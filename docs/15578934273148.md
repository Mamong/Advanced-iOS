第 16 章　正则表达式类

[TOC]

##16.1　关于正则表达式
###16.1.1　正则表达式的写法与用法

###16.1.2　正则表达式对象的创建方法
在程序中，通过用 // 将表示正则表达式模式的字符串括起来，就可以非常简单地创建出正则表达式。

另外，我们也可以使用类方法 Regexp.new(str) 来创建对象。当程序中已经定义了字符串对象 str，且希望根据这个字符串来创建正则表达式时，用这个方法会比较好。

我们也可以通过使用 % 的特殊语法来创建。正则表达式的情况下使用的是 %r，如果正则模式中包含 /，用这种方法会比较方便。语法如下所示：
%r (模式)
%r <模式>
%r |模式|
%r! 模式!

##16.2　正则表达式的模式与匹配
=~ 方法是正则表达式中常用的方法，可以用来判断正则表达式与指定字符串是否匹配。

正则表达式 =~ 字符串

无法匹配时返回 nil，匹配成功则返回该字符串起始字符的位置。

Ruby 会将 nil 与 false 解析为“假”，将除此以外的值解析为“真”，因此，如果要根据匹配结果执行不同的处理，则可以像下面这样写。

if 正则表达式 =~ 字符串
　匹配时的处理
else
　不匹配时的处理
end

我们还可以使用 !~ 来颠倒“真”与“假”。

###16.2.1　匹配普通字符
类似/ABC/
###16.2.2　匹配行首与行尾
类似/^ABC$/
^、$ 是有特殊意义的字符。但它们并不用于匹配 ^ 与 $ 字符。像这样的特殊字符，我们称之为元字符（meta character）。在稍后的章节中，我们会介绍 ^、$ 以外的其他元字符。

^ 表示匹配行首，$ 表示匹配行尾（表 16.2）。也就是说，模式 /^ABC/ 匹配行首为 ABC 的字符串，模式 /ABC$/ 匹配行尾为 ABC 的字符串。

匹配字符串的开头用元字符 \A，匹配字符串的末尾用元字符 \z。还有一个与 \z 类似的表现，就是 \Z，不过两者的作用有点不一样。\Z 虽然也是匹配字符串末尾的元字符，但它有一个特点，就是如果字符串末尾是换行符，则匹配换行符前一个字符。

###16.2.3　指定匹配字符的范围
[012ABC]　……0、1、2、A、B、C中的1个字符
[A-Za-z] 　……从A到Z与从a到z的全部英文字母
[0-9]　 　　……从0到9 的全部数字

在 [] 的开头使用 ^ 时，^ 表示指定字符以外的字符。
[^a-zA-Z] ……a 到 z，A 到 Z（英文字母）以外的字符
###16.2.4　匹配任意字符
. ……匹配任意字符
在下面两种情况下，一般会使用这个元字符。

在希望指定字符数时使用
/^...$/ 这样的模式可以匹配字符数为 3 的行。

与稍后介绍的元字符 * 配合使用
###16.2.5　使用反斜杠的模式
\s:表示空白符，匹配空格（0x20）、制表符（Tab）、换行符、换页符
\d:匹配 0 到 9 的数字
\w:匹配英文字母与数字
\A:匹配字符串的开头
\z:匹配字符串的末尾

元字符转义
我们还可以用 \ 对元字符进行转义。在 \ 后添加 ^、$、[ 等非字母数字的元字符后，该元字符就不再发挥元字符的功能，而是直接被作为元字符本身来匹配
###16.2.6　重复
\* ……重复 0 次以上
\+ ……重复 1 次以上
? ……重复 0 次或 1 次
###16.2.7　最短匹配
匹配 0 次以上的 * 以及匹配 1 次以上的 + 会匹配尽可能多的字符 1。相反，匹配尽可能少的字符 2 时（重复后的模式首次出现的位置之前的部分），我们可以用以下元字符：

1也称贪婪匹配。——译者注
2也称懒惰匹配。——译者注

*? ……0 次以上的重复中最短的部分
+? ……1 次以上的重复中最短的部分
###16.2.8　() 与重复
通过使用 ()，我们还可以重复匹配多个字符
###16.2.9　选择
我们可以用 | 在几个候补模式中匹配任意一个.


##16.3　使用 quote 方法的正则表达式
有时候我们可能会希望转义（escape）正则表达式中的所有元字符。而 quote 方法就可以帮我们实现这个想法。quote 方法会返回转义了元字符后的正则表达式字符串，然后再结合 new 方法，就可以生成新的正则表达式对象了。
```
re1 = Regexp.new("abc*def")
re2 = Regexp.new(Regexp.quote("abc*def"))
p (re1 =~ "abc*def")    #=> nil
p (re2 =~ "abc*def")    #=> 0
```
quote 方法的问题在于不能以元字符的格式写元字符。因此，在写一些复杂的正则表达式时，建议不要使用 quote 方法，而是乖乖地对元字符进行转义。
##16.4　正则表达式的选项
设定正则表达式的选项时，只需在 /…/ 的后面指定即可，如 /… /im，这里的 i 以及 m 就是正则表达式的选项。

i
忽略英文字母大小写的选项。指定这个选项后，无论字符串中的字母是大写还是小写都会被匹配。

x
忽略正则表达式中的空白字符以及 # 后面的字符的选项。指定这个选项后，我们就可以使用 # 在正则表达式中写注释了。

m
指定这个选项后，就可以使用 . 匹配换行符了。

Regexp.new 方法中的第 2 个参数可用于指定选项常量。只需要 1 个参数时，可不指定第 2 个参数或者直接指定 nil。

例如，/Ruby 脚本 /i 这一正则表达式，可以像下面那样写：
```
Regexp.new("Ruby 脚本"， Regexp::IGNORECASE)
```
另外，我们还可以用 | 指定多个选项。这时，/Ruby 脚本 /im 这一正则表达式就变成了下面这样：
```
Regexp.new("Ruby 脚本",
            Regexp::IGNORECASE | Regexp::MULTILINE)
```

##16.5　捕获
除了检查字符是否匹配外，正则表达式还有另外一个常用功能，甚至可以说是比匹配更加重要的功能——捕获（后向引用）。

所谓捕获，就是从正则表达式的匹配部分中提取其中的某部分。通过“$ 数字”这种形式的变量，就可以获取匹配了正则表达式中的用 () 括住的部分的字符串。

在进行匹配的时候，我们只知道是否匹配、匹配第几个字符之类的信息。而使用捕获后，我们就可以知道哪部分被匹配了。因此，通过这个功能，我们就可以非常方便地对字符串进行分析。

在 16.2.8 节中我们提到了 () 也被用于将多个模式整理为一个。在修改程序中的正则表达式时，如果改变了 () 的数量，那么将要引用的部分的索引也会随之改变，有时就会带来不便。这种情况下，我们可以使用 (?: ) 过滤不需要捕获的模式。
```
/(.)(\d\d)+(.)/ =~ "123456"
p $1    #=> "1"
p $2    #=> "45"
p $3    #=> "6"
/(.)(?:\d\d)+(.)/ =~ "123456"
p $1    #=> "1"
p $2    #=> "6"
```
除了“\$数字”这种形式以外，保存匹配结果的变量还有\$、\$&、\$\`，分表代表匹配部分前的字符串、匹配部分的字符串、匹配部分后的字符串。
```
/C./ =~ "ABCDEF"
p $`    #=> "AB"
p $&    #=> "CD"
p $'    #=> "EF"
```
这样一来，我们就可以将字符串整体分为匹配部分与非匹配部分，并将其分别保存在 3 个不同的变量中。
##16.6　使用正则表达式的方法
字符串相关的方法中有一些使用了正则表达式，接下来我们就来介绍一下其中的 sub 方法、gsub 方法、scan 方法。
###16.6.1　sub 方法与 gsub 方法
sub 方法与 gsub 方法的作用是用指定的字符置换字符串中的某部分字符。

sub 方法与 gsub 方法都有两个参数。第 1 个参数用于指定希望匹配的正则表达式的模式，第 2 个参数用于指定与匹配部分置换的字符。sub 方法只置换首次匹配的部分，而 gsub 方法则会置换所有匹配的部分。
```
str = "abc   def  g   hi"
p str.sub(/\s+/,' ')     #=> "abc def  g   hi"
p str.gsub(/\s+/,' ')    #=> "abc def g hi"
```
sub 方法与 gsub 方法也有带 ! 的方法。sub! 方法与 gusb! 方法会直接将作为接受者的对象变换为置换后的字符串。

###16.6.2　scan 方法
scan 方法能像 gsub 方法那样获取匹配部分的字符，但不能做置换操作。因此，当需要对匹配部分做某种处理时，可以使用该方法。
```
"abracatabra".scan(/.a/) do |matched|
  p matched
end

> ruby scan1.rb
"ra"
"ca"
"ta"
"ra"
```

在正则表达式中使用 () 时，匹配部分会以数组的形式返回
```
"abracatabra".scan(/(.)(a)/) do |matched|
  p matched
end

> ruby scan2.rb
["r", "a"]
["c", "a"]
["t", "a"]
["r", "a"]
```

如果指定与 () 相等数量的块参数，则返回的结果就不是数组，而是各个元素
```
"abracatabra".scan(/(.)(a)/) do |a, b|
  p a+"-"+b
end

> ruby scan3.rb
"r-a"
"c-a"
"t-a"
"r-a"
```

如果没有指定块，则直接返回匹配的字符串数组。
```
p "abracatabra".scan(/.a/)    #=> ["ra", "ca", "ta", "ra"]
```
##16.7　正则表达式的例子