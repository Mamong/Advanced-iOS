# 字节对齐算法

 字节对齐是在分配内存时需要考虑的问题，两个小算法：

(1)最容易想到的算法:
```c
    unsigned int calc_align(unsigned int n,unsigned align)  
    {  
        if ( n / align * align == n)  
                return n;  
      
            return  (n / align + 1) * align;  
    }  
```
 (2)更好的算法：
 ```c
    unsigned int calc_align(unsigned int n,unsigned align)  
    {  
        return ((n + align - 1) & (~(align - 1)));  
    }  
 ```
 对于2算法原理如下：

2字节对齐，要求地址位为2,4,6,8...，要求二进制位最后一位为0（2的1次方）
4字节对齐，要求地址位为4,8,12,16...，要求二进制位最后两位为0（2的2次方）
8字节对齐，要求地址位为8,16,24,32...，要求二进制位最后三位为0（2的3次方）
16字节对齐，要求地址位为16,32,48,64...，要求二进制位最后四位为0（2的4次方）
...
由此可见，我们只要对数据补齐对齐所需最少数据，然后将补齐位置0就可以实现对齐计算。
 
（1）(align-1)，表示对齐所需的对齐位，如：2字节对齐为1，4字节为11，8字节为111，16字节为1111...
（2）(x+(align-1))，表示x补齐对齐所需数据      
（3）&~(align-1)，表示去除由于补齐造成的多余数据
（4） (x+(align-1))&~(align-1)，表示对齐后的数据

举个例子：如8字节对齐。起始地始是6
6 + （8 - 1）=0000 0110 + 0000 0111 = 0000 1101
0000 1101 & ~(0000 0111) = 0000 1000  //去除由于补齐造成的多余数据
