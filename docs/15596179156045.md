AFNetworking源码分析

[TOC]

##类图
AFURLSessionManager
|----AFHTTPSessionManager


AFHTTPRequestSerializer\<AFURLRequestSerialization>
|----AFJSONRequestSerializer
|----AFPropertyListRequestSerializer

AFHTTPResponseSerializer\<AFURLResponseSerialization>
|----AFJSONResponseSerializer
|----AFXMLParserResponseSerializer
|----AFXMLDocumentResponseSerializer
|----AFPropertyListResponseSerializer
|----AFImageResponseSerializer
|----AFCompoundResponseSerializer


AFNetworkReachabilityManager

AFSecurityPolicy

##session task
首先简单介绍下session task，以下语句引用自[从 NSURLConnection 到 NSURLSession](http://objccn.io/issue-5-4/)

NSURLsessionTask 是一个抽象类，其下有 3 个实体子类可以直接使用：NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask。这 3 个子类封装了现代程序三个最基本的网络任务：获取数据，比如 JSON 或者 XML，上传文件和下载文件。

NSURLSessionTask class diagram

当一个 NSURLSessionDataTask 完成时，它会带有相关联的数据，而一个 NSURLSessionDownloadTask 任务结束时，它会带回已下载文件的一个临时的文件路径（还记得前面的location吧）。因为一般来说，服务端对于一个上传任务的响应也会有相关数据返回，所以NSURLSessionUploadTask 继承自 NSURLSessionDataTask。

之前讨论dataTask比较多，对于uploadTask和downloadTask提及较少。比如我们之前只说了- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]。其实还有类似的uploadTaskWithRequest:和downloadTaskWithRequest:等方法。

不知道大家看到这里会不会跟我一样有疑问——已经有了dataTask了，为什么还要实现一个uploadTask？我们从两者提供的对应task 生成的方法能看出一点端倪。比如使用dataTask来进行上传任务的时候，需要指定HTTPMethod为POST或PUT，并且提供的数据（NSData）得赋值给request.HTTPBody。而使用uploadTask来进行上传任务的时候，只需要使用- uploadTaskWithRequest:fromData:或- uploadTaskWithRequest:fromFile:之类的方法，其中参数的话只需要根提供数据（NSData）或者数据的磁盘位置（NSURL*fileURL）就可以构造出一个上传的session task了，简化了操作。

至于uploadTaskWithRequest:和downloadTaskWithRequest:等方法实现上本质和dataTaskWithRequest:并没有多大区别，这里对于相同的地方就不赘述了，主要提几点不同的地方，而这几点不同的地方根本在于系统提供了不同session task生成方法：

1. 系统提供的uploadTask构建方法：

    uploadTaskWithRequest:fromFile: 根据fileURL创建request

对应AFNetworking中的uploadTaskWithRequest:fromFile:progress:completionHandler:方法，关于这个方法，里面使用到了attemptsToRecreateUploadTasksForBackgroundSessions变量，这个是用于创建后台task时使用的。因为在iOS7中，有时候创建后台task会失败，Apple建议如果创建失败了，就重新尝试创建。此处尝试的次数最大为AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask，默认为3。至于其中使用到的addDelegateForUploadTask:地实现基本同addDelegateForDataTask:实现。

详见源码。

    uploadTaskWithRequest:fromData: 根据需要上传的NSData创建request

对应AFNetworking中的uploadTaskWithRequest:fromData:progress:completionHandler:方法。

详见源码。

    uploadTaskWithStreamedRequest: 使用该函数必须要实现URLSession:task:needNewBodyStream:来给上传任务提供数据

对应AFNetworking中的uploadTaskWithRequest:fromData:progress:completionHandler:方法。

详见源码。

2. 系统提供的downloadTask构建方法：

    downloadTaskWithRequest: 不赘述

对应AFNetworking中的downloadTaskWithRequest:progress:destination:completionHandler:方法，注意此处多了一个destination。destination是一个block：
```
(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
```
该block表示下载后的文件最后如何放置，返回的是一个NSURL*变量。具体使用请看addDelegateForDownloadTask:
```
    - (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask
                              progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock
                           destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
                     completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler
    {
        // ......
     
        if (destination) {
            // 会调用setDownloadTaskDidFinishDownloadingBlock:方法，生成最终下载文件放置位置
            delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) {
                return destination(location, task.response);
            };
        }
        // ......
    }
```

    downloadTaskWithResumeData: 用于断点续传，resumeData就是上一篇文章中提到的用于提供断点续传的信息。

对应AFNetworking中的downloadTaskWithResumeData:progress:destination:completionHandler:方法。



##AFHTTPSessionManager
```
- (NSURLSessionDataTask *)GET:(NSString *)URLString
                   parameters:(id)parameters
                      headers:(nullable NSDictionary <NSString *, NSString *> *)headers
                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress
                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
{
    
    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"GET"
                                                        URLString:URLString
                                                       parameters:parameters
                                                          headers:headers
                                                   uploadProgress:nil
                                                 downloadProgress:downloadProgress
                                                          success:success
                                                          failure:failure];
    
    [dataTask resume];
    
    return dataTask;
}
```
上面的实现中：
    使用dataTaskWithHTTPMethod方法创建了一个NSURLSessionDataTask
    调用NSURLSessionDataTask的resume来开启这个session task

我们很自然想到了，所有的关键都在dataTaskWithHTTPMethod这个函数。我们先不慌看这个函数的具体实现，先穷尽到这个函数的所有调用。我们已经知道这个函数是创建一个NSURLSessionDataTask，而系统提供给我们创建NSURLSessionDataTask的方法，有两个：

1.–dataTaskWithRequest:
2.–dataTaskWithRequest:completionHandler:

好，那我们就沿着这个线索一直找下去，一直找到有这两个函数使用的地方。追踪溯源，还真找到了这样一条函数调用栈。
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160116174901960-724693422.png)

上图可以看出GET、HEAD、POST、PUT、PATCH、DELETE这些方法实现的不同之处只在于调用dataTaskWithHTTPMethod:传递的method名称不同。另外在调用dataTaskWithRequest:时候，其实已经在上一级函数dataTaskWithHTTPMethod:中构建好了一个NSMutableURLRequest类型的request。所以我们主要研究dataTaskWithHTTPMethod:函数实现。

dataTaskWithHTTPMethod函数的实现主要分两部分，一部分是构建NSMutableURLRequest，另一部分是根据已构建好的Request来构建NSURLSessionDataTask。

##completionHandler
在AFURLSessionManager的头文件中，可以看到开放了两个相关属性：completionQueue、completionGroup ，前者是用来指定回调队列的，后者用来指定关联的group，不过这两个属性是给请求落地的回调（也就是completionHandler）用的。

因此结论是若上层没有指定回调队列，请求落地的回调默认在主线程执行。
###2.1 构建NSMutableURLRequest

此处构建request分为两个部分：

    1.先调用AFHTTPRequestSerializer的requestWithMethod函数构建request
    2.处理request构建产生的错误 – serializationError

####2.1.1 requestWithMethod构建request

先直接暴力列出requestWithMethod的函数声明（注：requestWithMethod是AFHTTPRequestSerializer的一个成员函数，并且AFHTTPRequestSerializer遵循AFURLRequestSerialization协议）
```
    /**
     使用指定的HTTP method和URLString来构建一个NSMutableURLRequest对象实例
     如果method是GET、HEAD、DELETE，那parameter将会被用来构建一个基于url编码的查询字符串（query url）
     ，并且这个字符串会直接加到request的url后面。对于其他的Method，比如POST/PUT，它们会根
     据parameterEncoding属性进行编码，而后加到request的http body上。
     @param method request的HTTP methodt，比如 `GET`, `POST`, `PUT`, or `DELETE`. 该参数不能为空
     @param URLString 用来创建request的URL
     @param parameters 既可以对method为GET的request设置一个查询字符串(query string)，也可以设置到request的HTTP body上
     @param error 构建request时发生的错误
     @return  一个NSMutableURLRequest的对象
     */
    - (NSMutableURLRequest *)requestWithMethod:(NSString *)method
                                     URLString:(NSString *)URLString
                                    parameters:(nullable id)parameters
                                         error:(NSError * _Nullable __autoreleasing *)error;
```
接着我们来看requestWithMethod的具体实现：
* 第一步：进行url转化和参数化断言

```
    NSParameterAssert(method);
    NSParameterAssert(URLString);
    NSURL *url = [NSURL URLWithString:URLString];
    NSParameterAssert(url);
```
其中NSParameterAssert(method) <=> NSParameterAssert(method != nil)，同理NSParameterAssert(URLString)和NSParameterAssert(url)也一样。这里NSHipster给出了一个金科玉律：

方法或函数应当在代码最开始处使用 NSParameterAssert / NSCParameterAssert 来强制输入的值满足先验条件，这是一条金科玉律；其他情况下使用 NSAssert / NSCAssert。

* 第二步：使用url构建并初始化NSMutableURLRequest，然后设置HTTPMethod

```
    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];
    mutableRequest.HTTPMethod = method;
```
* 第三步：给NSMutableURLRequest自带的属性赋值

```
for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
        }
    }
```
NSURLRequest/NSMutableURLRequest需要赋值的属性可以在AFHTTPRequestSerializerObservedKeyPaths()中找到，我们可以进去看一下：
```
static NSArray * AFHTTPRequestSerializerObservedKeyPaths() {
    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];
    });

    return _AFHTTPRequestSerializerObservedKeyPaths;
}
```
简单介绍下上面添加的keypath：
```
    /**
     是否允许使用设备的蜂窝移动网络来创建request，默认为允许:
     */
    @property (nonatomic, assign) BOOL allowsCellularAccess;
    /**
     创建的request所使用的缓存策略，默认使用`NSURLRequestUseProtocolCachePolicy`，该策略表示 
     如果缓存不存在，直接从服务端获取。如果缓存存在，会根据response中的Cache-Control字段判断
     下一步操作，如: Cache-Control字段为must-revalidata, 则 询问服务端该数据是否有更新，无更新话
     直接返回给用户缓存数据，若已更新，则请求服务端.
     */
    @property (nonatomic, assign) NSURLRequestCachePolicy cachePolicy;
    /**
     如果设置HTTPShouldHandleCookies为YES，就处理存储在NSHTTPCookieStore中的cookies
     HTTPShouldHandleCookies表示是否应该给request设置cookie并随request一起发送出去
     */
    @property (nonatomic, assign) BOOL HTTPShouldHandleCookies;
    /**
     HTTPShouldUsePipelining表示receiver(理解为iOS客户端)的下一个信息是否必须等到上一个请求回复才能发送。
     如果为YES表示可以，NO表示必须等receiver收到先前的回复才能发送下个信息。
     */
    @property (nonatomic, assign) BOOL HTTPShouldUsePipelining;
    /**
     设定request的network service类型. 默认是`NSURLNetworkServiceTypeDefault`.
     这个network service是为了告诉系统网络层这个request使用的目的
     比如NSURLNetworkServiceTypeVoIP表示的就这个request是用来请求网际协议通话技术(Voice over IP)。

     系统能根据提供的信息来优化网络处理，从而优化电池寿命，网络性能等等
     */
    @property (nonatomic, assign) NSURLRequestNetworkServiceType networkServiceType;
    /**
     超时机制，默认60秒
     */
    @property (nonatomic, assign) NSTimeInterval timeoutInterval;
```
然后通过判断mutableObservedChangedKeyPaths（NSMutableSet）中是否有这个keyPath，来设定mutableRequest对应的keyPath值。
```


    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) {
        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) {
            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];
        }
    }
```
至于mutableObservedChangedKeyPaths是什么，我们可以在AFURLRequestSerialization文件中的observeValueForKeyPath函数中得到答案。整个过程是这样的：
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160117190120757-1231141652.png)
关键就是在哪里会产生keypath的值变化了的消息？
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160117190144835-1057742407.png)
也就是说你只要使用了keyPath对应的的setter方法，就会响应observerValueForKeyPath这个方法，从而将对应的keyPath添加到了mutableObservedChangedKeyPaths。至于添加keyPath到observer中，那是在AFHTTPRequestSerializer的init中干的活：
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160117190627366-389648912.png)

* 第四步：将传入的parameters进行编码，并添加到request中。
此过程主要集中在requestBySerializingRequest这个函数中。在介绍requestBySerializingRequest之前，先简单介绍下，为什么会有这个函数的存在？
引用自[AFNetworking2.0源码解析<二>](http://www.cocoachina.com/ios/20140904/9523.html) ：

一般我们请求都会按key=value的方式带上各种参数，GET方法参数直接加在URL上，POST方法放在body上，NSURLRequest没有封装好这个参数的解析，只能我们自己拼好字符串。AFNetworking提供了接口，让参数可以是NSDictionary, NSArray, NSSet这些类型，再由内部解析成字符串后赋给NSURLRequest。

转化过程大致是这样的：
```
    @{ 
         @"name" : @"bang", 
         @"phone": @{@"mobile": @"xx", @"home": @"xx"}, 
         @"families": @[@"father", @"mother"], 
         @"nums": [NSSet setWithObjects:@"1", @"2", nil] 
    } 
    -> 
    @[ 
         field: @"name", value: @"bang", 
         field: @"phone[mobile]", value: @"xx", 
         field: @"phone[home]", value: @"xx", 
         field: @"families[]", value: @"father", 
         field: @"families[]", value: @"mother", 
         field: @"nums", value: @"1", 
         field: @"nums", value: @"2", 
    ] 
    -> 
    name=bang&phone[mobile]=xx&phone[home]=xx&families[]=father&families[]=mother&nums=1&num=2
```
或者看下面这段解释：

比如说我定义了下面这个parameter：
```
    NSString *URLString = @"http://example.com";
    NSDictionary *parameters = @{@"foo": @"bar", @"baz": @[@1, @2, @3]};
```
使用GET方式，最后得到的request是这样的：
```
[[AFHTTPRequestSerializer serializer] requestWithMethod:@"GET" URLString:URLString parameters:parameters error:nil];
    GET http://example.com?foo=bar&baz[]=1&baz[]=2&baz[]=3
```
或者使用POST方式，最后得到的request是这样的：
```
    [[AFHTTPRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];
    POST http://example.com/
    Content-Type: application/x-www-form-urlencoded
    foo=bar&baz[]=1&baz[]=2&baz[]=3
```
requestBySerializingRequest也分为三个部分(AFURLRequestSerialization协议中的方法)：

**第一部分**
设置request的http header field：
```
 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {
        if (![request valueForHTTPHeaderField:field]) {
            [mutableRequest setValue:value forHTTPHeaderField:field];
        }
    }];
```
这里关于http header field的值都存放在了HTTPRequestHeaders中了。至于HTTPRequestHeaders的设置，是在多个函数中都有设置的。此处就不一一赘述，后面遇到会详解。

**第二部分**
根据parameter来构建查询字符串，这里一开始parameter如下：
```
    Printing description of parameters:
    {
        baz =     (
            1,
            2,
            3
        );
        foo = bar;
    }
```
经过构建后，得到query为(这个例子中的构建方式使用的是AFQueryStringFromParameters()函数)：
```
Printing description of query:
    baz[]=1&baz[]=2&baz[]=3&foo=bar
```
事实上代码中有两种构建query的方式：

其中一种就是，如果自定义了queryStringSerialization（AFQueryStringSerializationBlock的block变量）。那么就使用自定义的queryStringSerialization构建方式（此方法在AFNetworking的test中用的比较多）

还有一种就是上面的那个AFQueryStringFromParameters()函数，我们可以看到AFQueryStringFromParameters的调用结构是下图这样的：
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160118114531482-1545230990.png)

讲解的话，我觉得根据上图从后往前讲比较好：

首先看NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value)这个函数

该函数首先定义了一个NSSortDescriptor *sortDescriptor：
```


    // 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:
    // 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数
    // 即@[@"foo", @"bar", @"bae"] ----> @[@"bae", @"bar",@"foo"]
    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"description" ascending:YES selector:@selector(compare:)];
```
接着会对value的类型进行判断，有NSDictionary、NSArray、NSSet类型。不过有人就会问了，在AFQueryStringPairsFromDictionary中给AFQueryStringPairsFromKeyAndValue函数传入的value不是NSDictionary嘛？还要判断那么多类型干啥？对，问得很好，这就是AFQueryStringPairsFromKeyAndValue的核心----递归调用并解析，你不能保证NSDictionary的value中存放的是一个NSArray、NSSet。

既然是递归，那么就要有结束递归的情况，比如解析到最后，对应value是一个NSString，那么就得调用函数中最后的else语句：
```
    else {
        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];
    }
```
注意此处定义了一个AFQueryStringPair:
```
@interface AFQueryStringPair : NSObject
@property (readwrite, nonatomic, strong) id field;
@property (readwrite, nonatomic, strong) id value;
// ...
@end
```
而initWithField做的就是将key赋给field，value赋值给value。大家可以回头看一下最开始举的那个例子，就产生了对应的field-value。

接着回到AFQueryStringPairsFromDictionary函数，好像没啥好说的。再回到AFQueryStringFromParameters函数，这个函数就是把这些构建好的AFQueryStringPair一个个用&连接好。这里注意一点就是，此处会对AFQueryStringPair使用其URLEncodedStringValue函数做一定的处理，其实就是Percent-encoding（百分号编码）。

**知识点：百分号编码**

根据RFC 3986，以下字符为保留字：
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160118114532482-1613937070.png)
另外，在RFC 3989 – Section 3.4部分，“？”和“/”当作为URL中的query string的时候，不再当做保留字。

此处主要是通过stringByAddingPercentEncodingWithAllowedCharacters函数来给我们的string进行百分号编码的。其中stringByAddingPercentEncodingWithAllowedCharacters函数需要传入不需要百分号编码的字符集（也就是不包括上面说的保留字，即函数中构建的allowedCharacterSet）。另外，为了防止![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160118114533060-725806998.png)字符造成的问题，此处还需要使用rangeOfComposedCharacterSequencesForRange函数来处理字符长度。

举个例子，如果我传入的字符串为image，那么最终得到的百分号编码的字符串为

poloby%3A%23mulberry%5B%5D%40%F0%9F%91%B4%F0%9F%8F%BB%F0%9F%91%AE%F0%9F%8F%BD

下图是保留字的百分号编码：
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160118114534513-642589046.png)
所以事实上，上面最终生成的query url中，[]都会被%5B%5D所代替。

**第三部分**
最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。

如果method是GET、HEAD、DELETE等。最后将query合并到mutbleRequest的query url上。不过这里还是要分情况讨论，如果request的query url不为空，就在生成的query前拼接&字符，再拼接到原先的query url上，如果request的query url为空，就将生成的的query前拼接？字符，再拼接到request的url上。
```
Printing description of mutableRequest:
    <NSMutableURLRequest: 0x7f9a63f237c0> { URL: https://api.app.net/stream/0/posts/stream/global?baz%5B%5D=1&baz%5B%5D=2&baz%5B%5D=3&foo=bar }
```
如果method是POST、PUT等。最后将query设置到http body上。另外，在此之前，函数会判断request的Content-Type是否设置了，如果没有，就默认设置为application/x-www-form-urlencoded。

####处理serializationError
生成request出错了怎么办？这里冒出了一个completionQueue，暂时不管它，因为我并不知道这个东西是怎么用的。一般的话，我们都是在main queue来执行自定义的failure函数处理error。

###构建NSURLSessionDataTask
有了request后，就可以调用-[AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]来构建session data task。

同样地，dataTaskWithRequest函数也分为两个部分。第一部分是创建一个dataTask，第二个部分是调用addDelegateForDataTask这个函数，具体这个函数是做什么的，目前我也不是很清楚。

####创建dataTask
使用了url_session_manager_create_task_safely(dispatch_block_t block)这个函数。这个函数主要的目的是为了解决iOS8之前的一个bug，详见https://github.com/AFNetworking/AFNetworking/issues/2093。在这个issue中，提问者建议版本小于iOS8的使用QUEUE_SERIAL的dispatch。所以才有了url_session_manager_create_task_safely这个函数，注意函数名中的create task和safely。由于在iOS8之后，这个bug被修复了，所以直接调用block()即可。
```
    static void url_session_manager_create_task_safely(dispatch_block_t block) {
        if (NSFoundationVersionNumber < NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) {
            // Fix of bug
            // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)
            // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093
            dispatch_sync(url_session_manager_creation_queue(), block);
        } else {
            block();
        }
    }
```

####addDelegateForDataTask
字面上理解的话，就是给data task添加了一个delegate，而这个delegate的类型为AFURLSessionManagerTaskDelegate。为什么要给task加一个delegate?

我们看看AFURLSessionManagerTaskDelegate的定义：
```
@interface AFURLSessionManagerTaskDelegate : NSObject <NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate>
```
这里我比较疑惑，NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate这三个delegate应该NSURLSession的delegate，你这边出现了一个AFURLSessionManagerTaskDelegate也来实现这三个delegate是几个意思？我猜测这里是不是一种分离的代码的方式，就是说把NSURLSession的delegate的实现分离出来给AFURLSessionManagerTaskDelegate实现。但是搜索了一下AFURLSessionManager中的session属性的构建：
```
self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];
```
官方对于delegateQueue参数的说明如下：
An operation queue for scheduling the delegate calls and completion handlers. The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.

根据描述，delegateQueue必须是一个串行队列，目的是为了使回调方法顺序执行。如何理解这个顺序执行？例如 URLSession: dataTask: didReceiveData: 方法，一个请求过程可能会回调多次，必须得保证这多个回调是时序的，否则进度回调就会有问题。如若使用并发队列，就无法保证时序了。AF里使用了一个自定义队列，并设置最大并发数为1，这就相当于是一个串行队列了。因此，请求的回调是在非主线程的线程中顺序执行的。若是将operationQueue设置为 [NSOperationQueue mainQueue] ，那就是在主线程中执行了。

这里的delegate并不是使用了AFURLSessionManagerTaskDelegate的那个delegate，所以上述猜测错误。不过我还是找到了点蛛丝马迹：

AFURLSessionManager中session（NSURLSession）的delegate设置为了AFURLSessionManager的self，并且AFURLSessionManager确实也遵循了NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate这三个协议，也实现了其中的方法。关键是实现这些方法时用到了AFURLSessionManagerTaskDelegate的delegate中实现的方法。至于为什么要这么做，话说我也是刚看，所以还需要消化一下。

注意addDelegateForDataTask:这个函数并不是AFURLSessionManagerTaskDelegate的函数，而是AFURLSessionManager的一个函数。这也侧面说明了AFURLSessionManagerTaskDelegate和NSURLSessionTask的关系是由AFURLSessionManager管理的。

该函数除了对于AFURLSessionManagerTaskDelegate类型的成员变量delegate设置之外，最关键的代码就是
```
[self setDelegate:delegate forTask:dataTask];
```
这个setDelegate:forTask:函数字面意思是将一个session task和一个AFURLSessionManagerTaskDelegate类型的delegate变量绑在一起，而这个绑在一起的工作是由我们的AFURLSessionManager所做。至于绑定的过程，就是以该session task的taskIdentifier为key，delegate为value，赋值给mutableTaskDelegatesKeyedByTaskIdentifier这个NSMutableDictionary类型的变量。知道了这两者是关联在一起的话，马上就会产生另外的问题 —— 为什么要关联以及怎么关联在一起？索性我们好好研究下setDelegate:forTask:这个函数：
```
    - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate
                forTask:(NSURLSessionTask *)task
    {
        NSParameterAssert(task);
        NSParameterAssert(delegate);
        [self.lock lock];
        self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
        [delegate setupProgressForTask:task];
        [self addNotificationObserverForTask:task];
        [self.lock unlock];
    }
```
代码首先是基本的判断，判断session task和delegate是否为空，这里实现方式（NSParameterAssert）每次看到都加深一下印象。接着就是使用NSLock来加锁，这个很简单，和@synchronized作用类似，不过@synchronized多了一个可以使用变量作为互斥信号量的功能，这里就不细说了。临界区的代码（lock和unlock之间的代码）也是分为三个部分：
```
    1. self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
    2. [delegate setupProgressForTask:task];
    3. [self addNotificationObserverForTask:task];
```
* 第一部分不赘述了。
* 第二部分我扫了下代码，好像是设置两个NSProgress的变量 - uploadProgress和downloadProgress。
* 第三部分就是给session task添加了两个KVO事件。

具体细节详述如下（包含第二部分和第三部分详述）：

####2.1 –[AFURLSessionManager setupProgressForTask:]
上面简单提了下该函数是为了设置uploadProgress和downloadProgress这两个NSProgress变量。这种设置也是很合理的，毕竟session task的任务中需要记录进度的，要不是上传任务，要不就是下载任务。

我们来看看setupProgressForTask:的具体实现：
```
    - (void)setupProgressForTask:(NSURLSessionTask *)task {
        __weak __typeof__(task) weakTask = task;
        self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;
        self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;
        [self.uploadProgress setCancellable:YES];
        [self.uploadProgress setCancellationHandler:^{
            __typeof__(weakTask) strongTask = weakTask;
            [strongTask cancel];
        }];
        [self.uploadProgress setPausable:YES];
        [self.uploadProgress setPausingHandler:^{
            __typeof__(weakTask) strongTask = weakTask;
            [strongTask suspend];
        }];
        if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) {
            [self.uploadProgress setResumingHandler:^{
                __typeof__(weakTask) strongTask = weakTask;
                [strongTask resume];
            }];
        }
        [self.downloadProgress setCancellable:YES];
        [self.downloadProgress setCancellationHandler:^{
            __typeof__(weakTask) strongTask = weakTask;
            [strongTask cancel];
        }];
        [self.downloadProgress setPausable:YES];
        [self.downloadProgress setPausingHandler:^{
            __typeof__(weakTask) strongTask = weakTask;
            [strongTask suspend];
        }];
        if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) {
            [self.downloadProgress setResumingHandler:^{
                __typeof__(weakTask) strongTask = weakTask;
                [strongTask resume];
            }];
        }
        [task addObserver:self
               forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))
                  options:NSKeyValueObservingOptionNew
                  context:NULL];
        [task addObserver:self
               forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))
                  options:NSKeyValueObservingOptionNew
                  context:NULL];
        [task addObserver:self
               forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))
                  options:NSKeyValueObservingOptionNew
                  context:NULL];
        [task addObserver:self
               forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))
                  options:NSKeyValueObservingOptionNew
                  context:NULL];
        [self.downloadProgress addObserver:self
                                forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                                   options:NSKeyValueObservingOptionNew
                                   context:NULL];
        [self.uploadProgress addObserver:self
                              forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
                                 options:NSKeyValueObservingOptionNew
                                 context:NULL];
    }
```
先是设置两个progress的totalUnitCount:
```  self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;
    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;
```
上传的totalUnitCount就对应期望发送(send)的数据大小，下载任务的就对应期望接收(receive)的数据大小。

接着就是设置这两个NSProgress对应的cancel、pause和resume这三个状态，正好对应session task的cancel、suspend和resume三个状态，详见上方源码。

最后一部分代码是关键，给session task和两个progress添加KVO。也就是说该AFURLSessionManager的对象需要观察以下属性：

    NSURLSessionTask的countOfBytesReceived、countOfBytesExpectedToReceive、countOfBytesSent、countOfBytesExpectedToSend属性
    NSProgress的fractionCompleted属性（任务已经完成的比例，取值为0~1）

看了KVO，马上跳到observeValueForKeyPath:ofObject:change:context:函数中：
```
    - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {
        if ([object isKindOfClass:[NSURLSessionTask class]]) {
            if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) {
                self.downloadProgress.completedUnitCount = [change[@"new"] longLongValue];
            } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) {
                self.downloadProgress.totalUnitCount = [change[@"new"] longLongValue];
            } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) {
                self.uploadProgress.completedUnitCount = [change[@"new"] longLongValue];
            } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) {
                self.uploadProgress.totalUnitCount = [change[@"new"] longLongValue];
            }
        }
        else if ([object isEqual:self.downloadProgress]) {
            if (self.downloadProgressBlock) {
                self.downloadProgressBlock(object);
            }
        }
        else if ([object isEqual:self.uploadProgress]) {
            if (self.uploadProgressBlock) {
                self.uploadProgressBlock(object);
            }
        }
    }
```
总结一下，也就是说
* downloadProgress.completedUnitCount 《==      countOfBytesReceived更新

* downloadProgress.totalUnitCount          《==      countOfBytesExpectedToReceive更新

* uploadProgress.completedUnitCount      《==      countOfBytesSent更新

* uploadProgress.totalUnitCount               《==      countOfBytesExpectedToSend更新

* 调用自定义的downloadProgressBlock        《==      downloadProgress.fractionCompleted更新

* 调用自定义的uploadProgressBlock             《==      uploadProgress.fractionCompleted更新

最后两个KVO事件中使用的block其实就是根据NSProgress的状态做用户自定义的行为，比如需要更新UI进度条的状态之类的。

####2.2 –[AFURLSessionManager addNotificationObserverForTask:]

```
    - (void)addNotificationObserverForTask:(NSURLSessionTask *)task {
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];
    }
```
此处如果往深的地方研究，会涉及到很多runtime甚至methodSwizzle的代码，后面会专门开一个章节，研究下这段代码。此处我们只需知道，当NSURLSessionTask调用resume函数时，会postNotificationName:AFNSURLSessionTaskDidResumeNotification，从而执行taskDidResume:方法：
```
    - (void)taskDidResume:(NSNotification *)notification {
        NSURLSessionTask *task = notification.object;
        if ([task respondsToSelector:@selector(taskDescription)]) {
            if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];
                });
            }
        }
    }
```
有了AFNetworkingTaskDidResumeNotification就方便了，之前我们UIRefreshControl+AFNEtworking中就使用AFNetworkingTaskDidResumeNotification作为NotificationName。同理，参考源码对AFNSURLSessionTaskDidSuspendNotification的处理，这里就不赘述了。

##AFURLSessionManager
AFURLSessionManager是对NSURLSession的封装。
AFHTTPSessionManager是对HTTP协议功能的封装，底层数据请求还是调用AFURLSessionManager。

直接来到AFURLSessionManager的初始化方法：
```
- (instancetype)init {
    return [self initWithSessionConfiguration:nil];
}

- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
    self = [super init];
    if (!self) {
        return nil;
    }
    if (!configuration) {
        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    }
    self.sessionConfiguration = configuration;
    self.operationQueue = [[NSOperationQueue alloc] init];
    //queue并发线程数设置为1
    self.operationQueue.maxConcurrentOperationCount = 1;

    //注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！
    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

    //各种响应转码
    self.responseSerializer = [AFJSONResponseSerializer serializer];

    //设置默认安全策略
    self.securityPolicy = [AFSecurityPolicy defaultPolicy];

#if !TARGET_OS_WATCH
    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
#endif
    // 设置存储NSURL task与AFURLSessionManagerTaskDelegate的词典（重点，在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理） ===============
    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

    //  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全
    self.lock = [[NSLock alloc] init];
    self.lock.name = AFURLSessionManagerLockName;

    // 置空task关联的代理
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {        
        for (NSURLSessionDataTask *task in dataTasks) {
            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
        }
        for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
        }
        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
        }
    }];
    return self;
}
```
这个就是最终的初始化方法了，注释应该写的很清楚，唯一需要说的就是三点：


self.operationQueue.maxConcurrentOperationCount = 1;这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。至于这里为什么要这么做，我们先留一个坑，等我们讲完AF2.x之后再来分析这一块。


第二就是我们初始化了一些属性，其中包括self.mutableTaskDelegatesKeyedByTaskIdentifier，这个是用来让每一个请求task和我们自定义的AF代理来建立映射用的，其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。
第三就是下面这个方法：
```
[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { 
}];
```
首先说说这个方法是干什么用的：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。
但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：[github](https://github.com/AFNetworking/AFNetworking/issues/3499) 。

原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。

初始化方法到这就全部完成了。

>https://www.jianshu.com/p/488c1f46cedd


###详解AFURLSessionManager的NSURLSession的相关代理

我们之前在看GET:等这些上层函数时，发现内部实现就是为了生成一个session task。而这个session task与网络具体如何交互，如何处理数据的方法，则是写在NSURLSession的相关代理方法中。虽然GET:这些方法是AFHTTPSessionManager的方法，但是AFURLSessionManager是AFHTTPSessionManager的父类，所以调用的NSURLSession的相关代理的实现其实是在AFURLSessionManager中实现的，我们可以看看AFURLSessionManager实现了哪些NSURLSession相关的代理方法：
```
### `NSURLSessionDelegate`
 - `URLSession:didBecomeInvalidWithError:`
 - `URLSession:didReceiveChallenge:completionHandler:`
 - `URLSessionDidFinishEventsForBackgroundURLSession:`
 ### `NSURLSessionTaskDelegate`
 - `URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`
 - `URLSession:task:didReceiveChallenge:completionHandler:`
 - `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`
 - `URLSession:task:didCompleteWithError:`
 ### `NSURLSessionDataDelegate`
 - `URLSession:dataTask:didReceiveResponse:completionHandler:`
 - `URLSession:dataTask:didBecomeDownloadTask:`
 - `URLSession:dataTask:didReceiveData:`
 - `URLSession:dataTask:willCacheResponse:completionHandler:`
 ### `NSURLSessionDownloadDelegate`
 - `URLSession:downloadTask:didFinishDownloadingToURL:`
 - `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesWritten:totalBytesExpectedToWrite:`
 - `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`
```
###3.1 NSURLSessionDelegate
####3.1.1 - URLSession:didBecomeInvalidWithError:
函数声明：
```
- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(NSError *)error
```
函数作用：

当前这个session已经失效时，该代理方法被调用。

函数讨论：

如果你使用finishTasksAndInvalidate函数使该session失效，那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
    didBecomeInvalidWithError:(NSError *)error
    {
        // 自定义的一个block，用来处理session无效的情况。
        // 此处插一句，刚才突然灵光一现，体验到了block的好处。具体说不清楚，
        // 我只能说好处就是此处并不是让用户自己实现didBecomeInvalidWithError:方法，
        // 而是让用户实现sessionDidBecomeInvalid这个block，隐藏细节。
        // 确实很妙，以后要学会使用block
        if (self.sessionDidBecomeInvalid) {
            self.sessionDidBecomeInvalid(session, error);
        }
        
        // 当一个session无效时，post名为AFURLSessionDidInvalidateNotification的Notification
        // 不过源代码中没有举例如何使用这个Notification，所以需要用户自己定义，比如结束进度条的显示啊。
        [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];
    }
```

####3.1.2 - URLSession:didReceiveChallenge:completionHandler:
函数声明：
```
- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * __nullable credential))completionHandler;
```
函数作用：

web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。最后调用completionHandler回应服务器端的挑战。

函数讨论：

该代理方法会在下面两种情况调用：

    1. 当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。
    2. 当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）

如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
    didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
     completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
    {
        //挑战处理类型为 默认
        /*
        NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理
        NSURLSessionAuthChallengeUseCredential：使用指定的证书
        NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战
        */
        NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
        __block NSURLCredential *credential = nil;
        // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战
        if (self.sessionDidReceiveAuthenticationChallenge) {
            disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &credential);
        } else {
            // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust
            // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。
            // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象
            if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
                // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战
                if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
                    // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书）
                    credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
                    // 确定挑战的方式 
                     if (credential) {
                        disposition = NSURLSessionAuthChallengeUseCredential;
                    } else {
                        disposition = NSURLSessionAuthChallengePerformDefaultHandling;
                    }
                } else {
                    // 取消挑战
                    disposition = NSURLSessionAuthChallengeRejectProtectionSpace;
                }
            } else {
                disposition = NSURLSessionAuthChallengePerformDefaultHandling;
            }
        }
        
        // 必须调用此方法，完成认证挑战
        if (completionHandler) {
            completionHandler(disposition, credential);
        }
    }
```
####3.1.3 – URLSessionDidFinishEventsForBackgroundURLSession:
函数声明：
```
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
```
函数作用：

当session中所有已经入队的消息被发送出去后，会调用该代理方法。

函数讨论：

在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler:消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。

当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。

函数实现：
```
    - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
        if (self.didFinishEventsForBackgroundURLSession) {
            // 意味着background session中的消息已经全部发送出去了，返回到主进程执行自定义的函数
            dispatch_async(dispatch_get_main_queue(), ^{
                self.didFinishEventsForBackgroundURLSession(session);
            });
        }
    }
```
###3.2 NSURLSessionTaskDelegate
####3.2.1 - URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:
函数声明：
```
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler
```
函数作用：

客户端告知服务器端需要HTTP重定向。

函数讨论：
此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。

知识点

对于NSURLSession对象的初始化需要使用NSURLSessionConfiguration，而NSURLSessionConfiguration有三个类工厂方法：

+defaultSessionConfiguration 返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享NSURLCredentialStorage。

+ephemeralSessionConfiguration 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。

+backgroundSessionConfiguration:(NSString *)identifier 的独特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
                  task:(NSURLSessionTask *)task
    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
            newRequest:(NSURLRequest *)request
     completionHandler:(void (^)(NSURLRequest *))completionHandler
    {
        NSURLRequest *redirectRequest = request;
        // 自定义如何处理重定向请求，注意会生成一个新的request
        if (self.taskWillPerformHTTPRedirection) {
            redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);
        }
        if (completionHandler) {
            completionHandler(redirectRequest);
        }
    }
```

####3.2.2 - URLSession:task:didReceiveChallenge:completionHandler:
函数声明：
```
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler
```
函数作用：

同NSURLSessionDelegate中的- URLSession:didReceiveChallenge:completionHandler:

函数讨论：

该方法是处理task-level的认证挑战。在NSURLSessionDelegate中提供了一个session-level的认证挑战代理方法。该方法的调用取决于认证挑战的类型：

    对于session-level的认证挑战，挑战类型有 — NSURLAuthenticationMethodNTLM, NSURLAuthenticationMethodNegotiate, NSURLAuthenticationMethodClientCertificate, 或NSURLAuthenticationMethodServerTrust — 此时session会调用其代理方法URLSession:didReceiveChallenge:completionHandler:。如果你的app没有提供对应的NSURLSessionDelegate方法，那么NSURLSession对象就会调用URLSession:task:didReceiveChallenge:completionHandler:来处理认证挑战。
    对于non-session-level的认证挑战，NSURLSession对象调用URLSession:task:didReceiveChallenge:completionHandler:来处理认证挑战。如果你在app中使用了session代理方法，而且也确实要处理认证挑战这个问题，那么你必须还是在task level来处理这个问题，或者提供一个task-level的handler来显式调用每个session的handler。而对于non-session-level的认证挑战，session的delegate中的URLSession:didReceiveChallenge:completionHandler:方法不会被调用。

函数实现：

参考URLSession:didReceiveChallenge:completionHandler:实现，除了自定义了taskDidReceiveAuthenticationChallenge这个block处理task-level的认证挑战，其他都一样。

####3.2.3 - URLSession:task:needNewBodyStream:

函数声明：
```
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler
```
函数作用：

当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。

函数讨论：

该代理方法会在下面两种情况被调用：

    如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。
    因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
                  task:(NSURLSessionTask *)task
     needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler
    {
        NSInputStream *inputStream = nil;
        if (self.taskNeedNewBodyStream) {
            // 自定义的获取到新的bodyStream方法
            inputStream = self.taskNeedNewBodyStream(session, task);
        } else if (task.originalRequest.HTTPBodyStream && [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) {
            // 拷贝一份数据出来到新的bodyStream中（即inputStream）
            inputStream = [task.originalRequest.HTTPBodyStream copy];
        }
        if (completionHandler) {
            completionHandler(inputStream);
        }
    }
```
####3.2.4 - URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:
函数声明：
```
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
```
函数作用：

周期性地通知代理发送到服务器端数据的进度。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
                  task:(NSURLSessionTask *)task
       didSendBodyData:(int64_t)bytesSent
        totalBytesSent:(int64_t)totalBytesSent
    totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
    {
        // 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount
        int64_t totalUnitCount = totalBytesExpectedToSend;
        if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
            NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@"Content-Length"];
            if(contentLength) {
                totalUnitCount = (int64_t) [contentLength longLongValue];
            }
        }
        // 每次发送数据后的相关自定义处理，比如根据totalBytesSent来进行UI界面的数据上传显示
        if (self.taskDidSendBodyData) {
            self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);
        }
    }
```
####3.2.5 - URLSession:task:didCompleteWithError:
函数声明：
```
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
```
函数作用：

告知该session task已经完成了数据传输任务。

函数讨论：

注意这里的error不会报告服务期端的error，他表示的是客户端这边的eroor，比如无法解析hostname或者连不上host主机。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
                  task:(NSURLSessionTask *)task
    didCompleteWithError:(NSError *)error
    {
        // 这里第一次展示了AFURLSessionManagerTaskDelegate的作用
        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];
        // 如果task是在后台完成的，可能delegate会为nil
        if (delegate) {
            // 调用了一样的代理方法，不过是AFURLSessionManagerTaskDelegate中实现的
            [delegate URLSession:session task:task didCompleteWithError:error];
            // 该task结束了，就移除对应的delegate
            [self removeDelegateForTask:task];
        }
        // 自定义处理方法
        if (self.taskDidComplete) {
            self.taskDidComplete(session, task, error);
        }
    }
```
###3.3 NSURLSessionDataDelegate
####3.3.1 - URLSession:dataTask:didReceiveResponse:completionHandler:

函数声明：
```
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler
```
函数作用：

告诉代理，该data task获取到了服务器端传回的最初始回复（response）。注意其中的completionHandler这个block，通过传入一个类型为NSURLSessionResponseDisposition的变量来决定该传输任务接下来该做什么：

    NSURLSessionResponseAllow 该task正常进行
    NSURLSessionResponseCancel 该task会被取消
    NSURLSessionResponseBecomeDownload 会调用URLSession:dataTask:didBecomeDownloadTask:方法来新建一个download task以代替当前的data task

函数讨论：

该方法是可选的，除非你必须支持“multipart/x-mixed-replace”类型的content-type。因为如果你的request中包含了这种类型的content-type，服务器会将数据分片传回来，而且每次传回来的数据会覆盖之前的数据。每次返回新的数据时，session都会调用该函数，你应该在这个函数中合理地处理先前的数据，否则会被新数据覆盖。如果你没有提供该方法的实现，那么session将会继续任务，也就是说会覆盖之前的数据。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
              dataTask:(NSURLSessionDataTask *)dataTask
    didReceiveResponse:(NSURLResponse *)response
     completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler
    {  
        // 默认方式为继续执行该task
        NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;
        // 自定义
        if (self.dataTaskDidReceiveResponse) {
            disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);
        }
        if (completionHandler) {
            completionHandler(disposition);
        }
    }
```
####3.3.2 - URLSession:dataTask:didBecomeDownloadTask:

函数声明：
```
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask
```
函数作用：

如果data task变化成了下载任务（download task），那么就会调用该代理方法

函数讨论：

比如在- URLSession:dataTask:didReceiveResponse:completionHandler:给completionHandler方法传递NSURLSessionResponseBecomeDownload，就会使data task变成download task。而且之前的data task不会再响应代理方法了。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
              dataTask:(NSURLSessionDataTask *)dataTask
    didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask
    {
        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
        if (delegate) {
            // 将delegate关联的data task移除，换成新产生的download task
            [self removeDelegateForTask:dataTask];
            [self setDelegate:delegate forTask:downloadTask];
        }
        // 自定义
        if (self.dataTaskDidBecomeDownloadTask) {
            self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);
        }
    }
```
####3.3.3 - URLSession:dataTask:didReceiveData:
函数声明：
```
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data
```
函数作用：

当接收到部分期望得到的数据（expected data）时，会调用该代理方法。

函数讨论：

一个NSData类型的数据通常是由一系列不同的数据整合到一起得到的，不管是不是这样，请使用- enumerateByteRangesUsingBlock:来遍历数据然不是使用bytes方法（因为bytes缺少enumerateByteRangesUsingBlock方法中的range，有了range，enumerateByteRangesUsingBlock就可以对NSData不同的数据块进行遍历，而不像bytes把所有NSData看成一个数据块）。

该代理方法可能会调用多次（比如分片获取数据），你需要自己实现函数将所有数据整合在一起。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
              dataTask:(NSURLSessionDataTask *)dataTask
        didReceiveData:(NSData *)data
    {
        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
        // 调用的是AFURLSessionManagerTaskDelegate的didReceiveData方法
        [delegate URLSession:session dataTask:dataTask didReceiveData:data];
        // 自定义
        if (self.dataTaskDidReceiveData) {
            self.dataTaskDidReceiveData(session, dataTask, data);
        }
    }
```
####3.3.4 - URLSession:dataTask:willCacheResponse:completionHandler:
函数声明：
```
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler
```
函数作用：

询问data task或上传任务（upload task）是否缓存response。

函数讨论：

当task接收到所有期望的数据后，session会调用此代理方法。如果你没有实现该方法，那么就会使用创建session时使用的configuration对象决定缓存策略。这个代理方法最初的目的是为了阻止缓存特定的URLs或者修改NSCacheURLResponse对象相关的userInfo字典。

该方法只会当request决定缓存response时候调用。作为准则，responses只会当以下条件都成立的时候返回缓存：

    该request是HTTP或HTTPS URL的请求（或者你自定义的网络协议，并且确保该协议支持缓存）
    确保request请求是成功的（返回的status code为200-299）
    返回的response是来自服务器端的，而非缓存中本身就有的
    提供的NSURLRequest对象的缓存策略要允许进行缓存
    服务器返回的response中与缓存相关的header要允许缓存
    该response的大小不能比提供的缓存空间大太多（比如你提供了一个磁盘缓存，那么response大小一定不能比磁盘缓存空间还要大5%）

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
              dataTask:(NSURLSessionDataTask *)dataTask
     willCacheResponse:(NSCachedURLResponse *)proposedResponse
     completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler
    {
        NSCachedURLResponse *cachedResponse = proposedResponse;
        // 自定义方法，你可以什么都不做，返回原始的cachedResponse，或者使用修改后的cachedResponse
        // 当然，你也可以返回NULL，这就意味着不需要缓存Response
        if (self.dataTaskWillCacheResponse) {
            cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);
        }
        if (completionHandler) {
            completionHandler(cachedResponse);
        }
    }
```
###3.4 NSURLSessionDownloadDelegate
####3.4.1 - URLSession:downloadTask:didFinishDownloadingToURL:（必须实现）
函数声明：
```
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location
```
函数作用：

告诉代理，该下载任务已完成。

函数实现：
```
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
    didFinishDownloadingToURL:(NSURL *)location
    {
        AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
        if (self.downloadTaskDidFinishDownloading) {
            // 自定义函数，根据从服务器端获取到的数据临时地址location等参数构建出你想要将临时文件移动的位置
            NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
            // 如果fileURL存在的话，表示用户希望把临时数据存起来
            if (fileURL) {
                delegate.downloadFileURL = fileURL;
                NSError *error = nil;
                // 将位于location位置的文件全部移到fileURL位置
                [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&error];
                if (error) {
                    // 如果移动文件失败，就发送AFURLSessionDownloadTaskDidFailToMoveFileNotification
                    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];
                }
                return;
            }
        }
        // 这一步比较诡异，感觉有重复的嫌疑。或许是为了兼容以前代码吧
        if (delegate) {
            [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];
        }
    }
```
####3.4.2 - URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:
函数声明：
```
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
```
函数作用：

周期性地通知下载进度。

函数实现：
```
    // bytesWritten 表示自上次调用该方法后，接收到的数据字节数
    // totalBytesWritten 表示目前已经接收到的数据字节数
    // totalBytesExpectedToWrite 表示期望收到的文件总字节数，是由Content-Length header提供。如果没有提供，默认是NSURLSessionTransferSizeUnknown
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
          didWriteData:(int64_t)bytesWritten
     totalBytesWritten:(int64_t)totalBytesWritten
    totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
    {
        // 自定义
        if (self.downloadTaskDidWriteData) {
            self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
        }
    }
```
####3.4.3 - URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:
函数声明：
```
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes
```
函数作用：

告诉代理，下载任务重新开始下载了。

函数讨论：

如果一个resumable（不是很会翻译）下载任务被取消或者失败了，你可以请求一个resumeData对象（比如在userInfo字典中通过NSURLSessionDownloadTaskResumeData这个键来获取到resumeData）并使用它来提供足够的信息以重新开始下载任务。随后，你可以使用resumeData作为downloadTaskWithResumeData:或downloadTaskWithResumeData:completionHandler:的参数。

当你调用这些方法时，你将开始一个新的下载任务。一旦你继续下载任务，session会调用它的代理方法URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:其中的downloadTask参数表示的就是新的下载任务，这也意味着下载重新开始了。

函数实现：
```
    // fileOffset如果文件缓存策略或者最后文件更新日期阻止重用已经存在的文件内容，那么该值为0。
    // 否则，该值表示已经存在磁盘上的，不需要重新获取的数据——— 这是断点续传啊！
    - (void)URLSession:(NSURLSession *)session
          downloadTask:(NSURLSessionDownloadTask *)downloadTask
     didResumeAtOffset:(int64_t)fileOffset
    expectedTotalBytes:(int64_t)expectedTotalBytes
    {
        if (self.downloadTaskDidResume) {
            self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);
        }
    }
```

##AFURLSessionManagerTaskDelegate

###2.1 NSURLSessionTaskDelegate
####2.1.1 - URLSession:task:didCompleteWithError:

该函数在AFURLSessionManager中的- URLSession:task:didCompleteWithError:被调用

函数实现：
```
    - (void)URLSession:(__unused NSURLSession *)session
                  task:(NSURLSessionTask *)task
    didCompleteWithError:(NSError *)error
    {
    // 保存clang诊断的上下文，类似OpenGL状态机，和后面的pop配对使用
    #pragma clang diagnostic push
    // 使用?:符号，注意x ? x : y == x ?: y,之前博客中要是有理解错误，以此为准
    #pragma clang diagnostic ignored "-Wgnu"
        __strong AFURLSessionManager *manager = self.manager;
        __block id responseObject = nil;
        
        // 因为NSNotification这个类中本身有userInfo属性，可作为响应函数的参数
        // 不过我在AFNetworking源码中还未发现使用userInfo作为参数的做法，可能需要用户自己实现
     
        /**

         * userInfo中的key值例举如下：
         * AFNetworkingTaskDidCompleteResponseDataKey session 存储task获取到的原始response数据，与序列化后的response有所不同
         * AFNetworkingTaskDidCompleteSerializedResponseKey 存储经过序列化（serialized）后的response
         * AFNetworkingTaskDidCompleteResponseSerializerKey 保存序列化response的序列化器(serializer)
         * AFNetworkingTaskDidCompleteAssetPathKey 存储下载任务后，数据文件存放在磁盘上的位置
         * AFNetworkingTaskDidCompleteErrorKey 错误信息
         */
        __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
        // serializer
        userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;
        //具体可以查看#issue 2672。这里主要是针对大文件的时候，性能提升会很明显
        NSData *data = nil;
        if (self.mutableData) { // 要先判断是否为nil
            data = [self.mutableData copy];
            //此处不再需要mutableData了
            self.mutableData = nil;
        }
        if (self.downloadFileURL) {
            userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
        } else if (data) {
            userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;
        }
        // 如果task出错了，处理error信息
        // 所以对应的观察者在处理error的时候，比如可以先判断userInfo[AFNetworkingTaskDidCompleteErrorKey]是否有值，有值的话，就说明是要处理error
        if (error) {
            userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;
           // 这里用group方式来运行task完成方法，表示当前所有的task任务完成，才会通知执行其他操作
            // 如果没有实现自定义的completionGroup和completionQueue，那么就使用AFNetworking提供的私有的dispatch_group_t和提供的dispatch_get_main_queue内容
            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
                if (self.completionHandler) {
                    self.completionHandler(task.response, responseObject, error);
                }
                dispatch_async(dispatch_get_main_queue(), ^{
                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
                });
            });
        } else {
            dispatch_async(url_session_manager_processing_queue(), ^{
                NSError *serializationError = nil;
                // 根据对应的task和data将response data解析成可用的数据格式，比如JSON serializer就将data解析成JSON格式
                responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&serializationError];
                // 注意如果有downloadFileURL，意味着data存放在了磁盘上了，所以此处responseObject保存的是data存放位置，供后面completionHandler处理。没有downloadFileURL，就直接使用内存中的解析后的data数据
                if (self.downloadFileURL) {
                    responseObject = self.downloadFileURL;
                }
     
                if (responseObject) {
                    userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
                }
                // 序列化的时候出现错误
                if (serializationError) {
                    userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
                }
                // 同上面的代码
                dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
                    if (self.completionHandler) {
                        self.completionHandler(task.response, responseObject, serializationError);
                    }
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
                    });
                });
            });
        }
    #pragma clang diagnostic pop
    }
```
###2.2 NSURLSessionDataDelegate
####2.2.1 - URLSession:dataTask:didReceiveData:

该函数在AFURLSessionManager中的- URLSession:dataTask:didReceiveData:被调用

函数实现：
```
    - (void)URLSession:(__unused NSURLSession *)session
              dataTask:(__unused NSURLSessionDataTask *)dataTask
        didReceiveData:(NSData *)data
    {
        // 将每次获得的新数据附在mutableData上，来组成最终获得的所有数据
        [self.mutableData appendData:data];
    }
```

###2.3 NSURLSessionDownloadDelegate
####2.3.1 - URLSession:downloadTask:didFinishDownloadingToURL:（必须实现）

该函数在AFURLSessionManager中的- URLSession:downloadTask:didFinishDownloadingToURL:被调用
函数实现：

和AFURLSessionManager中的实现类似，这里就不赘述了。

##Multipart协议
知识点：Multipart协议介绍 —— 详见HTTP协议之multipart/form-data请求分析，或者你看这篇文章https://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.2（一定要先看完）

这里简述一下：Multipart是HTTP协议为web表单新增的上传文件的协议，协议文档是rfc1867，它基于HTTP的POST方法，数据同样是放在body上，跟普通POST方法的区别是数据不是key=value形式，key=value形式难以表示文件实体，为此Multipart协议添加了分隔符（即boundary的概念），有自己的格式结构。

Multipart协议相关类和协议包括:
AFStreamingMultipartFormData,AFMultipartBodyStream,AFHTTPBodyPart类和AFMultipartFormData协议。

Multipart协议的结构，举个例子：
```
    --${bound} // 该bound表示pdf的文件名
    Content-Disposition: form-data; name="Filename"
     
    HTTP.pdf
    --${bound} // 该bound表示pdf的文件内容 
    Content-Disposition: form-data; name="file000"; filename="HTTP协议详解.pdf"
    Content-Type: application/octet-stream
     
    %PDF-1.5
    file content
    %%EOF
     
    --${bound} // 该bound表示字符串
    Content-Disposition: form-data; name="Upload"
     
    Submit Query
    --${bound}—// 表示body结束了
```

###Multipart的使用
我们如果想使用multipart形式调用，应该使用怎样的调用方法？
```
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager POST:@"postURLString" parameters:@{@"Filename":@"HTTP.pdf"} constructingBodyWithBlock:^(id<AFMultipartFormData>  _Nonnull formData) {
        [formData appendPartWithFileData:[pdf文件具体内容(NSData *)]
                                    name:@"file000"
                                fileName:@"HTTP协议详解.pdf"
                                mimeType:@"application/octet-stream"];
        [formData appendPartWithFormData:[@"Submit Query" dataUsingEncoding:NSUTF8StringEncoding]
                                    name:@"Upload"];
    } progress:nil success:nil failure:nil];
```
有些函数，比如appendPartWithFileData:和appendPartWithFormData:这些函数，大家对照上面的例子，也大概能猜出来大概用途了，具体实现后面会详解。

而此处带constructingBodyWithBlock的POST方法与- [AFHTTPSessionManager POST:parameters:progress:success:failure:]明显的区别在于构建request的时候，使用的是multipartFormRequestWithMethod:以及构建NSURLSessionDataTask的时候使用的是uploadTaskWithStreamedRequest:。因为uploadTaskWithStreamedRequest:函数在上面已经提到过了。这里就主要说一下multipartFormRequestWithMethod:实现。

multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:error:除了需要使用普通的request构造函数requestWithMethod:URLString:parameters:error:来构造request，还需要根据multipart独有的属性来修饰这个request，其中最关键的就是要构造http body部分。下面我挑出了其中比较关键的代码进行分析：
```
    // 使用initWithURLRequest:stringEncoding:来初始化一个AFStreamingMultipartFormData变量
    // 每个AFStreamMultipartFormData其实都是对应一个上面举的那个例子，主要是为了构建bodyStream
    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding];
    // 处理parameters，比如上面的@"Filename":"HTTP.pdf"，首先构建一个AFQueryStringPair，其中field为"Filename"，value为"HTTP.pdf"
```
```
// 然后会根据对应value的类型，构建出一个NSData变量。比如此处的value是一个NSString，所以调用//data = [[pair.value description] dataUsingEncoding:self.stringEncoding];将NSString->NSData

    if (parameters) {
        for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) {
            NSData *data = nil;
            if ([pair.value isKindOfClass:[NSData class]]) {
                data = pair.value;
            } else if ([pair.value isEqual:[NSNull null]]) {
                data = [NSData data];
            } else {
                data = [[pair.value description] dataUsingEncoding:self.stringEncoding];
            }
            
            if (data) {
               // bodyStream构造最主要的部分就在这了（虽然后面requestByFinalizingMultipartFormData函数还会稍微处理一下）

               // 根据data和name构建Request的header和body，后面详解
                [formData appendPartWithFormData:data name:[pair.field description]];
            }
        }
    }
    // 参考上面的例子，其实还是往formData中添加数据
    if (block) {
        block(formData);
    }
    // 做最终的处理，比如设置一下MultipartRequest的bodyStream或者其特有的content-type等等，后面也会详解
    return [formData requestByFinalizingMultipartFormData];
```

我们这次换个思路来学习AFNetworking中处理multipart格式的代码。我们先来解决做什么，再看源码中的怎么做。

首先，不管我们做什么，最终都是为了产生一个request。我们都知道request是由三个部分组成的：①请求行(request-line) ②请求头(headers) ③请求体(request body)。下面我就这三个方面逐一攻破。
###2.1 构建multipart请求行

这个没啥好说的，就是POST。
###2.2 构建multipart请求头
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160131011127255-1216459583.png)

multipart说白了和普通request大部分都很类似，所以普通request请求头的构造方法它也受用。而普通request的请求头构造方式有两个地方：

    - [AFHTTPRequestSerializer init]
    - [AFURLRequestSerialization requestWithMethod:URLString:parameters:error:]前面介绍过了

multipart除了使用普通协议请求头的构建方法。还会在- [AFStreamingMultipartFormData requestByFinalizingMultipartFormData]构建自己独有的请求头。
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160131011129052-1438470018.png)
可以看到上面红框中的代码就是用来构建上上面那张图的红框中的请求头。其中我们注意到这两个变量：
```
    @property (nonatomic, copy) NSString *boundary;    // multipart协议中的分割符
    @property (readwrite, nonatomic, strong) AFMultipartBodyStream *bodyStream;    // 代表了消息体
```
既然已经提到了boundary，此处就把他就地解决吧。至于bodyStream后面介绍消息体时候详解。

**boundary的构建方式**

boundary是用来分割不同数据内容的，其实就是上面举的那个例子中的${bound}。我们注意到boundary需要处理以下几个情况：

* 创建boundary字符串

此处AFNetworking自定义了个函数创建boundary字符串。
```
    static NSString * AFCreateMultipartFormBoundary() {
        // 使用两个十六进制随机数拼接在Boundary后面来表示分隔符
        return [NSString stringWithFormat:@"Boundary+%08X%08X", arc4random(), arc4random()];
    }
```

* 如果是开头分隔符的，那么只需在分隔符结尾加一个换行符
```
    static inline NSString * AFMultipartFormInitialBoundary(NSString *boundary) {
        return [NSString stringWithFormat:@"--%@%@", boundary, kAFMultipartFormCRLF];
    }
```
* 如果是中间部分分隔符，那么需要分隔符前面和结尾都加换行符
```
static inline NSString * AFMultipartFormEncapsulationBoundary(NSString *boundary) {
        return [NSString stringWithFormat:@"%@--%@%@", kAFMultipartFormCRLF, boundary, kAFMultipartFormCRLF];
    }
```
* 如果是末尾，还得使用--分隔符--作为请求体的结束标志
```
static inline NSString * AFMultipartFormFinalBoundary(NSString *boundary) {
        return [NSString stringWithFormat:@"%@--%@--%@", kAFMultipartFormCRLF, boundary, kAFMultipartFormCRLF];
    }
```

讲boundary有什么用呢？除了设置Content-Type外，在设置Content-Length时使用的[self.bodyStream contentLength]中会使用到boundary的这些相关函数:
```
    // AFMultipartBodyStream函数
    // 计算上面那个bodyStream的总长度作为Content-Length
    - (unsigned long long)contentLength {
        unsigned long long length = 0;
        // 注意bodyStream是由多个AFHTTPBodyPart对象组成的，比如上面那个例子就是有三个对象组成
        for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) {
            length += [bodyPart contentLength];
        }
        return length;
    }
    // AFHTTPBodyPart函数
    // 计算上面每个AFHTTPBodyPart对象的长度
```
```
 // 使用AFHTTPBodyPart中hasInitialBoundary和hasFinalBoundary属性表示开头bodyPart和结尾bodyPart
     - (unsigned long long)contentLength {
        unsigned long long length = 0;
        // 需要拼接上分割符
        NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding];
        length += [encapsulationBoundaryData length];
        // 每个AFHTTPBodyPart对象中还有Content-Disposition等header-使用stringForHeader获取
        NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding];
        length += [headersData length];
        // 加上每个AFHTTPBodyPart对象具体的数据（比如文件内容）长度
        length += _bodyContentLength;
        // 如果是最后一个AFHTTPBodyPart，还需要加上“--分隔符--”的长度
        NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]);
        length += [closingBoundaryData length];
        return length;
    }
```
###2.3 构建multipart请求体（bodyStream）
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160131011130943-1398786715.png)
至于setInitialAndFinalBoundaries函数，其实就是为了后面设置Content-Length做下预处理，使用这里不赘述了。我们把目光放在bodyStream的具体构建上。事实上对于bodyStream的构建就是对AFStreamingMultipartFormData对象的处理，比如函数- [AFHTTPRequestSerializer multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:error:]的那个formData就是一个AFStreamingMultipartFormData对象，下面我简单示意下AFStreamingMultipartFormData的结构：
![](http://images2015.cnblogs.com/blog/715314/201601/715314-20160131013511052-2125530171.png)
结合上图，我们就可以大胆推测，AFStreamingMultipartFormData类中的appendPart*函数最终落脚点就是给bodyStream中HTTPBodyParts添加一个AFHTTPBodyPart对象（HTTPBodyParts数组中的元素）。

注意这些appendPart*函数的主要区别在于数据的来源：

|||
|----|----|
|(BOOL) - appendPartWithFileURL:name:error:|根据文件位置构造数据源，使用文件类型名作为mimeType|
|(BOOL) - appendPartWithFileURL:name:fileName:mimeType:error:|根据文件位置构造数据源，需要提供mimeType|
|(void) - appendPartWithInputStream:name:fileName:length:mimeType:|直接使用NSInputStream作为数据源|
|(void) - appendPartWithFileData:name:fileName:mimeType:|使用NSData作为数据源|
|(void) - appendPartWithFormData:name:|使用NSData作为数据源，NSData并不是一个文件，可能只是一个字符串|


这些函数的实现步骤基本都是一致的，都是新建一个AFHTTPBodyPart对象bodyPart，然后给bodyPart设置各种参数，其中比较重要的参数是headers和body这两个。最后使用appendHTTPBodyPart:方法，将bodyPart添加到bodyStream的HTTPBodyParts上。

这些函数实现没什么难度，大家可以自行研究。提两个稍微要注意的地方：

    appendPartWithFileURL:函数会首先检查fileURL是否可用，使用[fileURL isFileURL]检查文件位置格式是否正确。使用[fileURL checkResourceIsReachableAndReturnError:error]来检查该文件是否存在，是否能获取到。最后使用NSFileManager获取到文件attributes，并判断attributes是否存在。另外注意到此处直接使用的是fileURL作为AFHTTPBodyPart对象的body属性。
    appendPartWithFileData:和appendPartWithFormData:两个函数实现中，最后使用的是appendPartWithHeaders:构建AFHTTPBodyPart对象，详见代码。

###2.4 另一种构建multipart request的方法-requestWithMultipartFormRequest:writingStreamContentsToFile:completionHandler:
我们先来看看这个函数的注释：
```
    /**
     将原来request中的HTTPBodyStream内容异步写入到指定文件中，随后调用completionHandler处理。最后返回新的request。
     @param request multipart形式的request，其中HTTPBodyStream属性不能为nil
     @param fileURL multipart request中的HTTPBodyStream内容写入的文件位置
     @param handler 用于处理的block
     @discussion NSURLSessionTask中有一个bug，当HTTP body的内容是来自NSStream的时候，request无法发送Content-Length到服务器端，此问题在Amazon S3的Web服务中尤为显著。作为一个解决方案，该函数的request参数使用的是multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:error:构建出的request，或者其他HTTPBodyStream属性不为空的request。接着将HTTPBodyStream的内容先写到指定的文件中，再返回一个原来那个request的拷贝，其中该拷贝的HTTPBodyStream属性值要置为空。至此，可以使用AFURLSessionManager -uploadTaskWithRequest:fromFile:progress:completionHandler:函数构建一个上传任务，或者将文件内容转变为NSData类型，并且指定给新request的HTTPBody属性。
     @see https://github.com/AFNetworking/AFNetworking/issues/1398
     */
    - (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request
                                 writingStreamContentsToFile:(NSURL *)fileURL
                                           completionHandler:(nullable void (^)(NSError * _Nullable error))handler;
```
知道这个函数是做什么之后，那么它的实现就相对容易理解了：
```
    - (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request
                                 writingStreamContentsToFile:(NSURL *)fileURL
                                           completionHandler:(void (^)(NSError *error))handler
    {
        NSParameterAssert(request.HTTPBodyStream); // 原先request的HTTPBodyStream不能为空
        NSParameterAssert([fileURL isFileURL]); // 文件路径要合法
        NSInputStream *inputStream = request.HTTPBodyStream;
        // 使用outputStream将HTTPBodyStream的内容写入到路径为fileURL的文件中
        NSOutputStream *outputStream = [[NSOutputStream alloc] initWithURL:fileURL append:NO]; 
        __block NSError *error = nil;
        // 异步执行写入操作
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            // 指定在当前RunLoop中(currentRunLoop)运行inputStreamm/outputStream，意味着在currentRunLoop中处理流操作
            [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
            [outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
            // 打开
            [inputStream open];
            [outputStream open];
            while ([inputStream hasBytesAvailable] && [outputStream hasSpaceAvailable]) {
                uint8_t buffer[1024];
                // 每次从inputStream中读取最多1024bytes大小的数据，放在buffer中，给outputStream写入file
                NSInteger bytesRead = [inputStream read:buffer maxLength:1024];
                // 出现streamError或者bytesRead小于0都表示读取出错
                if (inputStream.streamError || bytesRead < 0) {
                    error = inputStream.streamError;
                    break;
                }
                // 将上面读取的buffer写入到outputStream中，即写入文件
                NSInteger bytesWritten = [outputStream write:buffer maxLength:(NSUInteger)bytesRead];
                // 出现streamError或者bytesWritten小于0都表示写入出错
                if (outputStream.streamError || bytesWritten < 0) {
                    error = outputStream.streamError;
                    break;
                }
                // 表示读取写入完成
                if (bytesRead == 0 && bytesWritten == 0) {
                    break;
                }
            }
            [outputStream close];
            [inputStream close];
            // 回到主进程执行handler        
            if (handler) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    handler(error);
                });
            }
        });
        // 获取到新的request，并将新的request的HTTPBodyStream置为空
        NSMutableURLRequest *mutableRequest = [request mutableCopy];
        mutableRequest.HTTPBodyStream = nil;
        return mutableRequest;
    }
```
上面函数中稍微陌生一点的就是- [AFMultipartBodyStream read:maxLength:]和- [NSOutputStream write:maxLength:]，由于后者只是简单地将前者读出的数据写到文件中，所以真正的难点还是在- [AFMultipartBodyStream read:maxLength:]函数。

\- [AFMultipartBodyStream read:maxLength:]函数深入进去还是很多问题要解决的。不过我们先来看看其实现的方式：
```
    - (NSInteger)read:(uint8_t *)buffer
            maxLength:(NSUInteger)length
    {  // 输入流关闭状态，无法读取
        if ([self streamStatus] == NSStreamStatusClosed) {
            return 0;
        }
        NSInteger totalNumberOfBytesRead = 0;
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu"
        // 一般来说都是直接读取length长度的数据，但是考虑到最后一次需要读出的数据长度(self.numberOfBytesInPacket)一般是小于length
        // 所以此处使用了MIN(length, self.numberOfBytesInPacket)
        while ((NSUInteger)totalNumberOfBytesRead < MIN(length, self.numberOfBytesInPacket)) {
            // 类似于我们构建request的逆向过程，我们对于HTTPBodyStream的读取也是分成一个一个AFHTTPBodyPart来的
            // 如果当前AFHTTPBodyPart对象读取完成，那么就使用enumerator读取下一个AFHTTPBodyPart
            if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) {
                if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) {
                    break;
                }
            } else {
                // 读取当前AFHTTPBodyPart对象
                NSUInteger maxLength = MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead;
                // 使用的是AFHTTPBodyPart的read:maxLength:函数
                NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&buffer[totalNumberOfBytesRead] maxLength:maxLength];
                // 读取出错
                if (numberOfBytesRead == -1) {
                    self.streamError = self.currentHTTPBodyPart.inputStream.streamError;
                    break;
                } else {
                    // totalNumberOfBytesRead表示目前已经读取的字节数，可以作为读取后的数据放置于buffer的起始位置，如buffer[totalNumberOfBytesRead]
                    totalNumberOfBytesRead += numberOfBytesRead;
                    if (self.delay > 0.0f) {
                        [NSThread sleepForTimeInterval:self.delay];
                    }
                }
            }
        }
    #pragma clang diagnostic pop
     
        return totalNumberOfBytesRead;
    }
```
对于单个AFHTTPBodyPart的读取函数- [read:maxLength:]：
```
    - (NSInteger)read:(uint8_t *)buffer
            maxLength:(NSUInteger)length
    {
        NSInteger totalNumberOfBytesRead = 0;
        // 使用分隔符将对应bodyPart数据封装起来
        if (_phase == AFEncapsulationBoundaryPhase) {
            NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding];
            totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
        }
        // 如果读取到的是bodyPart对应的header部分，那么使用stringForHeaders获取到对应header，并读取到buffer中
        if (_phase == AFHeaderPhase) {
            NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding];
            totalNumberOfBytesRead += [self readData:headersData intoBuffer:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
        }
        // 如果读取到的是bodyPart的内容主体，即inputStream，那么就直接使用inputStream写入数据到buffer中
        if (_phase == AFBodyPhase) {
            NSInteger numberOfBytesRead = 0;
            // 使用系统自带的NSInputStream的read:maxLength:函数读取
            numberOfBytesRead = [self.inputStream read:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
            if (numberOfBytesRead == -1) {
                return -1;
            } else {
                totalNumberOfBytesRead += numberOfBytesRead;
                // 如果内容主体都读取完了，那么很有可能下一次读取的就是下一个bodyPart的header
                // 所以此处要调用transitionToNextPhase，调整对应_phase
                if ([self.inputStream streamStatus] >= NSStreamStatusAtEnd) {
                    [self transitionToNextPhase];
                }
            }
        }
        // 如果是最后一个AFHTTPBodyPart对象，那么就需要添加在末尾”--分隔符--"
        if (_phase == AFFinalBoundaryPhase) {
            NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]);
            totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)];
        }
        return totalNumberOfBytesRead;
    }
    // 上面那个函数中大量使用了read:intoBuffer:maxLength:函数
    // 这里我们将read:intoBuffer:maxLength:理解成一种将NSData类型的data转化为(uint8_t *)类型的buffer的手段，核心是使用了NSData的getBytes:range:函数
    - (NSInteger)readData:(NSData *)data
               intoBuffer:(uint8_t *)buffer
                maxLength:(NSUInteger)length
    {
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wgnu"
        // 求取range，需要考虑文件末尾比maxLength会小的情况
        NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length));
        // 核心：NSData *---->uint8_t*
        [data getBytes:buffer range:range];
    #pragma clang diagnostic pop
        _phaseReadOffset += range.length;
        // 读取完成就更新_phase的状态
        if (((NSUInteger)_phaseReadOffset) >= [data length]) {
            [self transitionToNextPhase];
        }
        return (NSInteger)range.length;
    }
```
另外，具体的_phase状态转换，大家参考transitionToNextPhase函数，不是很难，此处就不赘述了。


综合讲:
1.AFStreamingMultipartFormData代表了整个multipart，它保留了对请求的引用，multipart的编码方式，边界符号和实际的内容bodyStream（AFMultipartBodyStream类型）。AFMultipartBodyStream是真实的multipart内容所在，它继承于NSInputStream，因为NSURLRequest的bodyStream要求是NSInputStream类型的。AFMultipartBodyStream只是流的代理，内部有个HTTPBodyParts数组，实际存放着multipart的每个AFHTTPBodyPart。对外暴露一个inputStream，内部有个outputStream。AFMultipartBodyStream的read:maxLength:实质是依次调用每个AFHTTPBodyPart的read:maxLength:，而AFHTTPBodyPart不是stream，它只是内部一个NSInputStream的代理，最终会调用这个stream的read:maxLength:,AFHTTPBodyPart内部还有个body，类型可能是data，inputStream或者URL，最终从body创建这个inputStream。AFStreamingMultipartFormData的requestByFinalizingMultipartFormData方法中，为bodyStream设置边界，为Request设置httpBodyStream，设置HTTPHeader的Content-Type和Content-Length。

##AFJSONRequestSerializer和AFPropertyListRequestSerializer
这两个类都是继承自AFHTTPRequestSerializer，和父类不同的是：

* AFJSONRequestSerializer给参数（parameters）编码时使用的是系统自带的- [NSJSONSerialization dataWithJSONObject:options:error:]方法，另外Content-Type设定的是”application/json”。json格式我想大家都很熟悉了，就不赘述了。

* AFPropertyListRequestSerializer给参数（parameters）编码时使用的是系统自带的- [NSPropertyListSerialization dataWithPropertyList:format:options:error:]方法，另外Content-Type设定的是”application/x-plist”。此处比AFJSONRequestSerializer多了一个format参数，具体的format形式有以下几种：
1. OpenStep
2. XML（常用）
3. BinaryFormat

##AFURLResponseSerialization
还记得我们在说AFURLSessionManager的时候，在NSURLSessionTaskDelegate中的- URLSession:task:didCompeleteWithError这个代理方法中提到过：
```
responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&serializationError];
```
responseObjectForResponse:函数就是为了将返回的data转化为用户所需的格式，比如如果你的responseSerializer是AFJSONResponseSerializer的对象，那么解析出来的data就是JSON格式。

我们先来看看AFURLResponseSerialization这个文件中类的大概结构：
```
https://images2015.cnblogs.com/blog/715314/201601/715314-20160131175106068-678112170.png
```
简单讲一下这个结构，比如说我现在想自定义一个ResponseSerializer，名叫AFCustomResponseSerializer，继承自AFHTTPResponseSerializer。
```
@interface AFCustomResponseSerializer : AFHTTPResponseSerializer
```
那么AFCustomResponseSerializer需要实现AFURLResponseSerialization协议的responseObjectForResponse:方法。此方法就是将data转化你定义的格式。可能你还需要实现你自己的serializer方法，并在init中定义自己的acceptableContentTypes。我们接下来就先看AFHTTPResponseSerializer这个父类，然后逐个看看AFHTTPResponseSerializer这些个子类。
###4.1 AFHTTPResponseSerializer
注意到AFHTTPResponseSerializer实现的responseObjectForResponse:函数，只是简单调用了validateResponse:这个函数，而且validateResponse:中并没有对data做任何改变，也就是说父类AFHTTPResponseSerializer中的responseObjectForResponse:返回的就是最原始的data。对于data的处理，就交给了各个子类具体实现。

这里主要提及的就是validResponse:这个函数，挺重要的，主要是判断返回的response是否可用。有用的话，才会做下一步操作。
```
    - (BOOL)validateResponse:(NSHTTPURLResponse *)response
                        data:(NSData *)data
                       error:(NSError * __autoreleasing *)error
    {
        // 初始response是可用的，不过下面还需要要过三关斩六将
        BOOL responseIsValid = YES;
        NSError *validationError = nil;
       // 简单的为空判断和类型判断，注意如果response为空或类型不对，反而responseValid为YES
        if (response && [response isKindOfClass:[NSHTTPURLResponse class]]) {
            // 如果response对应的mimeType不被这个ResponseSerializer所接受，那么就认为Response不可用
            if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]]) {
                // 会返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中
                if ([data length] > 0 && [response URL]) {
                    NSMutableDictionary *mutableUserInfo = [@{
                                                              NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: unacceptable content-type: %@", @"AFNetworking", nil), [response MIMEType]],
                                                              NSURLErrorFailingURLErrorKey:[response URL],
                                                              AFNetworkingOperationFailingURLResponseErrorKey: response,
                                                            } mutableCopy];
                    if (data) {
                        mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
                    }
                    // 利用mutableUserInfo构建一个NSError对象
                    validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
                }
                responseIsValid = NO;
            }
            // 判断返回的statusCode是否被允许
            if (self.acceptableStatusCodes && ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] && [response URL]) {
                NSMutableDictionary *mutableUserInfo = [@{
                                                   NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: %@ (%ld)", @"AFNetworking", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                                   NSURLErrorFailingURLErrorKey:[response URL],
                                                   AFNetworkingOperationFailingURLResponseErrorKey: response,
                                           } mutableCopy];
                if (data) {
                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
                }
                
                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);
                responseIsValid = NO;
            }
        }
        // 将error设置为validationError
        if (error && !responseIsValid) {
            *error = validationError;
        }
        return responseIsValid;
    }
```
###4.2 AFJSONResponseSerializer

AFJSONResponseSerializer接受的content-type有@"application/json", @"text/json", @"text/javascript"。

再让我们看看responseObjectForResponse:data:error:的实现：
```
    - (id)responseObjectForResponse:(NSURLResponse *)response
                               data:(NSData *)data
                              error:(NSError *__autoreleasing *)error
    {
        // 判断当前response是否有效
        if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
            // 还记得validateResponse:中如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorCannotDecodeContentData
            if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
                // 因为不支持这个content-type，所以不用解析了，直接返回nil
                return nil;
            }
        }
        id responseObject = nil;
        NSError *serializationError = nil;
        // 对于'head :ok'，Rails返回的是一个空格 (这是Safari上的一个bug)，并且这样的JSON格式不会被NSJSONSerialization解析。
        // See https://github.com/rails/rails/issues/1742
        // 如果是单个空格，就不解析
        BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:" " length:1]]; 
        if (data.length > 0 && !isSpace) {
            // 使用系统自带的NSJSONSerialization来解析NSData数据
            responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&serializationError];
        } else {
            return nil;
        }
        // 如果需要移除JSON数据中对应value为空（nil或NSNull）的key，那么就使用AFJSONObjectByRemovingKeysWithNullValues函数
        // AFJSONObjectByRemovingKeysWithNullValues通过递归的方法，把JSON中NSDictionary的数据（不包括NSArray）中的对应value为空的key移除
        if (self.removesKeysWithNullValues && responseObject) {
            responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
        }
        if (error) {
            // 如果serializationError不为空，那么最终的error其实就是serializationError
            *error = AFErrorWithUnderlyingError(serializationError, *error);
        }
        return responseObject;
    }
```
###4.3 AFXMLParserResponseSerializer

AFXMLParserResponseSerializer接受的content-type有@"application/xml", @"text/xml"。

再让我们看看responseObjectForResponse:data:error:的实现：
```
    - (id)responseObjectForResponse:(NSHTTPURLResponse *)response
                               data:(NSData *)data
                              error:(NSError *__autoreleasing *)error
    {
        if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
            // 如果不支持该content-type
            if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
                return nil;
            }
        }
        // 使用NSXMLParser解析NSData数据
        return [[NSXMLParser alloc] initWithData:data];
    }
```
至于下面的AFXMLDocumentResponseSerializer，那是MAC上所用到的，这里不赘述了。
###4.4 AFPropertyListResponseSerializer

AFPropertyListResponseSerializer接受的content-type有@"application/x-plist"。

再让我们看看responseObjectForResponse:data:error:的实现：
```
    - (id)responseObjectForResponse:(NSURLResponse *)response
                               data:(NSData *)data
                              error:(NSError *__autoreleasing *)error
    {
        if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
            // 如果不支持该content-type，返回nil
            if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
                return nil;
            }
        }
        id responseObject;
        NSError *serializationError = nil;
        // 使用NSPropertyListSerialization来解析NSData数据
        if (data) {
            responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&serializationError];
        }
        // 如果serializationError不为空，那么最终的error其实就是serializationError
        if (error) {
            *error = AFErrorWithUnderlyingError(serializationError, *error);
        }
        return responseObject;
    }
```
###4.5 AFImageResponseSerializer
AFImageResponseSerializer接受的content-type有@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap"。

再让我们看看responseObjectForResponse:data:error:的实现：
```
    - (id)responseObjectForResponse:(NSURLResponse *)response
                               data:(NSData *)data
                              error:(NSError *__autoreleasing *)error
    {
        if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
            // 如果不支持该content-type，返回nil
            if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
                return nil;
            }
        }
    #if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
        // iOS和TV平台默认automaticallyInflatesResponseImage为YES
        // 下面的NSData转图片的方法，之前SDWebImage分析过，就不赘述了
        // 感兴趣的话可以查看【原】SDWebImage源码阅读（四）
        if (self.automaticallyInflatesResponseImage) {
            return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);
        } else {
            return AFImageWithDataAtScale(data, self.imageScale);
        }
    #else
        // 只关心iOS
        // Ensure that the image is set to it's correct pixel width and height
        NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];
        NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];
        [image addRepresentation:bitimage];
        return image;
    #endif
     
        return nil;
    }
```
###4.6 AFCompoundResponseSerializer
该类里面有一个成员属性为
```
@property (readwrite, nonatomic, copy) NSArray *responseSerializers;
```
可见AFCompoundResponseSerializer是表示一组Serializer的集合，不信，你可以看它的responseObjectForResponse:data:error:函数实现：
```
    - (id)responseObjectForResponse:(NSURLResponse *)response
                               data:(NSData *)data
                              error:(NSError *__autoreleasing *)error
    {
        // 可能确实不能确定返回的responsed的content-type，此时可以使用AFCompoundResponseSerializer

        // 总会找到合适的Serializer

        for (id <AFURLResponseSerialization> serializer in self.responseSerializers) {
            if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) {
                continue;
            }
            NSError *serializerError = nil;
            id responseObject = [serializer responseObjectForResponse:response data:data error:&serializerError];
            // 终于遍历到合适的Serializer
            if (responseObject) {
                if (error) {
                    *error = AFErrorWithUnderlyingError(serializerError, *error);
                }
                return responseObject;
            }
        }
        return [super responseObjectForResponse:response data:data error:error];
```


##AFSecurityPolicy网络安全策略
如何正确使用AFNetworking中的SSL功能。详细步骤如下：
1、获取到站点的证书：

我们可以使用以下openssl命令来获取到服务器的公开二进制证书（以google为例）：

"openssl s_client -connect www.google.com:443 </dev/null 2>/dev/null | openssl x509 -outform DER > https.cer"

冒号中的为命令主要部分。该条命令将会在当前路径下，形成google.com站点的公开二进制证书，命名为https.cer。您可以将www.google.com 替换成您自己的站点以此来获取您自己站点的https.cer。

2、将证书放进我们的XCode项目工程中：
![](http://cc.cocimg.com/api/uploads/20160223/1456192851656754.png)
如上图所示，将我们的https.cer拖到我们的工程Supporting Files中，把 Copy Items if needed 的勾选上。然后把您的Add to targets 选上，点击确定。就完成了证书的导入工作。

3、在我们的代码中使用我们的cer

AFNetworking中的AFSecurityPolicy是主要的类，我们可以这样来使用它：

AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];

NSString *cerPath                = [[NSBundle mainBundle] pathForResource:@"https" ofType:@"cer"];
NSData *certData                 = [NSData dataWithContentsOfFile:cerPath];
AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init];
[securityPolicy setAllowInvalidCertificates:NO];
[securityPolicy setPinnedCertificates:@[certData]];
[securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate];
[securityPolicy setValidatesDomainName:YES];
[securityPolicy setValidatesCertificateChain:NO];

manager.securityPolicy = securityPolicy;

解析：

1）新建一个manager, 地球人都知道

2）在mainBundle中寻找我们刚才拖进项目中的https.cer, 并且将相关的数据读取出来

3）新建一个AFSecurityPolicy，并进行相应的配置

4）将这个AFSecurityPolicy 实例赋值给manager

也可以这样来使用：

AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; 

AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init]; 
[securityPolicy setAllowInvalidCertificates:NO]; 
[securityPolicy setSSLPinningMode:AFSSLPinningModeCertificate]; 
[securityPolicy setValidatesDomainName:YES];
[securityPolicy setValidatesCertificateChain:NO]; 

manager.securityPolicy = securityPolicy;

这种方式比前面那种方式要更加简便一些，主要原因在于AFNetworking会自动去搜索mainBundle下的所有cer结尾的文件并放进内存中；再一一对比。因此在代码中可以省略不写。

这样一个网络请求的https的安全策略就配置好了，接下来再说明一下几个AFSecurityPolicy相关的配置

（1）SSLPinningMode

SSLPinningMode 定义了https连接时，如何去校验服务器端给予的证书。

typedef NS_ENUM(NSUInteger, AFSSLPinningMode) {
    AFSSLPinningModeNone,
    AFSSLPinningModePublicKey,
    AFSSLPinningModeCertificate,
};

AFSSLPinningModeNone: 代表客户端无条件地信任服务器端返回的证书。

AFSSLPinningModePublicKey: 代表客户端会将服务器端返回的证书与本地保存的证书中，PublicKey的部分进行校验；如果正确，才继续进行。

AFSSLPinningModeCertificate: 代表客户端会将服务器端返回的证书和本地保存的证书中的所有内容，包括PublicKey和证书部分，全部进行校验；如果正确，才继续进行。

（2）allowInvalidCertificates

allowInvalidCertificates 定义了客户端是否信任非法证书。一般来说，每个版本的iOS设备中，都会包含一些既有的CA根证书。如果接收到的证书是iOS信任的CA根证书签名的，那么则为合法证书；否则则为“非法”证书。

allowInvalidCertificates 就是用来确认是否信任这样的证书的。当然，我们也可以给iOS加入新的信任的CA证书。iOS已有的CA根证书，可以在这里了解到：https://support.apple.com/en-us/HT204132

（3）pinnedCertificates

pinnedCertificates 就是用来校验服务器返回证书的证书。通常都保存在mainBundle 下。通常默认情况下，AFNetworking会自动寻找在mainBundle的根目录下所有的.cer文件并保存在pinnedCertificates数组里，以校验服务器返回的证书。如果你想验证自建证书（浏览器没有内置对应CA证书的情况）的domain是否有效。那么你必须使用pinnedCertificates。

（4）validatesDomainName

validatesDomainName 是指是否校验在证书中的domain这一个字段。每个证书都会包含一个DomainName, 它可以是一个IP地址，一个域名或者一端带有通配符的域名。如*.google.com, www.google.com 都可以成为这个证书的DomainName。设置validatesDomainName=YES将严格地保证其安全性。

（5） validatesCertificateChain

validatesCertificateChain 指的是是否校验其证书链。

通常来讲，一个CA证书颁发机构有很多个子机构，用来签发不同用途的子证书，然后这些子证书又再用来签发相应的证书。只有证书链上的证书都正确，CertificateChain才算验证完成。以Google为例：
![](http://cc.cocimg.com/api/uploads/20160223/1456193144767865.png)

从上图可以看到，Google.com的证书的根CA证书是GeoTrust Global CA; 而CA并没有直接给google.com签证书，而是先签名了Google Internet Authority G2, 然后G2再签名了google.com。这时候就需要设备中保存有Google Internet Authority G2证书才能通过校验。

一般来讲，我推荐将validatesCertificateChain设置为NO，因为并不是太有必要做CertificateChain的校验。并且，在AFNetworking 2.6.0中，也正式将validatesCertificateChain拿掉了（https://github.com/AFNetworking/AFNetworking/blob/master/CHANGELOG.md）, 其原因也同样为：There was no documented security advantage to pinning against an entire certificate chain。

因此，在2.6.0之后，可以不管这个字段。而在此之前，从效率上来说，设定为NO会是个比较明智的选择。

做好以上工作后，您应该就可以正常访问您自己的https服务器了。如果还是有问题请检查：
HTTPS服务器的正确配置。一般来说，可以使用浏览器打开相同页面来查看浏览器上的小锁是否正常。

是否https.cer正确打包进了项目中。查看第2步中的内容。

之前我们在AFURLSessionManager中实现了NSURLSessionDelegate的代理方法- (void)URLSession:didReceiveChallenge:completionHandler:，其中我们提到过，如果iOS客户端需要向服务器发送一个凭证(Credential)来确认认证挑战（authentication challenge），那么先得使用AFNetworking的安全策略类-AFSecurityPolicy来检查服务器端是否可以信任（在authenticationMethod属性为NSURLAuthenticationMethodServerTrust情况下），而检查的方式就是通过- [AFSecurityPolicy evaluateServerTrust:forDomain:]这个函数。
###2.1 - [AFSecurityPolicy evaluateServerTrust:forDomain:]
```
    // 根据severTrust和domain来检查服务器端发来的证书是否可信

    // 其中SecTrustRef是一个CoreFoundation类型，用于对服务器端传来的X.509证书评估的

    // 而我们都知道，数字证书的签发机构CA，在接收到申请者的资料后进行核对并确定信息的真实有效，然后就会制作一份符合X.509标准的文件。证书中的证书内容包含的持有者信息和公钥等都是由申请者提供的，而数字签名则是CA机构对证书内容进行hash加密后得到的，而这个数字签名就是我们验证证书是否是有可信CA签发的数据。
    - (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
                      forDomain:(nullable NSString *)domain;
```
具体函数我们直接看函数源码：
```
    - (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust
                      forDomain:(NSString *)domain
    {
        /**self.allowInvalidCertificates==YES表示如果此处允许使用自建证书（服务器自己弄的CA证书，非官方），并且还想验证domain是否有效(self.validatesDomainName == YES)，也就是说你想验证自建证书的domain是否有效。那么你必须使用pinnedCertificates（就是在客户端保存服务器端颁发的证书拷贝）才可以。但是你的SSLPinningMode为AFSSLPinningModeNone，表示你不使用SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。所以当然你的客户端上没有你导入的pinnedCertificates，同样表示你无法验证该自建证书。所以都返回NO。最终结论就是要使用服务器端自建证书，那么就得将对应的证书拷贝到iOS客户端，并使用AFSSLPinningMode或AFSSLPinningModePublicKey
        if (domain && self.allowInvalidCertificates && self.validatesDomainName && (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) {
            // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html
            NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning.");
            return NO;
        }
        // 此处设置验证证书的策略
        NSMutableArray *policies = [NSMutableArray array];
        
        if (self.validatesDomainName) {
            // 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略，其中第一个参数为true表示验证整个SSL证书链，第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致
            [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];
        } else {
            // 如果不需要验证domain，就使用默认的BasicX509验证策略
            [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];
        }
        // 为serverTrust设置验证策略，即告诉客户端如何验证serverTrust
        SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);
        // 如果SSLPinningMode为 AFSSLPinningModeNone，表示你不使用SSL pinning，但是我允许自建证书，那么返回YES，或者使用AFServerTrustIsValid函数看看serverTrust是否可信任，如果信任，也返回YES
        if (self.SSLPinningMode == AFSSLPinningModeNone) {
            return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);
        } else if (!AFServerTrustIsValid(serverTrust) && !self.allowInvalidCertificates) {
            // 既不允许自建证书，而且使用AFServerTrustIsValid函数又返回NO，那么该serverTrust就真的不能通过验证了
            return NO;
        }
        switch (self.SSLPinningMode) {
           // 这个模式表示用证书绑定(SSL Pinning)方式验证证书，需要客户端保存有服务端的证书拷贝
            // 注意客户端保存的证书存放在self.pinnedCertificates中
            case AFSSLPinningModeCertificate: {
                NSMutableArray *pinnedCertificates = [NSMutableArray array];
                for (NSData *certificateData in self.pinnedCertificates) {
                   // 这里使用SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书
                    [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];
                }
                // 将pinnedCertificates设置成需要参与验证的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书），具体就是调用SecTrustEvaluate来验证。
                SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);
                if (!AFServerTrustIsValid(serverTrust)) {
                    return NO;
                }
                // 服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点
                NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);
                // 从服务器端证书链的根节点往下遍历，看看是否有与客户端的绑定证书一致的，有的话，就说明服务器端是可信的。因为遍历顺序正好相反，所以使用reverseObjectEnumerator
                for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]){
                    if ([self.pinnedCertificates containsObject:trustChainCertificate]) {
                        return YES;
                    }
              }
                
                return NO;
            }
            // AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。
            case AFSSLPinningModePublicKey: {
                NSUInteger trustedPublicKeyCount = 0;
                // 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥
                NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);
                // 依次遍历这些公钥，如果和客户端绑定证书的公钥一致，那么就给trustedPublicKeyCount加一
                for (id trustChainPublicKey in publicKeys) {
                    for (id pinnedPublicKey in self.pinnedPublicKeys) {
                        if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) {
                            trustedPublicKeyCount += 1;
                        }
                    }
                }
              // trustedPublicKeyCount大于0说明服务器端中的某个证书和客户端绑定的证书公钥一致，认为服务器端是可信的
                return trustedPublicKeyCount > 0;
            }
            default:
                return NO;
        }
        
        return NO;
    }
```
上述函数实现中调用了AFSecurityPolicy的私有方法（注意evaluateServerTrust:forDomain:方法是AFSecurityPolicy比较重要的公开方法），下面我来逐个分析相应的函数实现。

static BOOL AFServerTrustIsValid(SecTrustRef serverTrust)
```
    static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) {
        BOOL isValid = NO;
        SecTrustResultType result;
        // 对照下面的Require_noErr_Quiet函数解释，此处errorCode指的就是SecTrustEvaluate(serverTrust, &result)函数的返回值。如果serverTrust评估出错，那么就直接执行return isValid，默认isValid为NO。
        __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &result), _out);
        // 如果SecTrustEvaluate函数评估没出错，那么就看result的结果
        // 只有当result为kSecTrustResultUnspecified（此标志表示serverTrust评估成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书），或者当result为kSecTrustResultProceed（此标志表示评估成功，和上面不同的是该评估得到了用户认可），这两者取其一就可以认为对serverTrust评估成功
        // 在下面有对result类型（SecTrustResultType）的简单讲解
        isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);
    _out:
        return isValid;
    }
    // Require_noErr_Quiet是一个宏定义函数，表示如果errorCode不为0（0表示没有错误），那么就使用C语言中的go语句，跳到对应exceptionLabel地方开始执行代码。
    #ifndef __Require_noErr_Quiet
        #define __Require_noErr_Quiet(errorCode, exceptionLabel)                      \
          do                                                                          \
          {                                                                           \
              if ( __builtin_expect(0 != (errorCode), 0) )                            \
              {                                                                       \
                  goto exceptionLabel;                                                \
              }                                                                       \
          } while ( 0 )
    #endif
     
    // kSecTrustResultUnspecified和kSecTrustResultProceed都是SecTrustResultType类型
    /** 
      SecTrustResultType中枚举值的含义包括两个方面：一个是指评估是否成功，另一个是指该评估结果是不是由用户决定的。对于是不是由用户决定的这个问题，上面kSecTrustResultUnspecified和kSecTrustResultProceed就是一个很好的例子
     */
```

static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust)
```
    // 获取到serverTrust中证书链上的所有证书
    static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) {
        // 使用SecTrustGetCertificateCount函数t获取到serverTrust中需要评估的证书链中的证书数目，并保存到certificateCount中
        CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);
        NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];
        // 使用SecTrustGetCertificateAtIndex函数获取到证书链中的每个证书，并添加到trustChain中，最后返回trustChain
        for (CFIndex i = 0; i < certificateCount; i++) {
            SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);
            [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)];
        }
        return [NSArray arrayWithArray:trustChain];
    }
```

static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust)
```
    // 取出serverTrust中证书链上每个证书的公钥，并返回对应的该组公钥
    static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) {
        // 接下来的一小段代码和上面AFCertificateTrustChainForServerTrust函数的作用基本一致，都是为了获取到serverTrust中证书链上的所有证书，并依次遍历，取出公钥。
        SecPolicyRef policy = SecPolicyCreateBasicX509();
        CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);
        NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];
        for (CFIndex i = 0; i < certificateCount; i++) {
            SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);
            SecCertificateRef someCertificates[] = {certificate};
            CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL);
            SecTrustRef trust;
            // 根据给定的certificates和policy来生成一个trust对象
            __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &trust), _out);
            SecTrustResultType result;
            // 使用SecTrustEvaluate来评估上面构建的trust
            __Require_noErr_Quiet(SecTrustEvaluate(trust, &result), _out);
            // 如果该trust符合X.509证书格式，那么先使用SecTrustCopyPublicKey获取到trust的公钥，再将此公钥添加到trustChain中
            [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)];
        _out:
            // 注意释放资源
            if (trust) {
                CFRelease(trust);
            }
            if (certificates) {
                CFRelease(certificates);
            }
            continue;
        }
        CFRelease(policy);
        // 返回对应的一组公钥
        return [NSArray arrayWithArray:trustChain];
    }
```

###2.2 + [AFSecurityPolicy policyWithPinningMode:withPinnedCertificates:]
AFSecurityPolicy中还有一些关于初始化的函数，比较重要的就数+ [AFSecurityPolicy policyWithPinningMode:withPinnedCertificates:]这个函数了。
```
    // 初始化AFSecurityPolicy对象的SSLPinningMode和pinnedCertificates两个属性
    + (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates {
        AFSecurityPolicy *securityPolicy = [[self alloc] init];
        securityPolicy.SSLPinningMode = pinningMode;
        [securityPolicy setPinnedCertificates:pinnedCertificates];
        return securityPolicy;
    }
    // 此函数设置securityPolicy中的pinnedCertificates属性
    // 注意还将对应的self.pinnedPublicKeys属性也设置了，该属性表示的是对应证书的公钥（与pinnedCertificates中的证书是一一对应的）
    - (void)setPinnedCertificates:(NSSet *)pinnedCertificates {
        _pinnedCertificates = pinnedCertificates;
        if (self.pinnedCertificates) {
            NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];
            for (NSData *certificate in self.pinnedCertificates) {
                id publicKey = AFPublicKeyForCertificate(certificate);
                if (!publicKey) {
                    continue;
                }
                [mutablePinnedPublicKeys addObject:publicKey];
            }
            self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];
        } else {
            self.pinnedPublicKeys = nil;
        }
    }
```

static id AFPublicKeyForCertificate(NSData *certificate)
```
    // 此函数没什么特别要提及的，和AFPublicKeyTrustChainForServerTrust实现的原理基本一致
    // 区别仅仅在该函数是返回单个证书的公钥（所以传入的参数是一个证书），而AFPublicKeyTrustChainForServerTrust返回的是serverTrust的证书链中所有证书公钥
    static id AFPublicKeyForCertificate(NSData *certificate) {
        id allowedPublicKey = nil;
        SecCertificateRef allowedCertificate;
        SecCertificateRef allowedCertificates[1];
        CFArrayRef tempCertificates = nil;
        SecPolicyRef policy = nil;
        SecTrustRef allowedTrust = nil;
        SecTrustResultType result;
        // 因为此处传入的certificate参数是NSData类型的，所以需要使用SecCertificateCreateWithData来将NSData对象转化为SecCertificateRef对象
        allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);
        __Require_Quiet(allowedCertificate != NULL, _out);
        allowedCertificates[0] = allowedCertificate;
        tempCertificates = CFArrayCreate(NULL, (const void **)allowedCertificates, 1, NULL);
        policy = SecPolicyCreateBasicX509();
        __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &allowedTrust), _out);
        __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &result), _out);
        allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);
    _out:
        if (allowedTrust) {
            CFRelease(allowedTrust);
        }
        if (policy) {
            CFRelease(policy);
        }
        if (tempCertificates) {
            CFRelease(tempCertificates);
        }
        if (allowedCertificate) {
            CFRelease(allowedCertificate);
        }
        return allowedPublicKey;
    }
```

##AFNetworkReachabilityManager
AFNetworkingReachabilityManager是我使用AFNetworking的时候，第一个接触到的类。当时主要是用这个类做一些网络状态判断。比如我当时做一个视频类的app时，考虑到网络如果是2G/3G/4G，那么最好是有一个switchButton来让用户选择是否使用2G/3G/4G来观看在线视频，此时你就需要判断当前网络状态，如果用户不允许2G/3G/4G网络观看在线视频，而此时手机网络又是2G/3G/4G网络，就得提示用户当前网络不支持播放在线视频。

该类的使用方法很简单，我们看一个简单例子：
```
    // 设置networkReachabilityStatusBlock，根据不同网络状态，用户自定义处理方式
    AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
    [manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
        NSLog(@"network status '%@'", AFStringFromNetworkReachabilityStatus(status));
    }];
    // 启动网络监听
    [manager startMonitoring];
```
其实networkReachabilityStatusBlock应该都好理解。关键是这个startMonitoring方法。大家是不是觉得很神奇，感觉就像app在系统后台有一个循环，不停地检测网络状态。那么具体是怎么做到的呢，这里先透露点：代码的核心使用了iOS提供的一系列SCNetworkReachability文件中的方法。
```
    - (void)startMonitoring {
        // 先停止之前的网络监听
        [self stopMonitoring];
        // networkReachability表示的是需要检测的网络地址的句柄
        if (!self.networkReachability) {
            return;
        }
        __weak __typeof(self)weakSelf = self;
        // 根据网络状态status来设置网络状态监听的回调函数callback
        AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) {
            __strong __typeof(weakSelf)strongSelf = weakSelf;
            strongSelf.networkReachabilityStatus = status;
            if (strongSelf.networkReachabilityStatusBlock) {
                strongSelf.networkReachabilityStatusBlock(status);
            }
        };
        /** context是一个结构体
             typedef struct {
             // 创建一个SCNetworkReachabilityContext结构体时，需要调用SCDynamicStore的创建函数，而此创建函数会根据version来创建出不同的结构体，SCNetworkReachabilityContext对应的version是0
             CFIndex        version;  
            // 下面两个block（release和retain）的参数就是info，此处表示的是网络状态处理的回调函数
              void *        __nullable info;
            // 该retain block用于对info进行retain，下面那个AFNetworkReachabilityRetainCallback核心就是调用了Block_copy（用于retain一个block函数，即在堆空间新建或直接引用一个block拷贝）
              const void    * __nonnull (* __nullable retain)(const void *info);
            // 该release block用于对info进行release，下面那个AFNetworkReachabilityReleaseCallback核心就是调用了Block_release（用于release一个block函数，即将block从堆空间移除或移除相应引用）
              void        (* __nullable release)(const void *info);
            // 提供info的description，此处调用为NULL
            CFStringRef    __nonnull (* __nullable copyDescription)(const void *info);
            } SCNetworkReachabilityContext;
         */
        SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL};
        /**
         // 给客户端指定对应target（该参数和需要检测网络状况的地址有一定关联，此处使用的是self.networkReachability），然后当这个target的网络状态变化时，告之SCNetworkReachabilityCallBack对象callout处理（此处使用的是AFNetworkReachabilityCallback），另外callout中使用到的参数包括target和context提供的info。
         Boolean
         SCNetworkReachabilitySetCallback    (
        SCNetworkReachabilityRef                                        target,
        SCNetworkReachabilityCallBack    __nullable    callout,
        SCNetworkReachabilityContext    * __nullable    context
    )                __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_2_0);
         */
        SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &context);
        /**
         此处表示在main RunLoop中以kCFRunLoopCommonModes形式处理self.networkingReachability
         */
        SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);
        // 在后台检测self.networkingReachability的网络状态，并使用SCNetworkReachabilityGetFlags函数返回产生的flag，注意此处flag表示的就是网络的状态，后面会详细介绍每种flag对应的状态是什么
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{
            SCNetworkReachabilityFlags flags;
            if (SCNetworkReachabilityGetFlags(self.networkReachability, &flags)) {
                // AFPostReachabilityStatusChange函数就是先将flags转化为对应的AFNetworkReachabilityStatus变量，然后给我们的callback处理，后面会详解此函数
                AFPostReachabilityStatusChange(flags, callback);
            }
        });
    }
```

static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block)
```
    static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) {
        // 使用AFNetworkReachabilityStatusForFlags函数将flags转化为status，提供给下面block使用
        AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);
        dispatch_async(dispatch_get_main_queue(), ^{
            if (block) {
                block(status);
            }
            // 对于用户，可以使用KVO来观察status的变化，随后用户可以根据传过来的userInfo[AFNetworkingReachabilityNotificationStatusItem]获取到相应的status
            NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
            NSDictionary *userInfo = @{ AFNetworkingReachabilityNotificationStatusItem: @(status) };
            [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];
        });
    }
    static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) {
        // 该网络地址可达
        BOOL isReachable = ((flags & kSCNetworkReachabilityFlagsReachable) != 0);
        // 该网络地址虽然可达，但是需要先建立一个connection
        BOOL needsConnection = ((flags & kSCNetworkReachabilityFlagsConnectionRequired) != 0); 
        // 该网络虽然也需要先建立一个connection，但是它是可以自动去connect的
        BOOL canConnectionAutomatically = (((flags & kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags & kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));
        // 不需要用户交互，就可以connect上（用户交互一般指的是提供网络的账户和密码）
        BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically && (flags & kSCNetworkReachabilityFlagsInterventionRequired) == 0);
        // 如果isReachable==YES，那么就需要判断是不是得先建立一个connection，如果需要，那就认为不可达，或者虽然需要先建立一个connection，但是不需要用户交互，那么认为也是可达的
        BOOL isNetworkReachable = (isReachable && (!needsConnection || canConnectWithoutUserInteraction));
        
        //  AFNetworkReachabilityStatus就四种状态Unknown、NotReachable、ReachableViaWWAN、ReachableViaWiFi，这四种状态字面意思很好理解，这里就不赘述了
        AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;
        if (isNetworkReachable == NO) {
            status = AFNetworkReachabilityStatusNotReachable;
        }
    #if    TARGET_OS_IPHONE
        else if ((flags & kSCNetworkReachabilityFlagsIsWWAN) != 0) {
            status = AFNetworkReachabilityStatusReachableViaWWAN;
        }
    #endif
        else {
            status = AFNetworkReachabilityStatusReachableViaWiFi;
        }
        return status;
    }
```
此时AFNetworking如何判断网络状态的思路基本也理清楚了：先使用SCNetworkReachability相关函数得到网络状态，不过此时的网络状态还需要放到AFNetworking中封装一层，以提供适合用户使用的API（如isReachable、isReachableViaWWAN、isReachableViaWiFi），对于不同的网络状态，用户只需要定义自己的block进行处理就行。

最后，不知道大家对_networkReachability这个属性值是否有疑惑：源码中定义了一个sharedManager，那么sharedManager中的_networkReachability是如何设置的呢？一图以蔽之，我就不赘述了。
![](https://images2015.cnblogs.com/blog/715314/201602/715314-20160202231442054-1497155496.png)


##UIKit+AFNetworking
###AFNetworkActivityIndicatorManager
启用AFNetworkActivityIndicatorManager：
```  [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES];
```


如果要我去实现这个类，面临的两个问题就是：

    1.如何在status bar上显示那个小菊花。
    2.如何判断什么时候显示这个小菊花，也就是怎么判断session task的开始和结束。

3.1 问题一：如何显示小菊花？

我搜寻了一下代码，发现显示方式很简单，是系统自带的。就一行代码：
```
[[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];
```
但关键作为一个这么牛逼的库，肯定不能就这么简单就把菊花漏出来了。对了！它还允许用户自定义处理（用户需要自己定义networkActivityActionBlock）。见代码（AFNetworkActivityIndicatorManager.m下的setNetworkActivityIndicatorVisible:函数）：
```
if (self.networkActivityActionBlock) {
        self.networkActivityActionBlock(networkActivityIndicatorVisible);
    } else {
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];
    }
```
3.2 问题二：什么时候显示与隐藏小菊花？

这个算是比较困难的问题。首先你得涉及到状态的处理和转移（处理就是指遇到这个状态我应该做什么，转移表示的是如何进行状态转移的）。纵观全局，发现获取和维护都是使用了currentState这个属性。这个currentState是一个AFNetworkActivityManagerState类型的属性，何为AFNetworkActivityManagerState：
```
typedef NS_ENUM(NSInteger, AFNetworkActivityManagerState) {
    AFNetworkActivityManagerStateNotActive,
    AFNetworkActivityManagerStateDelayingStart,
    AFNetworkActivityManagerStateActive,
    AFNetworkActivityManagerStateDelayingEnd
};
```
我们从中大概也可以看出AFNetworkActivityIndicatorManager所需要处理的状态就这四种。NotActive和Active我清楚，就是判断当前有没有session task，但是DelayingStart和DelayingEnd是什么？不着急，先看看这些状态用来干啥的？
3.2.1 状态的处理

我们先搜索currentState。发现setCurrentState:函数集中了状态的处理过程：

整个函数是包含在@synchronized中，使用self作为锁的唯一标识。主要是担心多个网络线程同时修改currentState。接着就是判断currentState是否有变化，如果变了，就执行if语句中的函数。这里有一个貌似配对的函数willChangeValueForKey:和didChangeValueForKey:。

跟着就是判断currentState，并作出相应处理了：

    * AFNetworkActivityManagerStateNotActive一上来就出现了cancelActivationDelayTimer和cancelActivationDelayTimer两个函数。看懂这两个函数不难，


* AFNetworkActivityManagerStateDelayingStart,直接查找startActivationDelayTimer。我们发现这个函数都是定义了一个计时器。具体看代码：

```
- (void)startActivationDelayTimer {
    self.activationDelayTimer = [NSTimer
                                 timerWithTimeInterval:self.activationDelay target:self selector:@selector(activationDelayTimerFired) userInfo:nil repeats:NO];
    [[NSRunLoop mainRunLoop] addTimer:self.activationDelayTimer forMode:NSRunLoopCommonModes];
}
```
* AFNetworkActivityManagerStateActive

* AFNetworkActivityManagerStateDelayingEnd,直接查找startCompletionDelayTimer函数。我们发现这个函数都是定义了一个计时器。具体看代码：

```
- (void)startCompletionDelayTimer {
    [self.completionDelayTimer invalidate];
    self.completionDelayTimer = [NSTimer timerWithTimeInterval:self.completionDelay target:self selector:@selector(completionDelayTimerFired) userInfo:nil repeats:NO];
    [[NSRunLoop mainRunLoop] addTimer:self.completionDelayTimer forMode:NSRunLoopCommonModes];
}
```

注意这里添加计时器的时候，使用的Mode是NSRunLoopCommonModes，表示不管RunLoop出于什么状态，都执行这个计时器任务（因为如果不指定这个mode的话，UI操作会阻塞计时器任务）。

不过现在关键是完全不知道这两个delay是干啥的？找了一会，终于在activationDelay和completionDelay的注释中找到了答案，恍然大悟，整个小菊花存在的时间是这样的：
![](https://images2015.cnblogs.com/blog/715314/201601/715314-20160112000333788-240635404.png)
不禁要问，既然session task已经开始了，为什么不直接使用Active作为状态，还要搞出一个activationDelay，这是因为Apple的HIG(Human Interface Guidelines)说有些session task时间太短了，有可能用户还没意识到session task的进行，就已经结束了，就没必要搞个菊花在上面转啊转的（这个用户的意识盲区在此处默认设定为1秒，即activationDelay）。至于completionDelay，是因为如果有多个session task正在进行，前一个task结束之后，不一会（这个不一会的时间，默认是0.17秒，可能利用了大数据分析出来的（鬼知道怎么测出来了），也就是completionDelay）另一个task就开始，此处认为这个间隙没必要停止菊花转。

3.2.2 状态的转移

牛逼的代码就是不一样，状态都这么多…没办法，只好全局搜索，发现了这个函数----updateCurrentStateForNetworkActivityChange，我大致看了下，觉得所有状态变化应该就写在这了：
```
- (void)updateCurrentStateForNetworkActivityChange {
    if (self.enabled) {
        switch (self.currentState) {
            case AFNetworkActivityManagerStateNotActive:
                if (self.isNetworkActivityOccurring) {
                    [self setCurrentState:AFNetworkActivityManagerStateDelayingStart];
                }
                break;
            case AFNetworkActivityManagerStateDelayingStart:
                //No op. Let the delay timer finish out.
                break;
            case AFNetworkActivityManagerStateActive:
                if (!self.isNetworkActivityOccurring) {
                    [self setCurrentState:AFNetworkActivityManagerStateDelayingEnd];
                }
                break;
            case AFNetworkActivityManagerStateDelayingEnd:
                if (self.isNetworkActivityOccurring) {
                    [self setCurrentState:AFNetworkActivityManagerStateActive];
                }
                break;
        }
    }
}
```
结合上面那个图，大概转移关系也是可以理解的。

不过在状态转移过程中，有一个属性很重要，叫做isNetworkActivityOccurring。这个其实是最真实的记录session task起始的状态。不过这个属性是根据activityCount来决定的：
```
- (BOOL)isNetworkActivityOccurring {
    @synchronized(self) {
        return self.activityCount > 0;
    }
}
```
那什么是activityCount？我们发现activityCount的增减是通过incrementActivityCount和decrementActivityCount两个函数进行的。这两个函数也是使用了手动KVO的形式，具体实现很简单，此处就不赘述了。我们再看在networkRequestDidStart函数中调用了incrementActivityCount，在networkRequestDidFinish调用了decrementActivityCount。而这两个networkRequestDid*函数也是使用了KVO。具体这两个函数什么时候执行，已经超出了第一篇文章要研究的范围了。我们大概从他们的名字可以猜出networkRequest开始的时候activityCount++，networkRequest结束的时候activityCount--。


###UIActivityIndicatorView\UIRefreshControl

###UIWebView

###UIProgressView

###UIImageView
###UIButton
###UIImage


##其他
###_AFURLSessionTaskSwizzling
这个类在[#issues 1477](https://github.com/AFNetworking/AFNetworking/issues/1477)上reopen了多次，讨论还是很激烈的。讨论的起由是app会莫名crash，主要原因是AFNetworking对NSURLSessionTask中的state进行了KVO操作。一开始人们removeObserver这个state，但是会造成AFNetworkActivityIndicatorManager功能（其中会观察state）削弱。另外后来iOS8上也出现了同样crash现象，貌似iOS7和iOS8在NSURLSessionTask有些不同。最后还是有个大神用swizzling方法才解决了这个问题。

还记得【原】AFNetworking源码阅读（三）中我们提到了如果想使用AFNetworkingTaskDidResumeNotification来通知各种UI控件当前网络任务状态为resume，那么就得调用taskDidResume:函数，而想要调用taskDidResume:函数就得调用af_resume函数。之前我们提到过，af_resume和系统的resume进行了method swizzling。所以调用af_resume其实就是调用resume。

不过你有没发现除了后面Test中的方法出现了_AFURLSessionTaskSwizzling，其他地方都没出现该类的使用，那method swizzling是在哪初始化的的呢，换句话说，af_resume和resume是在哪调换的？这个问题我想了好久，最后才明白，都是自己学艺不精啊。下面补充一个知识点：

load方法会在加载类的时候就被调用，也就是iOS应用启动的时候就会加载所有的类，就会调用每个类的+load方法。

而我们的_AFURLSessionTaskSwizzling重写了load方法，并且在其中调用了swizzleResumeAndSuspendMethodForClass:来进行method swizzling。下面我们先看看swizzleResumeAndSuspendMethodForClass:这个方法：
```
    + (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass {
        // 因为af_resume和af_suspend都是类的实例方法，所以使用class_getInstanceMethod获取这两个方法
        Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));
        Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));
        
        // 给theClass添加一个名为af_resume的方法，使用@selector(af_resume)获取方法名，使用afResumeMethod作为方法实现
        if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) {
            // 交换resume和af_resume的方法实现
            af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));
        }
        // 同上
        if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) {
            af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));
        }
    }
```
上述方法调用了大量私有的方法，下面一一解释：
```
    // 根据两个方法名称交换两个方法，内部实现是先根据函数名获取到对应方法实现
    // 再调用method_exchangeImplementations交换两个方法
    static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) {
        Method originalMethod = class_getInstanceMethod(theClass, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
    // 给theClass添加名为selector，对应实现为method的方法
    static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) {
        // 内部实现使用的是class_addMethod方法，注意method_getTypeEncoding是为了获得该方法的参数和返回类型
        return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));
    }
```
```
    - (NSURLSessionTaskState)state {
        NSAssert(NO, @"State method should never be called in the actual dummy class");
        // 初始状态是NSURLSessionTaskStateCanceling;
        return NSURLSessionTaskStateCanceling;
    }
    - (void)af_resume {
        NSAssert([self respondsToSelector:@selector(state)], @"Does not respond to state");
        NSURLSessionTaskState state = [self state];
        [self af_resume]; // 因为经过method swizzling后，此处的af_resume其实就是之前的resume，所以此处调用af_resume就是调用系统的resume。但是在程序中我们还是得使用resume，因为其实际调用的是af_resume
        // 如果之前是其他状态，就变回resume状态，此处会通知调用taskDidResume
        if (state != NSURLSessionTaskStateRunning) {
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];
        }
    }
    // 同上
    - (void)af_suspend {
        NSAssert([self respondsToSelector:@selector(state)], @"Does not respond to state");
        NSURLSessionTaskState state = [self state];
        [self af_suspend];
        
        if (state != NSURLSessionTaskStateSuspended) {
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];
        }
    }
```
解释完上面的函数后，最终回到我们的load函数：
```
    + (void)load {
        /**
         WARNING: 高能预警
         https://github.com/AFNetworking/AFNetworking/pull/2702
         */
        // 担心以后iOS中不存在NSURLSessionTask
        if (NSClassFromString(@"NSURLSessionTask")) {
            /**
             iOS 7和iOS 8在NSURLSessionTask实现上有些许不同，这使得下面的代码实现略显trick
             关于这个问题，大家做了很多Unit Test，足以证明这个方法是可行的
             目前我们所知的：
                - NSURLSessionTasks是一组class的统称，如果你仅仅使用提供的API来获取NSURLSessionTask的class，并不一定返回的是你想要的那个（获取NSURLSessionTask的class目的是为了获取其resume方法）
                - 简单地使用[NSURLSessionTask class]并不起作用。你需要新建一个NSURLSession，并根据创建的session再构建出一个NSURLSessionTask对象才行。
                - iOS 7上，localDataTask（下面代码构造出的NSURLSessionDataTask类型的变量，为了获取对应Class）的类型是 __NSCFLocalDataTask，__NSCFLocalDataTask继承自__NSCFLocalSessionTask，__NSCFLocalSessionTask继承自__NSCFURLSessionTask。
                - iOS 8上，localDataTask的类型为__NSCFLocalDataTask，__NSCFLocalDataTask继承自__NSCFLocalSessionTask，__NSCFLocalSessionTask继承自NSURLSessionTask
              - iOS 7上，__NSCFLocalSessionTask和__NSCFURLSessionTask是仅有的两个实现了resume和suspend方法的类，另外__NSCFLocalSessionTask中的resume和suspend并没有调用其父类（即__NSCFURLSessionTask）方法，这也意味着两个类的方法都需要进行method swizzling。
                - iOS 8上，NSURLSessionTask是唯一实现了resume和suspend方法的类。这也意味着其是唯一需要进行method swizzling的类
                - 因为NSURLSessionTask并不是在每个iOS版本中都存在，所以把这些放在此处（即load函数中），比如给一个dummy class添加swizzled方法都会变得很方便，管理起来也方便。
            
             一些假设前提:
                - 目前iOS中resume和suspend的方法实现中并没有调用对应的父类方法。如果日后iOS改变了这种做法，我们还需要重新处理
                - 没有哪个后台task会重写resume和suspend函数
             
             */
            // 1) 首先构建一个NSURLSession对象session，再通过session构建出一个_NSCFLocalDataTask变量
            NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
            NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wnonnull"
            NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];
    #pragma clang diagnostic pop
            // 2) 获取到af_resume实现的指针
            IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));
            Class currentClass = [localDataTask class];
            // 3) 检查当前class是否实现了resume。如果实现了，继续第4步。
            while (class_getInstanceMethod(currentClass, @selector(resume))) {
                // 4) 获取到当前class的父类（superClass）
                Class superClass = [currentClass superclass];
                // 5) 获取到当前class对于resume实现的指针
                IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
                //  6) 获取到父类对于resume实现的指针
                IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
                // 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。
                if (classResumeIMP != superclassResumeIMP &&
                    originalAFResumeIMP != classResumeIMP) {
                    [self swizzleResumeAndSuspendMethodForClass:currentClass];
                }
                // 8) 设置当前操作的class为其父类class，重复步骤3~8
                currentClass = [currentClass superclass];
            }
            
            [localDataTask cancel];
            [session finishTasksAndInvalidate];
        }
    }
```

###NSSecureCoding
关于NSSecureCoding的讲解请参考[使用NSSecureCoding协议进行编解码](http://codingobjc.com/blog/2014/04/15/shi-yong-nssecurecodingxie-yi-jin-xing-bian-jie-ma/)。

因为要支持secure coding，所以要在supportsSecureCoding返回YES。









>AFNetworking源码阅读 https://www.cnblogs.com/polobymulberry/p/5081049.html
>正确使用AFNetworking的SSL保证网络安全 http://www.cocoachina.com/detail/15394
>https://www.jianshu.com/p/488c1f46cedd
>
>
>AFNetworking3.0后为什么不再需要常驻线程？
>https://www.jianshu.com/p/b5c27669e2c1