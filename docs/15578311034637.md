第13章 数组

##13.1　复习数组
数组是带索引的对象的集合。

可以从数组中获取某个索引的元素（对象）
print name[2]

可以将任意的值（对象）保存到数组的某个索引的元素中
name[0] = " 野尻 "

使用迭代器可以逐个取出数组中的元素
names.each{|name| puts name}

##13.2　数组的创建方法
使用 [] 来创建数组的方法。
```
nums = [1, 2, 3, 4, 5]
strs = ["a", "b", "c", "d"]
```
###13.2.1　使用 Array.new
```
a = Array.new
p a                    #=> []
a = Array.new(5)
p a                    #=> [nil, nil, nil, nil, nil]
a = Array.new(5, 0)
p a                    #=> [0, 0, 0, 0, 0]
```
Array 类的情况下，若 new 方法没有参数，则会创建元素个数为 0 的数组；若 new 方法只有 1 个参数，则会创建元素个数为该参数个数，且各元素初始值都为 nil 的数组；若 new 方法有两个参数，则第 1 个参数代表元素的个数，第 2 个参数代表元素值的初始值。

当希望创建元素值相同的数组时，建议使用这个方法。

###13.2.2　使用 %w 与 %i
创建不包含空白的字符串数组时，可以使用 %w。
```
lang = %w(Ruby Perl Python Scheme Pike REBOL)
p lang #=> ["Ruby", "Perl", "Python", "Scheme", "Pike",
       #    "REBOL"]
```
创建符号（Symbol）数组的 %i。
```
lang = %i(Ruby Perl Python Scheme Pike REBOL)
p lang   #=> [:Ruby, :Perl, :Python, :Scheme, :Pike, :REBOL]
```
在本例中，创建数组时使用了 () 将数组元素括了起来，但实际上还可以使用如 <>、||、!!、@@、AA 这样的任意字符。

虽然 Ruby 允许我们使用任意字符，但若用一些不常用的字符来创建数组的话，可能就会使程序不便于阅读。在选择表示字符串数组元素的字符时，还要注意该字符不能在要创建的字符串中出现，因此建议使用 ()、<>、||。

###13.2.3　使用 to_a 方法
很多类都定义了 to_a 方法，该方法能把该类的对象转换为数组。
```
color_table = {black: "#000000", white: "#FFFFFF"}
p color_table.to_a  #=> [[:black, "#000000"],
                    #   [:white, "#FFFFFF"]]
```
对散列对象使用 to_a 方法，结果就会得到相应的数组的数组。具体来说就是，将散列中的各键、值作为一个数组，然后再把这样的数组放到一个大数组中。

###13.2.4　使用字符串的 split 方法
对用逗号或者空白间隔的字符串使用 split 方法，也可以创建数组。
column = "2013/05/30 22:33 foo.html proxy.example.jp".split()
p column
\#=> ["2013/05/30", "22:33", "foo.html", "proxy.example.jp"]

##13.3　索引的使用方法
###13.3.1　获取元素
对数组指定索引值，就可以获取相应的元素。我们可以逐个获取元素，也可以一次获取多个元素。

通过 [] 指定索引，获取元素。[] 有以下 3 种用法：
（a）a [n],索引值为负数时，不是从数组的开头，而是从数组的末尾开始获取元素。如果指定的索引值大于元素个数，则返回 nil。
（b）a [n..m] 或者 a [n...m], a [n..m] 表示获取从 a [n] 到 a [m] 的元素，然后用它们创建新数组并返回（图 13.3）。a [n...m] 表示获取从 a [n] 到 a [m-1] 的元素，并用它们创建新数组返回。如果 m 的值比数组长度大，则返回的结果与指定数组最后一个元素时是一样的
（c）a [n, len],表示从 a [n] 开始，获取之后的 len 个元素，用它们创建新数组并返回。

另外，我们还可以用普通的方法代替 []。
a.at(n)　 　　　　　……与 a[n] 等价
a.slice(n)　 　 　 ……与 a[n] 等价
a.slice(n..m) 　 　……与 a[n..m] 等价
a.slice(n, len)　　　……与 a[n, len] 等价

###13.3.2　元素赋值
使用 []、at、slice 方法除了可以获取元素外，还可以对元素赋值。

###13.3.3　插入元素
插入元素其实也可以被认为是对 0 个元素进行赋值。因此，指定 [n, 0] 后，就会在索引值为 n 的元素前插入新元素。

###13.3.4　通过多个索引创建数组
使用 values_at 方法，就可以利用多个索引来分散获取多个元素，并用它们创建新数组。
a.values_at (n1, n2, …)
用这个方法，我们就可以每隔一个元素获取一次

##13.4　作为集合的数组
交集……ary = ary1 & ary2
并集……ary = ary1 | ary2
集合的差……ary = ary1 - ary2

##13.5　作为列的数组
数据结构的队列（queue）和栈（stack）都是典型的列结构。这两个相对的数据结构都有以下两种操作数据的方式。
追加元素
获取元素

||对数组开头的元素的操作|对数组末尾的元素的操作|
|----|----|----|
|追加元素|unshift|push|
|删除元素|shift|pop|
|获取元素|first|last|

##13.6　主要的数组方法
###13.6.1　为数组添加元素
a.unshift (item)
将 item 元素添加到数组的开头。

a.push (item)
a << item
<< 与 push 是等价的方法，在数组 a 的末尾添加新元素 item。

a.concat (b)
a + b
连接数组 a 和数组 b。concat 是具有破坏性的方法，而 + 则会根据原来的数组元素创建新的数组。
>在 Ruby 的方法中，有像 sort 和 sort! 这样，在相同方法名后加上 ! 的方法。为了区分方法是否具有破坏性，在具有破坏性的方法末尾添加 ! 这一做法目前已经成为了通用的规则。

a [n] = item
a [n..m] = item
a [n, len] = item
把数组 a 指定的部分的元素替换为 item。

###13.6.2　从数组中删除元素
a.compact
a.compact!
从数组 a 中删除所有 nil 元素。compact 方法会返回新的数组，compact! 则直接替换原来的数组。compact! 方法返回的是删除 nil 元素后的 a，但是如果什么都没有删除的话就会返回 nil。

a.delete(x)
从数组 a 中删除 x 元素。

a.delete_at(n)
从数组中删除 a[n] 元素。

a.delete_if{|item| … }
a.reject{|item| … }
a.reject!{|item| … }
判断数组 a 中的各元素 item，如果块的执行结果为真，则从数组 a 中删除 item。delete_if 和 reject! 方法都是具有破坏性的方法。

a.slice!(n)
a.slice!(n..m)
a.slice!(n, len)
删除数组 a 中指定的部分，并返回删除部分的值。slice! 是具有破坏性的方法。

a.uniq
a.uniq!
删除数组 a 中重复的元素。uniq! 是具有破坏性的方法。

a.shift
删除数组 a 开头的元素，并返回删除的值。

a.pop
删除数组 a 末尾的元素，并返回删除的值。

###13.6.3　替换数组元素
a.collect{|item| … }
a.collect!{|item| … }
a.map{|item| … }
a.map!{|item| … }
将数组 a 的各元素 item 传给块，并用块处理过的结果创建新的数组。从结果来看，数组的元素个数虽然不变，但由于经过了块处理，因此数组的元素和之前会不一样。

a.fill(value)
a.fill(value, begin)
a.fill(value, begin, len)
a.fill(value, n..m)
将数组 a 的元素替换为 value。参数为一个时，数组 a 的所有元素值都会变为 value。参数为两个时，从 begin 到数组末尾的元素值都会变为 value。参数为三个时，从 begin 开始 len 个元素的值会变为 value。另外，当第 2 个参数指定为 [n..m] 时，则指定范围内的元素值都会变为 value。

a.flatten
a.flatten!
平坦化数组 a。所谓平坦化是指展开嵌套数组，使嵌套数组变为一个大数组。

a.reverse
a.reverse!
反转数组 a 的元素顺序。

a.sort
a.sort!
a.sort{|i, j| … }
a.sort!{|i, j| … }
对数组 a 进行排序。排序方法可以由块指定。没有块时，使用 <=> 运算符比较。

a.sort_by{|i| … }
对数组 a 进行排序。根据块的运行结果对数组的所有元素进行排序。

##13.7　数组与迭代器
迭代器是实现循环处理的方法，而数组则是多个对象的集合。在对这些对象进行某种处理，或者取出某几个对象时，都需要大量用到迭代器。

例如，对数组的各元素进行相同的操作时使用的 each 方法就是典型的迭代器。该方法会遍历数组的所有元素，并对其进行特定的处理。

此外，接收者不是数组的情况下，为了让迭代器的执行结果能作为某个对象返回，也会用到数组。其中 collect 方法就是一个具有代表性的方法。collect 方法会收集某种处理的结果，并将其合并为一个数组后返回。
```
a = 1..5
b = a.collect{|i| i += 2}
p b    #=> [3, 4, 5, 6, 7]
```
在上面的例子中，接收者为范围对象，而结果则是数组对象。像这样，迭代器和数组就被紧密地结合在一起了。

##13.8　处理数组中的元素
###13.8.1　使用循环与索引
传统的方法是使用循环，也就是在遍历数组的同时，利用索引逐个访问数组元素。
```ruby
list = [1, 3, 5, 7, 9]
sum = 0
for i in 0..4
  sum += list[i]
end
print "合计：",sum,"\n"
```

###13.8.2　使用 each 方法逐个获取元素
```
list = [1, 3, 5, 7, 9]
sum = 0
list.each do |elem|
  sum += elem
end
print "合计：",sum,"\n"
```

###13.8.3　使用具有破坏性的方法实现循环
```
while item = a.pop
  ## 对item 进行处理
end
```
###13.8.4　使用其他迭代器
Ruby 中实现了不少像 collect、map 方法这样一眼就能看出其作用的基本操作。

###13.8.5　创建专用的迭代器
不过有时也可能会找不到自己想要的迭代器，这时就只能根据需要创建属于自己的迭代器了。

##13.9　数组的元素
数组中可以存放各种各样的对象。除了数值、字符串外，我们还可以在数组对象中存放别的数组对象或散列对象等等。

###13.9.1　使用简单的矩阵
```
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
p a[1][2]
```
###13.9.2　初始化时的注意事项
把数组对象或者散列对象作为数组元素时，需要注意该对象初始化时的问题。
```
a = Array.new(3, [0, 0, 0])
```
a中每一个元素都指向同一个[0,0,0]数组。因此：
```
a = Array.new(3, [0, 0, 0])
a[0][1] = 2
p a    #=> [[0, 2, 0], [0, 2, 0], [0, 2, 0]]
```
为了解决这个问题，我们可以指定 new 方法的块和元素个数。程序调用与元素个数一样次数的块，然后再将块的返回值赋值给元素。每次调用块都会生成新的对象，这样一来，各个元素引用同一个对象的问题就不会发生了。
```
a = Array.new(3) do
  [0, 0, 0]
end
p a    #=> [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

a[0][1] = 2
p a    #=> [[0, 2, 0], [0, 0, 0], [0, 0, 0]]
```
##13.10　同时访问多个数组
zip 方法会将接收器和参数传来的数组元素逐一取出，而且每次都会启动块。参数可以是一个也可以是多个。
```
ary1 = [1, 2, 3, 4, 5]
ary2 = [10, 20, 30, 40, 50]
ary3 = [100, 200, 300, 400, 500]

result = []
ary1.zip(ary2, ary3) do |a, b, c|
  result << a + b + c
end
p result  #=> [111, 222, 333, 444, 555]
```

>专栏：Enumerable 模块