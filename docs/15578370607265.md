第 12 章　数值类

[TOC]

##12.1　数值类的构成

在数值类中，有像 -1、0、1、10 这样的表示整数的 Integer 类，也有像 0.1、3.141592 这样的具有精度的、表示浮点小数的 Float 类。

这些数值类都被定义为了 Numeric 类的子类。另外，Integer 类又可以分为两种，一种是表示计算机硬件可以处理的数值的 Fixnum 类，另外一种是表示比 Fixnum 更大的数值的 Bignum 类。
![](https://box.kancloud.cn/2015-10-26_562e01efb6396.png)
程序中用到的整数一般都是 Fixnum 类范围内的整数。如果使用的整数超过了 Fixnum 的范围，Ruby 就会自动将其转换为 Bignum 类。因此，在写程序的时候，我们几乎可以忽略上述整数类的区别。下面是计算 2 的 10 次幂以及 2 的 1000 次幂的例子，** 是表示乘方的运算符。

Ruby 也可以处理有理数和复数。表示有理数用 Rational 类，表示复数用 Complex 类。

Rational 对象用“Rational( 分子 , 分母 )”的形式定义。我们还可以使用 Rational#to_f 方法将其转换为 Float 对象。
```
a = Rational(2, 5)
b = Rational(1, 3)
p a                #=> (2/5)
p b                #=> (1/3)
c = a + b
p c                #=> (11/15)
p c.to_f           #=> 0.7333333333333333
```
Complex 对象用“Complex( 实数 , 虚数 )”的形式定义。以下是计算复数 2i 的 2 次幂的例子：
```
c = Complex(0, 2) ** 2
p c                    #=> (-4+0i)
```

##12.2　数值的字面量
单纯的数字罗列表示 10 进制整数。以 0b 开头的数值表示 2 进制数，以 0 或者 0o 开头的数值表示 8 进制数，以 0d 开头的数值表示 10 进制数，以 0x 开头的数值表示 16 进制数。字面量中的 _ 会被自动忽略。还可以指数表示法，例如1.23e4。

##12.3　算数运算
+,-,\*,/,%,**
指数为负整数的乘方返回的结果是表示有理数的 Rational 对象。

除法
除了 / 和 % 以外，数值对象中还有一些与除法相关的方法。

x.div(y)
返回 x 除以 y 后的商的整数。
```
p 5.div(2)        #=> 2
p 5.div(2.2)      #=> 2
p -5.div(2)       #=> -3
p -5.div(2.2)     #=> -3
```

x.quo(y)
返回 x 除以 y 后的商，如果 x、y 都是整数则返回 Rational 对象。
```
p 5.quo(2)        #=> (5/2)
p 5.quo(2.2)      #=> 2.2727272727272725
p -5.quo(2)       #=> (-5/2)
p -5.quo(2.2)     #=> -2.2727272727272725
```

x.modulo(y)
与 x % y 等价。

x.divmod(y)
将 x 除以 y 后的商和余数作为数组返回。商是将 x / y 的结果去掉小数点后的部分而得到的值。余数的符号与 y 的符号一致，余数的值为 x % y 的结果。假设有运算式如下，
ans=x.divmod(y)
这时，下面的等式是成立的。
x==ans[0] *y + ans[1]
```
p 10.divmod(3.5)        #=> [2, 3.0]
p 10.divmod(-3.5)       #=> [-3, -0.5]
p -10.divmod(3.5)       #=> [-3, 0.5]
p -10.divmod(-3.5)      #=> [2, -3.0]
```

x.remainder(y)
返回 x 除以 y 的余数，结果的符号与 x 的符号一致。
```
p 10.remainder(3.5)        #=> 3.0
p 10.remainder(-3.5)       #=> 3.0
p -10.remainder(3.5)       #=> -3.0
p -10.remainder(-3.5)      #=> -3.0
```
另外，除数为 0 时，Integer 类会返回错误，而 Float 类则会返回 Infinity（无限大）或者 NaN（Not a Number）。如果再用这两个值进行运算，那么结果只会返回 Infinity 或者 NaN。程序把输入的数据直接用于运算的时候，除数有可能会为 0，我们应当注意避免这样的情况发生。
```
p 1 / 0         #=> 错误（ZeroDivisionError）
p 1 / 0.0       #=> Infinity
p 0 / 0.0       #=> NaN
p 1.divmod(0)   #=> 错误（ZeroDivisionError）
p 1.divmod(0.0) #=> 错误（FloatDomainError）
```

##12.4　Math 模块
Math 模块提供了三角函数、对数函数等常用的函数运算的方法。该模块中定义了模块函数和常量，例如，求平方根时，可以采用下述方法。

表 12.3　Math 模块定义的方法
表 12.4　Math 模块定义的常量
PI E
##12.5　数值类型转换
将 Integer 对象转换为 Float 对象时，可以使用 to_f 方法。相反，使用 to_i 方法则可以将 Float 对象转换为 Integer 对象（Integer#to_i 方法和 Float#to_f 方法返回与接收者一样的值）。另外，也可以把字符串转换为数值。
```
p 10.to_f       #=> 10.0
p 10.8.to_i     #=> 10
p -10.8.to_i    #=> -10
p "123".to_i    #=> 123
p "12.3".to_f   #=> 12.3
```

Float#to_i 方法返回的结果会把小数点以后的值去掉。我们用 round 方法对小数进行四舍五入的处理。
```
p 1.2.round    #=> 1
p 1.8.round    #=> 2
p -1.2.round   #=> -1
p -1.8.round   #=> -2
```
返回比接收者大的最小整数用 ceil 方法，返回比接收者小的最大整数用 floor 方法。
```
p 1.5.ceil     #=> 2
p -1.5.ceil    #=> -1
p 1.5.floor    #=> 1
p -1.5.floor   #=> -2
```

我们还可以将数值转换为 Rational 对象和 Complex 对象，分别使用 to_r 和 to_c 方法，如下所示。
```
p 1.5.to_r     #=> (3/2)
p 1.5.to_c     #=> (1.5+0i)
```

##12.6　位运算
~,|,&,^,>>,<<

##12.7　随机数
我们可以用 Random.rand 方法得到随机数。不指定参数时，Random.rand 方法返回比 1 小的浮点小数。参数为正整数时，返回 0 到该正整数之间的数值。
```
p Random.rand        #=> 0.13520495197709
p Random.rand(100)   #=> 31
p Random.rand(100)   #=> 84
```
使用 Random.new 方法初始化随机数生成器，然后再使用 Random#rand 方法，就可以对 Random 对象指定随机数种子，从而生成随机数。
```
r1 = Random.new(1)    # 初始化随机数组
p [r1.rand, r1.rand]
  #=> [0.417022004702574, 0.7203244934421581]

r2 = Random.new(1)    # 再次初始化随机数组
p [r2.rand, r2.rand]
  #=> [0.417022003702574, 0.7203244934421581]
```
模拟随机数终究只是通过计算得到的数值，只要随机数的种子一样，那么得到值就有可能重复出现。Random.new 方法不指定参数的情况下，则会用随机生成的随机数种子初始化 Random 对象，因此每次得到的随机数组也会不一样。
```
r1 = Random.new
p [r1.rand, r1.rand]
  #=> [0.49452535392946817, 0.34141702823098863]

r2 = Random.new
p [r2.rand, r2.rand]
  #=> [0.9464262066747281, 0.01911968591048996]
```

##12.8　计数
除了数值计算外，Integer 类还能计算处理的次数、数组的元素个数等。接下来介绍的方法就是按照数值指定的次数执行循环处理的迭代器。

n.times{|i| … }
循环 n 次，从 0 到 n-1 的值会被依次赋值给块变量。
```
ary = []
10.times do |i|
  ary << i
end
p ary    #=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

from.upto(to){|i| … }
从 from 开始循环对 i 进行加 1 处理，直到 i 等于 to。from 比 to 大时不会执行循环处理。
```
ary = []
2.upto(10) do |i|
  ary << i
end
p ary    #=> [2, 3, 4, 5, 6, 7, 8, 9, 10]
```

from.downto(to){…}
从 from 开始循环对 i 进行减 1 处理，直到 i 等于 to。from 比 to 小时不会执行循环处理。
```
ary = []
10.downto(2) do |i|
  ary << i
end
p ary    #=> [10, 9, 8, 7, 6, 5, 4, 3, 2]
```

from.step(to, step){…}
从 from 开始循环对 i 进行加 step 处理，直到 i 等于 to。step 为正数时，from 比 to 大时不会执行循环处理。step 为负数时，from 比 to 小时不会执行循环处理。
```
ary = []
2.step(10, 3) do |i|
  ary << i
end
p ary    #=> [2, 5, 8]
　
ary = []
10.step(2, -3) do |i|
  ary << i
end
p ary    #=> [10, 7, 4]
```
如果不对 times、upto、downto、step 的各方法指定块，则会返回 Enumerator 对象。这样，之前通过 step 方法的块获取的一连串数值，就同样也可以通过 Enumerator#collect 方法获取。
```
ary = 2.step(10).collect{|i| i * 2}
p ary    #=> [4, 6, 8, 10, 12, 14, 16, 18, 20]
```

##12.9　近似值误差
虽然我们期待 0.1 + 0.2 与 0.3 的比较结果为 true，但实际结果却是 false。

如果可以把小数转换为两个整数相除的形式，那么通过使用 Rational 类进行运算，就可以避免近似值误差。
```
a = Rational(1, 10) + Rational(2, 10)
b = Rational(3, 10)
p [a, b]    #=> [(3/10), (3/10)]
p a == b
```

另外，Ruby 还提供了 bigdecimal 库，可以有效处理拥有更多小数位的 10 进制数。

>Comparable 模块
Ruby 的比较运算符（\==、<= 等）实际上都是方法。Comparable 模块里封装了比较运算符，将其 Mix-in 到类后，就可以实现实例间互相比较的方法（下表）。
<，<=,==,>=	,>,between?
>Comparable 模块中的各运算符都会使用 <=> 运算符的结果。<=> 运算符如果能像下表那样定义的话，上表中的各个方法就都可以使用。
>a <>时	-1( 比0 小)
a == b时	0
a > b时	1（比 0 大）