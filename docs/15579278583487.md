iOS动画部分备览

[TOC]

iOS动画主要由Core Animation提供，UIKit部分也提供了少量的动画支持。

##1.什么是核心动画

Core Animation可以用在 Mac OS X 和 iOS平台。Core Animation的动画执行过程是在后台操作的，不会阻塞主线程。要注意的是， Core Animation是直接作用在CALayer上的，并非UIView。

总体来说核心动画的优点有：
1、性能强大，使用硬件加速，可以同时向多个图层添加不同的动画效果
2、接口易用，只需要少量的代码就可以实现复杂的动画效果。
3、运行在后台线程中，在动画过程中可以响应交互事件（UIView动画默认动画过程中不响应交互事件）
4、只有在发生改变的时候才重绘内容，消除了动画的帧速率上的运行代码，提高应用性能

核心动画的组成包括一些图层、图层布局和动画。

在QuartzCore（ = Core Animation + CALayer类及其派生类 + 少部分其它类与协议）中，CALayer是作为渲染模型设计的，它持有渲染的几何图层的原始数据。
动画通过在有效时长内动态改变渲染模型的属性值，实时提交渲染，进而呈现动画。


我们看一下核心动画的几个类：
![](https://upload-images.jianshu.io/upload_images/1776769-affec476c9834967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
![](http://cc.cocimg.com/api/uploads/20170622/1498114752750475.png)
![](https://upload-images.jianshu.io/upload_images/5447877-edd54d489cb42c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567)

下面我们从上图的协议以及类的属性入手，分析一下上图结构：

###1.1 CAMediaTiming
CAMediaTiming 协议中定义了时间，速度，重复次数等。属性定义如下：

**beginTime**
对象的开始时间，相对于它的父对象，如果有的话。对于没有父对象概念的CAAnimation来说，它可以用来设置动画延时，若想延迟1秒，就设置为CACurrentMediaTime()+1，其中CACurrentMediaTime()为图层当前时间。对于有父对象概念的CALayer来说，它的beginTime一般用于动画暂停的使用，暂停几秒就设置多少。CAAnimation的beginTime一般用于动画延迟执行，但只在使用groupAnimation的时候生效，直接添加在layer上的animation使用会导致动画不执行。

在Core Animation中，对于一个CALayer或CAAnimation，都有一条自己的时间线timeline。而.beginTime是在父object的时间线中，layer开始渲染或animation动画开始渲染的时间点（本地时间）。
比如：
layer.beginTime是layer在layer.superlayer的时间线中，layer开始渲染的时间点；
animation.beginTime是animation在[animLayer addAnimation:animation forKey:nil]的那个animLayer的时间线中，animation开始动画的时间点。
除此之外，和beginTime相关的，Core Animation还有一个absoluteTime（绝对时间），通过CACurrentMediaTime()获取，其本质为系统时钟时间mach_absolute_time()的秒数值。

下面通过一个例子来说明。
现象：superlayer在屏幕显示之后，layer延迟了2.0秒才显示。
```
CALayer *superlayer = [CALayer layer];
..
CALayer *layer = [CALayer layer];
layer.beginTime = [layer convertTime:CACurrentMediaTime() fromLayer:superlayer]+2.0f;
[superlayer addSublayer:layer];
```
解释：
由于layer.beginTime属性设置的是layer在superlayer的时间线中开始渲染的时间点（本地时间），
而CACurrentMediaTime()可以理解为在现实世界随时间流逝的现在这个时刻，
convertTime: fromLayer:将现在这个时刻（绝对时间）转换成相应的这个时刻在super的时间线中对应的时间点，
然后对应的时间点上加上了2.0秒，并设置为layer的beginTime。
所以最后的结果是看到的是layer在现实世界2.0秒后延迟出现在屏幕上。


**duration**
动画的持续时间，默认为0，默认仅是默认，实际会执行0.25秒。

**speed**
动画速率，决定动画时间的倍率。默认为1，即保持为原动画速率。当speed为2时，动画时间为设置的duration的1/2。速度 speed = 1.0 / duration = 1.0 的动画效果 和 speed = 2.0 / duration = 2.0 的动画效果是一模一样的，我们设置的duration可能和动画进行的真实duration不一样，这个还依赖于speed。

**timeOffset**
动画时间偏移量。比如设置动画时长为3秒，当设置timeOffset为1.5时，当前动画会从中间位置开始，并在到达指定位置时，走完之前跳过的前半段动画。再比如假定一个3s的动画，它的状态为t0,t1,t2,t3，当没有timeOffset的时候，正常的状态序列应该为：
t0->t1->t2->t3
当设置timeOffset为1的时候状态序列就变为
t1->t2->t3->t0
同理当timeOffset为2的时候状态序列就变为：
t2->t3->t0->t1

**repeatCount**
动画的重复次数。默认为0，默认只是默认，实际执行1次。

**repeatDuration**
重复进行动画的有效时长。当repeatCount设定为!=0时，
1、当repeatDuration==0，动画的有效时长等于repeatCount*duration
2、当repeatDuration！=0，动画的有效时长等于repeatDuration，忽略duration

**autoreverses**
动画由初始值到最终值后，是否反过来回到初始值的动画。如果设置为YES，就意味着动画完成后会以动画的形式回到初始值。

**fillMode**
动画填充模式，决定当前对象在非动画时间段的行为。比如动画开始之前，动画结束之后。fillMode属性值如下:(要想fillMode有效，最好设置removedOnCompletion = NO）
* kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态
* kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态，也就是属性toValue指定值状态。但removedOnCompletion=YES时，这个状态不可保持，会恢复为初始状态。 
* kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始，也就是属性一开始就到了fromValue的位置并等待动画开始，而模式kCAFillModeRemoved和kCAFillModeForwards会在动画开始后才迅速到达fromValue的位置。
* kCAFillModeBoth 这个其实就是上面两个的合成，动画加入之后在开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态

其实不只是CAAnimation遵循CAMediaTiming协议，熟悉底层结构的小伙伴们应该知道CALayer也遵循这个协议，所有在一定程度上我们可以通过控制layer本身的协议属性来控制动画节奏。

###1.2 CAAnimation 

CAAnimation是所有动画对象的父类，实现CAMediaTiming协议，负责控制动画的时间、速度和时间曲线等等，是一个抽象类，不能直接使用。除了CAMediaTiming协议中的方法，增加了CAAnimationDelegate的代理属性等。具体如下：

**timingFunction**
控制动画的节奏。系统提供的包括：kCAMediaTimingFunctionLinear （匀速），kCAMediaTimingFunctionEaseIn （慢进快出），kCAMediaTimingFunctionEaseOut （快进慢出），kCAMediaTimingFunctionEaseInEaseOut （慢进慢出，中间加速），kCAMediaTimingFunctionDefault （默认），当然也可通过自定义创建CAMediaTimingFunction。

CAMediaTimingFunction时间函数类对象。用于描述动画的执行速率（三次贝塞尔曲线）。
从CAMediaTimingFunction类获取对象有两种方式：
一是使用+functionWithName:，根据function_name获取常用的预配置函数，目前系统提供的有四种。

二是通过传入两个点坐标（贝塞尔曲线控制点坐标。三次贝塞尔曲线需要4个控制点确定，系统默认添加了(0,0)和(1,1)两个控制点，因此只需传入中间两个控制点坐标）获取自定义的函数：
（**c1&c2点坐标）
+ (instancetype)functionWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;
- (instancetype)initWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;
至于如何算控制点坐标，和相应的贝塞尔曲线，超出本文范围，这里给个[传送门](http://cubic-bezier.com/)，手动拖一拖就行，很直观。或参考[自定义缓冲函数](https://zsisme.gitbooks.io/ios-/content/chapter10/custom-easing-functions.html)


**delegate**
动画代理。id类型对象。需要遵守协议CAAnimationDelegate。根据动画不同的的生命周期，会回调代理对象的以下两个方法：
```
-(void)animationDidStart:(CAAnimation *)anim; 核心动画开始时执行
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; 核心动画执行结束后调用
```
该代理是NSObject的分类，NSObject默认实现了CAAnimationDelegate分类，而所有类继承自NSObject，因此为动画设置delegate时，只需要重写以上两个方法即可。

**removedOnCompletion**
是否让图层保持显示动画执行后的状态，默认为YES，也就是动画执行完毕后从图层上移除，恢复到执行前的状态，如果设置为NO，并且设置fillMode为kCAFillModeForwards，则保持动画执行后的状态。

###1.3 CAPropertyAnimation 
属性动画，针对对象的可动画属性进行效果的设置，不可直接使用。添加属性具体如下：

**keyPath**
CALayer的某个属性名，并通过这个属性的值进行修改，达到相应的动画效果。

**additive**
属性动画是否以当前动画效果为基础，默认为NO。若为YES，把当前呈现layer相应keyPath的value，与动画设置的值value（它的子类中会提供），两者进行叠加作为该动画最终渲染value。

**cumulative**
指定动画是否为累加效果，默认为NO。和上面类似，但只对于重复执行的动画，下一轮的动画的初始value为动画设置的value叠加上一轮的结束时呈现的value

**valueFunction**
此属性配合CALayer的transform属性使用。对keyPath为transform是如何插值计算的（tranform3D的Rotate，Scale，Translate）。这个属性存在的意义在于CALayer只有transform属性，transform.rotation以及transform.rotation.y都是并不真实存在的。

###1.4 CABasicAnimation
基础动画，通过keyPath对应属性进行控制，需要设置fromValue以及toValue。只添加了如下属性：

**fromValue**
keyPath相应属性的初始值。

**toValue**
keyPath相应属性的结束值。

**byValue**
在不设置toValue时，toValue = fromValue + byValue，也就是在当前的位置上增加多少。

插值规律:
1. fromValue和toValue都设置了，就在这两者间插值
2. fromValue、byValue非空，toValue为空，就在fromValue和（fromValue+byValue）间插值
3. toValue、byValue非空，fromValue为空，就在（toValue-byValue）和toValue之间插值
4. fromValue非空，就在fromValue和当前值之间插值
5. toValue非空，就在当前值和toValue之间插值
6. byValue非空，就在当前值和（当前值+byValue）之间插值
7. 均为空，就在前一个值和当前值之间插值。

注：当前值和前一个值均是目标layer的presentation layer的keypath对应的值。

###1.5 CASpringAnimation 
带有初始速度以及阻尼指数等物理参数的属性动画。iOS9后新增。我们可以把它看成在不绝对光滑的地面上，一个弹簧拴着别小球，那么我们可以这么理解他的属性（物理知识请问一下牛顿大叔）：

**mass**
物件质量。增大mass，会使振动时偏离toValue的绝对值增大，并使到达toValue的时间变长，即以下的settlingDuration值增加。默认值为1

**stiffness**
弹性系数。增大stiffness，会使settlingDuration值减少。默认值为100。

**damping**
阻尼系数，地面的摩擦力。增大damping，每次振动时偏离toValue的绝对值衰减更快，结果会使settlingDuration值减少。默认值为10

**initialVelocity**
初始速度，layer有个初始速度，当initialVelocity大于0，layer向toValue运动得更快（初始速度+initialVelocity）；当initialVelocity小于0，向toValue运动更缓慢。并在小于某个值时，会使layer开始动画时，初速度反向再逐渐向toValue运动


**settlingDuration**
结算时间，根据上述参数计算出的到达toValue的预计时间，相对于你设置的时间，这个时间比较准确，readonly只读。有一点注意要的是，当设置了duration时，弹簧动画的实际有效时长为duration = duration>settlingDuration ? duration : settlingDuration（duration与settlingDuration中值比较大的那个，它们很有可能不等）


###1.6 CAKeyframeAnimation 
关键帧动画，同样通过keyPath对应属性进行控制，但它可以通过values或者path进行多个阶段的控制。属性如下：

**values**
关键帧组成的数组，动画对象会在指定的时间（duration）内，依次显示其中的每一帧。关键帧是keypath对应的离散的属性值。

**path**
关键帧路径，可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略。

**keyTimes**
NSNumber数组类型，数组元素值取值范围从0.0f到1.0f，它表示某关键帧，或者设置了path时path某控制点的呈现时间点，具体时间点是duration*keyTime。对于使用values，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的。对于使用path也类似。

**timingFunctions**
每一帧对应的动画节奏。CAMediaTimingFunction数组类型，对于多段的关键帧补间，应该设置该时间函数数组属性，而不是继承父类的那个timingFunction属性，timingFunctions个数应为keyTimes个数-1。

**calculationMode**
动画的计算模式，系统提供了对应的几种模式。所谓计算模式：其主要针对的是每一帧的内容为一个坐标点的情况，也就是对anchorPoint和 position进行的动画。当在平面坐标系中有多个离散的点的时候，可以是离散的，也可以直线相连后进行插值计算，也可以使用圆滑的曲线将他们相连后进行插值计算。

calculationMode目前提供如下几种模式：
- kCAAnimationLinear 默认值，表示当关键帧为坐标点的时候，关键帧之间直接直线相连进行插值计算 

- kCAAnimationDiscrete 离散的，不进行插值计算，所有关键帧直接逐个进行显示

- kCAAnimationPaced 使得动画均匀进行，而不是按keyTimes设置的或者按关键帧平分时间，此时keyTimes和timingFunctions无效

- kCAAnimationCubic 对关键帧为坐标点的关键帧进行圆滑曲线相连后插值计算，这里的主要目的是使得运行的轨迹变得圆滑

- kCAAnimationCubicPaced 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀，就是系统时间内运动的距离相同，此时keyTimes以及timingFunctions也是无效的

注意：就目前而言，此属性研究的意义不大，知道有这么一个属性即可，只有再做复杂动画，同时动画效果不够理想的时候，才需要考虑使用这一属性

**tensionValues**
动画张力控制。仅当calculationMode设为kCAAnimationCubic时适用。（kCAAnimationCubic与kCAAnimationCubicPaced模式计算的曲线是数学上称为Catmull-Rom spline的曲线，这个属性和下面两个属性是其数学公式的参数，用于定制这条曲线，取值都为-1到1，默认值都为0。）越比0大，（曲线点与点之前的）圆弧越紧致；越比0小，圆弧越偏圆。

**continuityValues**
动画连续性控制。越比0大，圆弧越尖（偏三角）；负值为倒置的圆弧

**biasValues**
动画偏差率控制。越比0大，圆弧越比0时的圆弧向外偏移；越比0小，越向内陷。没有特殊需求的话，以上三个属性值都无须修改。单设置kCAAnimationCubic就可以获得系统预设的平滑过渡

**rotationMode**
动画沿路径旋转方式，系统提供了两种模式。仅当设置了path属性时适用。在layer运动的过程中：
kCAAnimationRotateAuto：layer的x轴正方向与运动路径的切线方向相平行且相同
kCAAnimationRotateAutoReverse：layer在kCAAnimationRotateAuto基础上，再旋转180度

###1.7 CAAnimationGroup 
动画组，方便对于多动画的统一控制管理。

**animations**
所有动画效果元素的数组。

###1.8 CATransition 
转场动画，系统提供了很多酷炫效果。属性如下：

**type**
转场动画类型。

**subtype**
转场动画方向。

**startProgress**
动画起点进度（整体的百分比）。

**endProgress**
动画终点进度（整体的百分比）。

**filter**
自定义转场。



##2. CAPropertyAnimation属性动画
CAPropertyAnimation是CAAnimation的抽象子类。不应该直接使用它来创建动画，而应该使用它的子类CABasicAnimation和CAKeyframeAnimation来创建动画。

keyPath：通过指定CALayer的一个属性名做为keyPath里的参数(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。

一些常用的animationWithKeyPath值的总结

|值|说明|使用形式|
|----|----|----|
|transform.scale|比例转化|@(0.8)|
|transform.scale.x|宽的比例|@(0.8)|
|transform.scale.y|高的比例|@(0.8)|
|transform.rotation.x|围绕x轴旋转|@(M_PI)|
|transform.rotation.y|围绕y轴旋转|@(M_PI)|
|transform.rotation.z|围绕z轴旋转|@(M_PI)|
|cornerRadius|圆角的设置|@(50)|
|backgroundColor|背景颜色的变化|(id)[UIColor purpleColor].CGColor|
|bounds|大小，中心不变|[NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)];|
|position|位置(中心点的改变)|[NSValue valueWithCGPoint:CGPointMake(300, 300)];|
|contents|内容，比如UIImageView的图片|imageAnima.toValue = (id)[UIImage imageNamed:@"to"].CGImage;|
|opacity|透明度|@(0.7)|
|contentsRect.size.width|横向拉伸缩放|@(0.4)最好是0~1之间的|

keyPath支持的属性有：
几何属性:
bounds // 大小
position // 位置
frame // **根据bounds和position计算出来的属性，不支持动画
anchorPoint // 几何锚点。详情看CALayer篇
cornerRadius // 圆角半径
transform // 几何变换
zPosition // zPosition值越大，在父layer中的视图层级越高。zPosition=1的layerA将覆盖在zPosition=0的layerB之上。

背影属性：
backgroundColor // 背景颜色渐变

渲染内容属性：
contents // 内容渐变，常设：CGImage
contentsRect // 矩形范围内容才会被渲染，并拉伸到layer大小
masksToBounds // 截掉超出layer的内容

子Layer：
sublayers // 所有的子layer
sublayerTransform // 所有子layer的几何变换

边框：
borderColor // 边框颜色
borderWidth // 边框宽度

阴影：
shadowColor // 阴影颜色
shadowOffset // 阴影偏移
shadowOpacity // 阴影不透明度
shadowRadius // 阴影半径
shadowPath // 阴影路径

不透明度：
opacity

遮罩：
mask

其它：
doubleSided // layer是否显现双面。\*\*无隐式动画
hidden // 隐藏

这里要注意的是，除了这些是所有CALayer所通用的外，CALayer的子类有不同的属性可供动画使用。例如CAShapeLayer的strokeStart和strokeEnd等，可以用其实现着色动画效果。

CAPropertyAnimation其它属性举例：
（例子会用到CABasicAnimation，继承自CAPropertyAnimation，其中fromValue和toValue指的是动画从keyPath的fromValue开始，到toValue结束。比如keyPath=@"position.y"，fromValue=0，toValue=100表示layer从position的y=0运动到y=100。）

layer的初始状态为
```
CALayer *layer = [CALayer layer];
layer.bounds = CGRectMake(0,0,60,60);// 大小
layer.position = CGPointMake(100,100);// 位置
```
additive:
```
CABasicAnimation *anim = [CABasicAnimation animation];
anim.duration = 3;
anim.keyPath = @"position.y";// 动画类型为y轴坐标值变化动画
anim.fromValue = @100;// 从
anim.toValue = @200;// 到

anim.additive = NO;// layer将从poistion.y=100运动到200

// 呈现layer相应keyPath的值，即layer的poistion的y为100（layerPosY=100）
anim.additive = YES;// 若为YES，fromValue+=layerPosY，toValue+=layerPosY
                    // 即100+@100开始运动到100+@200
[layer addAnimation:anim forKey:nil];
```
cumulative:
```
anim.repeatCount = 2;// 动画重复执行2次
anim.cumulative = NO;// layer从y=100运动到200结束，layer重新从y=100开始运动（lastPosY=200）

anim.cumulative = YES;// 将进行第2轮动画时，fromValue+=lastPosY，toValue+=lastPosY
                      // 即从200+@100运动到200+@200
```
valueFunction:
```
CABasicAnimation *anim2 = [CABasicAnimation animation];
anim2.keyPath = @"transform";
anim2.fromValue = @0;
anim2.toValue = @M_PI;

anim2.valueFunction = [CAValueFunction functionWithName:kCAValueFunctionRotateY];// 为RotateY进行插值
```
也可以不设置valueFunction，
keyPath改为@"transform.rotation.y"
或者.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 0, 1, 0)];
都是一样效果：
![绕y轴旋转180度](https://upload-images.jianshu.io/upload_images/1776769-a2c7f7f15e751198.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/145)

此外，CAValueFunction的+functionWithName:预设有：
kCAValueFunctionRotateX // 绕x轴旋转
kCAValueFunctionRotateY // 绕y轴旋转
kCAValueFunctionRotateZ // 绕z轴旋转
kCAValueFunctionScale // 大小缩放。应为value赋值为数组@[@x, @y, @z]，表示x,y,z轴上的缩放比例
kCAValueFunctionScaleX // x轴上缩放
kCAValueFunctionScaleY // y轴上缩放
kCAValueFunctionScaleZ // z轴上绽放
kCAValueFunctionTranslate // 位移，类似kCAValueFunctionScale
kCAValueFunctionTranslateX // x轴位移
kCAValueFunctionTranslateY // y轴位移
kCAValueFunctionTranslateZ // z轴位移

##3. CABasicAnimation基本动画
在一般的应用开发中，基础动画可以满足大部分的开发需求，主要完成对于对象指定动画属性两个Value之间的动画过度。

使用过程如下：
* 初始化动画并设置动画keyPath（keyPath为指定动画效果的CALayer的某个属性名，比如position属性）

* 设置动画其他属性，比如delegate，fromValue，toValue，duration等

* 利用- (void)addAnimation:(CAAnimation *)animationForKey:(nullable NSString *)key;添加给指定layer添加动画

* 利用- (void)removeAllAnimations;或者- (void)removeAnimationForKey:(NSString *)key;方法停止所有或者指定动画

* 动画的暂停与恢复
```
//2.动画pause
    // 将当前时间CACurrentMediaTime转换为layer上的时间, 即将parent time转换为local time
    CFTimeInterval pauseTime = [view.layer convertTime:CACurrentMediaTime() fromLayer:nil];
    
    // 设置layer的timeOffset, 在继续操作也会使用到
    view.layer.timeOffset = pauseTime;
    
    // local time与parent time的比例为0, 意味着local time暂停了
    view.layer.speed = 0;
```
```
//3.动画continue
    // 时间转换
    CFTimeInterval pauseTime = view.layer.timeOffset;
    // 计算暂停时间
    CFTimeInterval timeSincePause = CACurrentMediaTime() - pauseTime;
    // 取消
    view.layer.timeOffset = 0;
    // local time相对于parent time世界的beginTime
    view.layer.beginTime = timeSincePause;
    // 继续
    view.layer.speed = 1;
```
    
动画过程说明：
* 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue

* keyPath内容是CALayer的可动画Animatable属性

* 如果fillMode=kCAFillModeForwards同时removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。

fillMode使用举例：
* kCAFillModeForwards

```
//kCAFillModeForwards
CABasicAnimation * basicAnimation = [[CABasicAnimation alloc] init];
    basicAnimation.keyPath = @"position.y";
    basicAnimation.removedOnCompletion = NO;
    //beginTime : 动画的开始时间
    //CACurrentMediaTime() : 图层的当前时间
    //让动画延迟3秒执行
    basicAnimation.beginTime = CACurrentMediaTime()+3;
    basicAnimation.fillMode = kCAFillModeForwards;
    //动画的开始位置
    basicAnimation.fromValue = @300;
    //动画的结束位置
    basicAnimation.toValue = @500;
    //动画持续时间
    basicAnimation.duration = 3;
    [self.layer addAnimation:basicAnimation forKey:nil];
```
效果图：
![kCAFillModeForwards](https://upload-images.jianshu.io/upload_images/1846368-7ca219b10f1b4dcb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/373)


* kCAFillModeBackwards

```
CABasicAnimation * basicAnimation = [[CABasicAnimation alloc] init];
    basicAnimation.keyPath = @"position.y";
    //beginTime : 动画的开始时间
    //CACurrentMediaTime() : 图层的当前时间
    //让动画延迟3秒执行
    basicAnimation.beginTime = CACurrentMediaTime()+3;
    basicAnimation.fillMode = kCAFillModeBackwards;
    //动画的开始位置
    basicAnimation.fromValue = @300;
    //动画的结束位置
    basicAnimation.toValue = @500;
    //动画持续时间
    basicAnimation.duration = 3;
    [self.layer addAnimation:basicAnimation forKey:nil];
```
效果图：
![](https://upload-images.jianshu.io/upload_images/1846368-3a353d01a8f93832.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/373)

接下去的例子，我们采用的代码是:
```
 //初始化动画并设置keyPath
    CABasicAnimation *basicAni = [CABasicAnimation animationWithKeyPath:@"position"];
    //设置代理
    basicAni.delegate = self;
    //到达位置
    basicAni.toValue = [NSValue valueWithCGPoint:position];
    //延时执行
    //basicAni.beginTime = CACurrentMediaTime() + 2;
    //动画时间
    basicAni.duration = 3;
    //动画节奏
    basicAni.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    //动画速率
    //basicAni.speed = 0.1;
    //图层是否显示执行后的动画执行后的位置以及状态
    basicAni.removedOnCompletion = NO;
    basicAni.fillMode = kCAFillModeForwards;
    //动画完成后是否以动画形式回到初始值
    //basicAni.autoreverses = YES;
    //动画时间偏移
    //basicAni.timeOffset = 0.5;
    //添加动画
    [_aniLayer addAnimation:basicAni forKey:NSStringFromSelector(_cmd)];
```
在上述代码中，我们注释掉这两行：
```
//basicAni.removedOnCompletion = NO;
//basicAni.fillMode = kCAFillModeForwards;
```
运行结果：
![](https://upload-images.jianshu.io/upload_images/4408163-0e731b515386a8e9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/226)
去掉这两行代码后，layer完成动画后跳回到开始的位置，我们看到的这种现象结合layer层级的打印，我们可以确定：动画本身并没有改变model tree的位置，我们看到的动画是presentation tree运动的轨迹。当设置removedOnCompletion  属性为NO以及fillMode属性为kCAFillModeForwards时，也并未改变model tree的位置，但是可以使动画结束后，防止presentation tree被移除并回到动画开始的位置。所以并不建议使用removedOnCompletion配合fillMode的方式来实现动画结束时，图层不跳转回原位的实现，我们应该在动画开始或者结束时重新设置它的位置。我们这么做：
```
//储存结束位置
[basicAni setValue:[NSValue valueWithCGPoint: position] forKey:@"positionToEnd"];
//动画结束后，重新设置它的位置
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
    _aniLayer.position = [[anim valueForKey:@"positionToEnd"] CGPointValue];
}
```
我们来看一下效果:
![](https://upload-images.jianshu.io/upload_images/4408163-66cc97408a8233f2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/226)
我们发现了另一个问题，当动画完成后，它会重新从起点运动到终点，对于非根图层，设置它的可动画属性是有隐式动画的，那么我们需要关闭图层的隐式动画，我们就需要用到动画事务CATransaction：
说到这，我们就简单介绍一下CATransaction，和NSAutoreleasePool一样，当我们不手动创建时，系统会在一帧开始时生成一个事务，并在这一帧结束时commit，这也就是隐式CATransaction。当然你也可以利用[CATransaction begin]方法开始，调用[CATransaction commit]方法结束，中间便是事务的作用域，然后把需要更改可动画属性的操作放在该作用域内，这就是显式CATransaction，它常常用于关闭隐式动画和调整动画时间。下面我们就用它来关闭修改图层的position时所带来的隐式动画：
```
动画结束时我们这样写：
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
    //开始事务
    [CATransaction begin];
    //关闭隐式动画
    [CATransaction setDisableActions:YES];
    _aniLayer.position = [[anim valueForKey:@"positionToEnd"] CGPointValue];
    //提交事务
    [CATransaction commit];
}
```
运行效果：
![](https://upload-images.jianshu.io/upload_images/4408163-4cae02f30335ef2d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/226)

##4. CASpringAnimation弹性动画
CASpring​Animation由iOS 9.0+ SDK开始支持，所以并不兼容9.0以下版本，要根据实际开发来选择使用。
继承自CABasicAnimation，弹簧动画。
CASpring​Animation类似于下面的场景：
一个被一端固定在墙上的弹簧钩住的物件，放在有摩擦力的地面某初始位置（fromValue）上，从弹簧压缩状态，手按住到释放物件，弹簧推动物件加速；
直到弹簧开始要被拉伸了，物件开始减速。减速到0时，弹簧收缩并拉回物件；
在拉回到弹簧原长的时候，由于这时物件有速度、动能，物件继续运动并因弹簧推(弹)力减速至0，弹簧再次被压缩；
如此反复左右振动，直至动能因摩擦力，能量完全损失至为0，物件停留在某个最终位置（toValue）。
![](https://upload-images.jianshu.io/upload_images/1776769-a3aa5a7fdad7038c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)
换成动画来说，就是在动画时间内，layer某keyPath的fromValue在会在toValue附近振动并最终到达toValue。

使用例子:
```
-(void)springAnimation{
    CASpringAnimation *springAni = [CASpringAnimation animationWithKeyPath:@"position"];
    springAni.damping = 2;
    springAni.stiffness = 50;
    springAni.mass = 1;
    springAni.initialVelocity = 10;
    springAni.toValue = [NSValue valueWithCGPoint:CGPointMake(200, 400)];
    springAni.duration = springAni.settlingDuration;
    [_aniLayer addAnimation:springAni forKey:@"springAnimation"];
}
```
运行效果：
![](https://upload-images.jianshu.io/upload_images/4408163-2b444dda3335ebbb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/226)

##5. CAKeyframeAnimation关键帧动画
关键帧动画，继承自CAPropertyAnimation。关键帧补间插值动画，向其提供多个（keyPath）的value作为关键帧，关键帧之间自动进行补全插值，呈现连贯动画。

与CABasicAnimation的区别是：
CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue），而CAKeyframeAnimation会使用一个NSArray保存这些数值。CAKeyframeAnimation可看作是多段的CABaiscAniamtion的定制合成。CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation。

下面分别使用属性values及path两种的效果；围绕的点视图块进行转动效果；
```
//values方式
-(void)animationValues
{
    if (self.my_View==nil) {
        self.my_View=[[UIView alloc]initWithFrame:CGRectMake(120,350,50,50)];
        self.my_View.backgroundColor=[UIColor redColor];
        [self.view addSubview:self.my_View];
    }
    
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    
    NSValue *value1=[NSValue valueWithCGPoint:CGPointMake(100, 100)];
    NSValue *value2=[NSValue valueWithCGPoint:CGPointMake(200, 100)];
    NSValue *value3=[NSValue valueWithCGPoint:CGPointMake(200, 200)];
    NSValue *value4=[NSValue valueWithCGPoint:CGPointMake(100, 200)];
    NSValue *value5=[NSValue valueWithCGPoint:CGPointMake(100, 100)];
    animation.values=@[value1,value2,value3,value4,value5];
    animation.repeatCount=MAXFLOAT;
    animation.removedOnCompletion = NO;
    animation.fillMode = kCAFillModeForwards;
    animation.duration = 4.0f;
    animation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    animation.delegate=self;
    [self.my_View.layer addAnimation:animation forKey:nil];
}


//path方式
-(void)animationPath
{
    if (self.my_pathView==nil) {
        self.my_pathView=[[UIView alloc]initWithFrame:CGRectMake(120,350,50,50)];
        self.my_pathView.backgroundColor=[UIColor blueColor];
        [self.view addSubview:self.my_pathView];
    }
    
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"position";
    CGMutablePathRef path=CGPathCreateMutable();
    CGPathAddEllipseInRect(path, NULL, CGRectMake(150, 100, 100, 100));
    animation.path=path;
    CGPathRelease(path);
    animation.repeatCount=MAXFLOAT;
    animation.removedOnCompletion = NO;
    animation.fillMode = kCAFillModeForwards;
    animation.duration = 4.0f;
    animation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    animation.delegate=self;
    [self.my_pathView.layer addAnimation:animation forKey:nil];
}
```
更多列子：
使用values和keyTimes：
```
layer.position = (CGPoint){20, 350};

// 关键帧动画
CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];
anim.keyPath = @"position";// 动画类型为位置变化动画
anim.duration = 3.0f;

// keyTime=0.0f，即在keyTime*duration = 0.0秒时刻，layer呈现为position = v1的值
// keyTime=0.2f，即在0.6秒时刻，呈现为v2
// keyTime=1.0f，即在3.0秒时刻，呈现为v3
// 中间的空隙，自动进行补间插值
NSValue *v1 = [NSValue valueWithCGPoint:(CGPoint){20, 350}];
NSValue *v2 = [NSValue valueWithCGPoint:(CGPoint){150, 150}];
NSValue *v3 = [NSValue valueWithCGPoint:(CGPoint){280, 350}];
anim.values = @[v1, v2, v3];
anim.keyTimes = @[@0.0f, @0.2f, @1.0f];// 与values一一对应
```
![](https://upload-images.jianshu.io/upload_images/1776769-f2395edc70412194.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)

使用path，上面的例子等价于：
```
// moveToPoint、addLineToPoint的point（控制点）相当于上面的value
CGMutablePathRef path = CGPathCreateMutable();
CGPathMoveToPoint(path, NULL, 30, 350);
CGPathAddLineToPoint(path, NULL, 160, 150);
CGPathAddLineToPoint(path, NULL, 290, 350);
anim.path = path;// path赋值时自动copy
CGPathRelease(path);// 手动释放内存

// 设置了path值，将会忽略values属性
// anim.values = nil;

[layer addAnimation:anim forKey:nil];
```
使用timingFunctions：
```
anim.keyTimes = @[@0.0f, @0.5f, @1.0f];// 把@0.2f改成@0.5f，更方便观察

// 不同补间插值分段，使用各自的时间函数
// v1到v2段时间函数，慢入快出
CAMediaTimingFunction *v1v2 = [CAMediaTimingFunction functionWithControlPoints:0.62f :0.12f :0.93f :0.17f];
// v2到v3段时间函数，快入慢出
CAMediaTimingFunction *v2v3 = [CAMediaTimingFunction functionWithControlPoints:0.81f :0.12f :0.25f :0.92f];
anim.timingFunctions = @[v1v2, v2v3];// 元素个数应当为keyTimes个数-1，默认为线性
```
![](https://upload-images.jianshu.io/upload_images/1776769-bd75d2849f16261d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)
注意，在前一张图的例子中，并没有设置timeFunctions，它默认为线性。即v1v2、v2v3虽然各段的动画时间不一样，但都是匀速进行的。

rotationMode：
当rotationMode设为nil（默认为nil）时，不发生旋转：
```
// anim.rotationMode = nil;
```
![](https://upload-images.jianshu.io/upload_images/1776769-835726208fefaf39.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)

设为kCAAnimationRotateAuto，旋转至切线方向：
![](https://upload-images.jianshu.io/upload_images/1776769-2567d84fd0e45dd5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)

设为kCAAnimationRotateAutoReverse，切线方向再旋转180度：
![](https://upload-images.jianshu.io/upload_images/1776769-3c25e3b2f22ce390.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)

calculationMode：
 有一个3秒内y坐标值变化动画，并设置calculationMode，加到layer上
```
 CAKeyframeAnimation *yAnim = [CAKeyframeAnimation animation];
yAnim.duration = 3.0f;

yAnim.keyPath = @"position.y";
yAnim.values = @[@350, @120, @200, @160, @350];
yAnim.calculationMode = kCAAnimationLinear;
```
由于此layer动画让layer单纯上下运动，比较难观察calculationMode是如何对动画产生影响的（使y坐标值的变化）
那么再给layer一个随时间变化x坐标匀速增加的辅助动画，同样是3秒
```
CABasicAnimation *xAnim = [CABasicAnimation animation];
xAnim.keyPath = @"position.x";
xAnim.duration = 3.0f;
xAnim.byValue = @290;
```
接下来跟踪layer的运动曲线，观察设置了calculationMode的yAnim的layer的y坐标值的变化:
kCAAnimationLinear（默认）：
![](https://upload-images.jianshu.io/upload_images/1776769-f7b8e7a26839764d.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)
设为kCAAnimationLinear时，并且没有设置timeFunctions，那么默认各段都是匀速补间插值的，可以看出单位时间内y值均匀变化（k=y/x=常数，即线性）

kCAAnimationDiscrete：
![](https://upload-images.jianshu.io/upload_images/1776769-34ca9aa244ac51dc.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)
到某个时间点，y值会跳跃式变化

kCAAnimationPaced：
设为kCAAnimationPaced时，使让keyTimes与timeFunctions属性失效，整个动画都是匀速进行的。这里kCAAnimationLinear的曲线刚好和它一样，只是kCAAnimationLinear如果设置了keyTimes、timeFunctions的话，曲线会有所不同。

kCAAnimationCubic：
![](https://upload-images.jianshu.io/upload_images/1776769-ac1d8cbf095d4b70.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/316)
和kCAAnimationLinear相比，它对y值变化的过渡更加圆滑，比如在y值在变化到第一个最高点v1时，切线的斜率有所减小，变化的速度减缓。

kCAAnimationCubicPaced：
和kCAAnimationCubic相比，加了paced，两者之间关系类似kCAAnimationLinear与kCAAnimationPaced。

tensionValues、continuityValues、biasValues
这几个属性有兴趣的自己可以动手试验一下，观察曲线会有什么不同。

##6. CAAnimationGroup动画组
在我们实际开发中，我们可能需要更加复杂的复合运动，那么需要给图层加多个动画，动画组也就应运而生。

创建动画组也很简单，首先创建单个动画，然后将创建的多个动画添加到动画组，最后将动画组添加图层上就可以啦。不要认为动画组是简单的动画的集合，因为其他动画有的属性很多动画组也有，比如timingFunction，duration，repeatCount等，动画组和动画组的每一个元素都可以单独设置这些属性来实现一个不仅仅是单纯组合这么单纯的效果。

动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。这组动画保存在animations数组中。

默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。

需要注意的是，数组内动画对象的delegate和removedOnCompletion将被忽略，因此设计时应该是设置Group的这两个属性。

例子
```
// 动画1：3秒的大小缩放
CABasicAnimation *anim1 = [CABasicAnimation animation];
anim1.keyPath = @"transform.scale";
anim1.duration = 3.0;
anim1.fromValue = @[@1, @1, @1];
anim1.toValue = @[@0.8, @0.8, @1];// x,y,z轴上的缩放

// 在animationGroup里的动画，以下两个属性设置是不起作用的
anim1.removedOnCompletion = NO;
anim1.delegate = self;

// 动画2：5秒的逐渐透明
CABasicAnimation *anim2 = [CABasicAnimation animation];
anim2.keyPath = @"opacity";
anim2.duration = 5.0f;
anim2.toValue = @0;

// 动画组：10秒的动画组，虽然组内动画在3秒和5秒的时候已经结束了
// 但组是持续10秒的，10秒后才结束
CAAnimationGroup *animGroup = [CAAnimationGroup animation];
animGroup.duration = 10.0f;
animGroup.animations = @[anim1, anim2];
[layer addAnimation:animGroup forKey:@"animGroup"];
```
如果想要layer的状态填充为动画结束时的状态，需要
```
anim1.fillMode = kCAFillModeForwards;
anim2.fillMode = kCAFillModeForwards;
animGroup.fillMode = kCAFillModeForwards;
```
但是Group结束时，Group内的动画仍然后被remove掉，让动画的fillMode效果消失，因此不能让Group被移除
```
animGroup.removedOnCompletion = NO;// Group内的动画设置此属性是无效的，只能通过Group来设置
```

##7. CATransition转场动画
CATransition是CAAnimation的子类，用于做转场动画。它提供的一系列预设的layer的动画,能够为层提供移出屏幕和移入屏幕的动画效果。接着手动改变layer的属性，表现上就完成了过渡转场的实现。转场动画中都包含了一个伪layer和最终呈现layer（手动改变layer属性将影响的layer），分别在下面称为faker和layer。

UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果。

**type**
合法的转场动画类型有：
fade：默认。faker淡出，layer淡入
moveIn：layer移入覆盖faker
push：layer推入，faker推出
reveal：覆盖在layer上面的faker被移出
私有：（被苹果ban了，不建议直接使用）
cube：立方体旋转，layer将会在呈现的面，faker在不可见的面
suckEffect：覆盖在layer上面的faker被抽离
oglFlip：将背面的layer翻转到前面，faker翻转到背面、、
rippleEffect：伴随着水面波动动画，faker淡出，layer淡入
pageCurl：翻到下一页，faker被翻走，呈现layer
pageUnCurl：翻回上一页，layer被翻回并覆盖faker
cameraIrisHollowOpen：下面这两个是特殊的。镜头开，同时呈现部分为透明，而不是layer
cameraIrisHollowClose：类似上面，镜头关
![](https://upload-images.jianshu.io/upload_images/1776769-8f23d59a8394cf98.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/191)

**subtype**
4个子类型，表示上左下右4个转场动画方向：
fromTop
fromLeft
fromBottom
fromRight
![常用的转场动画类型](http://cc.cocimg.com/api/uploads/20170622/1498116888339802.png)

创建转场动画真的很简单：
1.创建转场动画
2.设置转场类型type，以及自类型subtype（也就是转场方向，不是所有的效果都有子类型）及其他属性。
3.设置新的显示效果后，添加动画到图层。

使用例子:
```
//转场动画
-(void)transitionAnimation{
    CATransition *transtion = [CATransition animation];
    transtion.type = @"rippleEffect";
    transtion.subtype = kCATransitionFromLeft;//kCATransitionFromLeft  kCATransitionFromRight
    transtion.duration = 1;
    _transtionIndex++;
    if (_transtionIndex > 4) {
        _transtionIndex = 1;
    }
    _aniLayer.contents = (id)[UIImage imageNamed:[NSString stringWithFormat:@"%@.jpg",@(_transtionIndex)]].CGImage;
    [_aniLayer addAnimation:transtion forKey:@"transtion"];
}
```
运行效果：
![](https://upload-images.jianshu.io/upload_images/4408163-b272ba4eb6d623fd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/226)

##8. CAAction图层行为
动画要分两部分考虑：怎么动？动多久？  即动画行为和动画时间两部分。CoreAnimation中表示行为的有CAAction协议，表示时间的有CAMediaTiming协议，当然CAAnimation都实现了这两个协议。

怎么动： 默认情况下，CALayer的可动画属性都关联到一个行为对象（实现了CAAction）,即当直接修改CALayer的可动画属性时，会执行对应的行为对象。

动多久：CALayer也实现了CAMediaTiming协议，自身可以控制行为时间。在每一次Runloop中，都会创建隐式的事务(CATransaction)，所有CALayer的属性修改都会包含到这个事务中去，而事务中CALayer的行为时间被默认设置为0.25s。所以修改CALayer属性所触发的行为都会执行0.25s。

###8.1 什么是CAAction
Core Animation使用行为对象为图层实现了隐式动画行为。一个行为对象是一个遵循CAAction协议响应行为标识符的对象。所有CAAnimation对象都实现了这个协议。行为标识符使用标准远点分隔的关键路径来命名。当使用一个行为标识符向图层查询对应的行为对象时，图层会返回合适的行为对象，并向它发送 runActionForKey:object:arguments:消息。

CALayer类提供了默认的CAAnimation的行为对象实例，即默认的隐式动画效果。

CALayer行为流程：触发图层行为-->行为标示符-->根据标示符查找行为对象-->执行行为对象(往往是通过协议方法把动作对象自身设置给图层以产生动画效果)

###8.2 自定义适配CAAction协议的动作对象
这部分介绍行为触发器和行为标示符。

为了创建你自己的动作对象，你需要适配CAAction协议并实现runActionForKey：object：arguments：方法。在该方法中利用可用的信息执行任何你想要在图层上的动作。你可能使用该方法给图层添加动画对象或者你可能使用该方法执行另外的任务。

当你定义了一个动作对象，你必须决定动作以何种方式被触发。动作的触发器定义了你用于注册动作的键（行为标识符）。动作对象可在下面的情况下被触发：
1. 图层的某一个属性值被改变。这可以是图层的任何一个属性，不仅仅是可动画的属性（你也可以给添加到图层的自定义属性关联动作）。 识别动作的键是属性名。
2. 图层变成可视或被加入到图层层次中，则识别动作的键为kCAOnOrderIn。
3. 图层从图层层次中被移除或变成不可视，则识别动作的键为kCAOnOrderOut。
4. 图层是即将包含一个变换动画。则识别动作的键为kCATransition。

对于结构体属性比如transform(CATransform3D),也可以通过键路径指定特定的变换行为,比如，为了指定一个围绕图层z轴的旋转因子，你可以指定一个transform.rotation.z的键路径。
![](https://upload-images.jianshu.io/upload_images/4312211-0873394610c2ad23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538)

###8.3 CAAction协议
CAAction协议定义了行为对象如何被调用。实现CAAction协议的类包含一个方法runActionForKey:object:arguments:。
当行为对象收到一个runActionForKey:object:arguments:的消息时，行为标识符、行为发生所在的图层、额外的参数字典会被作为参数传递给方法。
通常行为对象是CAAnimation的子类实例，它实现了CAAction协议。然而你也可以返回任何实现了CAAction协议的类对象。当实例收runActionForKey:object:arguments:的消息时，它需要执行相应的行为。
当CAAnimation实例受到消息runActionForKey:object:arguments:的时候，它把自己添加到图层的动力里面，触发动画的执行:
```
- (void)runActionForKey:(NSString *)key
                 object:(id)anObject
              arguments:(NSDictionary *)dict
{
     [(CALayer *)anObject addAnimation:self forKey:key];
}
```

###8.4 动作对象设置给图层才产生效果
这部分包括了动作对象查找顺序以及隐式动画的重载。

在动作被执行之前，图层需要找到一个相应的动作对象。与图层相关的动作的键可以是被更改的属性名或一个特殊的识别动作的字符串。当一个适当的事件发生在图层上，图层调用它的actionForKey：方法搜索与键关联的动作对象。你的应用可以介入到搜索期间的几个关键点，并提供一个与键相关的动作对象。

Core Animation以下面的顺序搜索动作对象：

1.如果图层有一个代理，并且代理实现了actionForLayer：forKey：方法，图层调用该方法。代理必须完成下面所述操作之一：
. 返回给定的键指定的动作对象
. 如果代理不处理动作则返回nil，而搜索操作将继续。
. 返回NSNull对象，这将引起搜索操作立即结束。
2.图层的 actions 字典被搜索以便找到一个和行为标识符对应的对象。
3.图层的 style 属性被搜索以便找到一个包含行为标识符的actions字典。（换句话说，style字典包含一个actions键，它的值也是字典。图层在这个字典中搜索给定的键对应的对象。）
4.图层调用它的defaultActionForKey：类方法。它将会返回一个和标识符对应的行为对象，如果不存在的话则返回 nil。
5.图层执行由Core Animation定义的隐式动作（如果有）。

如果你在任何一个适当的搜索点提供了一个动作对象，图层将停止它的搜索并执行返回的动作对象。当它找到了一个动作对象，图层调用对象的runActionForKey：object：arguments：方法执行动作。如果你为一个给定的键定义的动作是一个CAAnimation类实例，你可以使用默认的方法实现执行动画。如果你自己定义了服从CAAction协议的对象，你必须使用你的对象的方法实现做任何适当的动作。

在哪里设置动作对象依赖于你打算如何更改图层:

对于只应用在指定环境的动作，或对于已经使用代理对象的图层，提供一个代理并实现它的actionForLayer：forKey：方法。

对于不使用代理的图层对象，添加动作到图层的actions字典。

与定义在图层对象上的自定义属性相关的动作，应被包含在图层的style字典内。

对于那些对于图层行为是必要的动作，子类化图层并覆盖defaultActionForKey：方法。

下面的例子显示了一个用于给定动作对象的代理方法实现。在这种情况下，代理搜索图层contents属性的改变并将新内容转换为使用一个变换动画的位置。
```
- (id<CAAction>)actionForLayer:(CALayer *)theLayer

                        forKey:(NSString *)theKey {

    CATransition *theAnimation=nil;

    if ([theKey isEqualToString:@"contents"]) {

        theAnimation = [[CATransition alloc] init];

        theAnimation.duration = 1.0;

        theAnimation.timingFunction = [CAMediaTimingFunction

functionWithName:kCAMediaTimingFunctionEaseIn];

        theAnimation.type = kCATransitionPush;

        theAnimation.subtype = kCATransitionFromRight;

}

 

    return theAnimation;

}

```
###8.5 UIView对CALayer动画的控制
既然UIView就是CALayer的delegate，那么actionForLayer:forKey:方法就是由UIView来实现的。所以UIView可以相当灵活的控制动画的产生。

当我们对UIView的一个属性赋值的时候，它只是简单的调用了它持有的那个CALayer的对应的属性的setter方法而已，根据上面的可动画属性的特点，CALayer会让它的delegate（也就是这个UIView）调用actionForLayer:forKey:方法。实际上结果大家都应该能想得到：在UIView的动画block外面，UIView的这个方法将返回NSNull，而在block里面，UIView将返回一个正确的CAAction对象（这里将不深究UIView是如何判断此时setter的调用是在动画block外面还是里面的）。

UIView将CAAction返回给layer后，layer使用这个对象生成了一个CABasicAnimation对象并添加到自身上。

动画结束后，CAAnimation将回调它delegate的animationDidStop方法。我们发现这个delegate又是一个私有类，因为我们在调用UIView动画的时候设置了completionBlock，也就是动画结束后要调用的block，所以UIView会将这个私有delegate的信息放进CAAction对象中告知CALayer动画结束后我要干事情（调用这个block）。

注意：如果block里的动画属性修改与外部相比没有变化，则不会生成动画对象，completionBlock会直接被调用。在block里执行异步的属性修改，也不会生成动画对象，completionBlock也会直接被调用。

###8.6 使用CATransaction类临时禁用动作
你可以使用CATransaction类临时禁用图层的动作。当你改变了一个图层的属性，Core Animation通常会为动画属性的改变创建一个隐式事务对象。如果你不想以动画的形式展现变化，你可以通过创建一个显示事务并设置它的kCATransactionDisableActions属性为True禁用隐式动画。清单6-2的代码片段 显示了将指定的图层从图层数中移除时禁用动画。
```
[CATransaction begin];

  [CATransaction setValue:(id)kCFBooleanFalse

                   forKey:kCATransactionDisableActions];

  [aLayer removeFromSuperlayer];

[CATransaction commit];

```

##9. CATransaction图层事务
###9.1 CATransaction是什么
CATransaction是 Core Animation 中的事务类，在iOS中的图层中，图层的每个改变都是事务的一部分，CATransaction可以对多个layer的属性同时进行修改，同时负责成批的把多个图层树的修改作为一个原子更新到渲染树。

简单来说事务是核心动画里面的一个基本的单元，动画的产生必然伴随着layer的Animatable属性的变化，而layer属性的变化必须属于某一个事务。因此，核心动画依赖事务。
```
/* CoreAnimation - CATransaction.h

   Copyright (c) 2006-2016, Apple Inc.
   All rights reserved. */`

/* Transactions are CoreAnimation's mechanism for batching multiple layer-
 * tree operations into atomic updates to the render tree. Every
 * modification to the layer tree requires a transaction to be part of.
 *
 * CoreAnimation supports two kinds of transactions, "explicit" transactions
 * and "implicit" transactions.
 *
 * Explicit transactions are where the programmer calls `[CATransaction
 * begin]' before modifying the layer tree, and `[CATransaction commit]'
 * afterwards.
 *
 * Implicit transactions are created automatically by CoreAnimation when the
 * layer tree is modified by a thread without an active transaction.
 * They are committed automatically when the thread's run-loop next
 * iterates. In some circumstances (i.e. no run-loop, or the run-loop
 * is blocked) it may be necessary to use explicit transactions to get
 * timely render tree updates. */

@available(iOS 2.0, *)
open class CATransaction : NSObject
```

###9.2 隐式事务和显式事务
CATransaction事务类分为隐式事务和显式事务，注意以下两组概念的区分：
1.隐式动画和隐式事务:
隐式动画通过隐式事务实现动画。
2.显式动画和显式事务:
显式动画有多种实现方式，显式事务是一种实现显式动画的方式。

**隐式事务**
隐式事务是没有主动调用事务的方法，由系统自动生成事务。
除显式事务外,任何对于CALayer属性的修改,都是隐式事务.这样的事务会在run-loop中被提交.
当图层树被没有获得事务的线程修改的时候将会自动创建隐式事务,当线程的运行循环(run-loop)执行下次迭代的时候将会自动提交事务。但是,当在一个没有运行循环(runloop)的线程修改图层的属性时,你必须使用显式事务。以下皆是隐式事务。
```
override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
        
        layer = CALayer()
        layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100)
        layer.position = CGPoint.init(x: 150, y: 100)
        layer.backgroundColor = UIColor.red.cgColor
        layer.borderColor = UIColor.black.cgColor
        layer.opacity = 1.0
        self.view.layer.addSublayer(layer)
    }
```
可以通过下面的方法查看动画的效果，前提是让动画效果出来：
```
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
        
        // 设置变化动画过程是否显示，默认为true不显示
        CATransaction.setDisableActions(false)
        // 设置圆角
        layer.cornerRadius = (layer.cornerRadius == 0.0) ? 30.0 : 0.0
        // 设置透明度
        layer.opacity = (layer.opacity == 1.0) ? 0.5 : 1.0
    }
```
**显式事务**
在你修改图层树之前,可以通过给 CATransaction 类发送一个begin 消息来创建一个显式事务,修改完成之后发送 commit消息。显式事务在同时设置多个图层的属性的时候(例如当布局多个图层的时候),暂时的禁用图层的行为,或者暂时修改动画的时间的时候非常有用 。
```
override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
        
        // 开启事务
        CATransaction.begin()
        
        // 显式事务默认开启动画效果,kCFBooleanTrue关闭
        CATransaction.setValue(kCFBooleanFalse, forKey: kCATransactionDisableActions)
        
        // 动画执行时间
        CATransaction.setValue(5.0, forKey: kCATransactionAnimationDuration)
        
        layer.cornerRadius = (layer.cornerRadius == 0.0) ? 30.0 : 0.0
        
        layer.opacity = (layer.opacity == 1.0) ? 0.5 : 1.0
        // 提交事务
        CATransaction.commit()
    }
```
事务的可设置属性（会覆盖隐式动画的设置）：
```
animationDuration：动画时间
animationTimingFunction：动画时间曲线
disableActions：是否关闭动画
completionBlock：动画执行完毕的回调
```
事务支持嵌套使用：当最外层的事务commit后动画才会开始。


###9.3 完成块
UIView中常用的使用闭包来处理动画的方式，而且还有有一个 completion 的闭包来表示动画已经执行结束（完成块）。
CATranscation提供的+setCompletionlock:方法来实现在动画结束时添加一个完成的动作，类似UIView的block。
使用例子:
```
@IBAction func changeBtnClick(_ sender: UIButton) {
        //开始事务
        CATransaction.begin()
        defer {
            //提交事务
            CATransaction.commit()
        }
        CATransaction.setAnimationDuration(1.0)
        CATransaction.setCompletionBlock { 
            var transform = self.colorLayer.affineTransform()
            transform = transform.rotated(by: CGFloat(M_PI_2))
            self.colorLayer.setAffineTransform(transform)
        }
        let red = CGFloat(arc4random() % 256) / 255.0
        let green = CGFloat(arc4random() % 256) / 255.0
        let blue = CGFloat(arc4random() % 256) / 255.0
        colorLayer.backgroundColor = UIColor(red: red, green: green, blue: blue, alpha: 1.0).cgColor
    }
```


##10. 其他动画
###10.1 UIViewAnimation
可设置的动画属性：
```
1. frame            //大小变化：改变视图框架（frame）和边界。
2. bounds           //拉伸变化：改变视图内容的延展区域。
3. center           //居中显示
4. transform        //旋转：即任何应用到视图上的仿射变换（transform）
5. alpha            //改变透明度：改变视图的alpha值。
6. backgroundColor  //改变背景颜色
7. contentStretch   //拉伸内容
```
可设置的动画参数：
```
1. duration   //为动画持续的时间。 
2. animations //为动画效果的代码块。
3. completion //为动画执行完毕以后执行的代码块
4. options    //为动画执行的选项
5. delay      //为动画开始执行前等待的时间
```
UIView的动画通过分类实现，由三部分组成：
1.UIView(UIViewAnimation)
```
UIView(UIViewAnimation);
 设置动画ID 方便查询
 + (void)beginAnimations:(nullable NSString *)animationID context:(nullable void *)context;
 提交动画 执行动画
 + (void)commitAnimations;
 设置动画执行时间
 + (void)setAnimationDuration:(NSTimeInterval)duration;
 设置动画执延迟执行时间
 + (void)setAnimationDelay:(NSTimeInterval)delay;
 设置动画代理对象，当动画开始或者结束时会发消息给代理对象
 + (void)setAnimationDelegate:(nullable id)delegate;
 设置动画开始时调用的方法 执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector
 + (void)setAnimationWillStartSelector:(nullable SEL)selector;
 设置动画结束时调用的方法 执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector
 + (void)setAnimationDidStopSelector:(nullable SEL)selector;
 设置动画的开始时间，默认为now
 + (void)setAnimationStartDate:(NSDate *)startDate
 设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好
 + (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache
 设置是否自动恢复执行 YES,代表动画每次重复执行的效果会跟上一次相反
 + (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses
 设置动画的重复次数
 + (void)setAnimationRepeatCount:(float)repeatCount
 设置动画执行效果
 + (void)setAnimationCurve:(UIViewAnimationCurve)curve
 设置动画是否生效
 + (void)setAnimationsEnabled:(BOOL)enabled; 
```
构建动画：
```
self.animationImageView.frame = CGRectMake(0, 132, 56, 36);
[UIView beginAnimations:@"btnOne" context:nil];
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
[UIView setAnimationDelegate:self];
[UIView setAnimationDuration:1.0];
[UIView setAnimationDelay:0.0];
[UIView setAnimationRepeatCount:1];
[UIView setAnimationRepeatAutoreverses:YES];
[UIView setAnimationDidStopSelector:@selector(AnimationDidStop)];
[UIView setAnimationWillStartSelector:@selector(AnimationWillBegin)];
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.animationImageView cache:YES];

self.animationImageView.frame = CGRectMake(SCREEN_WIDTH - 56, 132, 56, 36);
[UIView commitAnimations];
```
2.UIView(UIViewAnimationWithBlocks)
将动画实现封装在block区域，参数构建在类方法上。
```
可选动画执行效果，如进出效果等
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);

带回调block动画，动画执行完成后进入block
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0

不带回调动画
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0, completion = NULL

弹簧动画
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

view的转场动画
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);

view到另一个view的转场动画
+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // toView added to fromView.superview, fromView removed from its superview

+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray<__kindof UIView *> *)views options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))parallelAnimations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);
```
构建动画
```
[UIView animateWithDuration:1.0 delay:0.0 usingSpringWithDamping:5.0 initialSpringVelocity:0 options:UIViewAnimationOptionAutoreverse animations:^{

    self.animationImageView.frame = CGRectMake(SCREEN_WIDTH - 56, 132, 56, 36);

} completion:^(BOOL finished) {
    self.animationImageView.frame = CGRectMake(0, 132, 56, 36);
}];
```
3.UIView (UIViewKeyframeAnimations)
只能构建属性动画，不能构建path动画。
```
关键帧动画
+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

在上面的block中添加关键帧
+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations NS_AVAILABLE_IOS(7_0); // start time and duration are values between 0.0 and 1.0 specifying time and duration relative to the overall time of the keyframe animation
```
构建动画
```
[UIView animateKeyframesWithDuration:2.0 delay:0.0 options:UIViewKeyframeAnimationOptionAutoreverse animations:^{

    [UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:0.5 animations:^{

        self.animationImageView.frame = CGRectMake(200, 132, 56, 36);
    }];

    [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.5 animations:^{

        self.animationImageView.frame = CGRectMake(200, 232, 56, 36);
    }];

} completion:^(BOOL finished) {
    self.animationImageView.frame = CGRectMake(0, 132, 56, 36);
}];
```

UIView中的动画与图层的动画关系

 （1）UIView有两个方法，`+beginAnimations:context:`和`+commitAnimations`，实现动画效果；实际上在`+beginAnimations:context:`和`+commitAnimations`之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因。 
 
 （2）UIView中基于block的动画方法：`+animateWithDuration:animations:`。这样写对做一堆的属性动画在语法上会更加简单，但实质上在`+animateWithDuration:animations:`内部调用了CATransaction的`+begin`和`+commit`方法，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对+begin和+commit匹配的失误造成的风险。 

###10.2 控制器转场动画
###10.3 UIDynamic
###10.4 基于定时器的动画
####10.4.1 NSTimer动画
####10.4.2 CADisplayLink逐帧动画
###10.5 UIViewPropertyAnimator

##11. 提升动画性能
Core Animation是提升based-app动画帧率的最佳方式 ，但使用Core Animation并不保证性能一定会得到提升。特别是在OS X中，你仍必须选择最有效的方式使用Core Animation的行为。跟所有和性能相关的问题一样，随着时间的推移，你应该使用Instruments测量和追踪你的应用的性能性能正在提升而不是在退化。

常规的技巧和窍门

有很多种方法可以让你的层运行的更加有效率（因为层是核心动画的基础）。就像任何优化一样，你应该先在优化前审查下现在的代码让动画表现如何，这个是基准，然后才能对比出优化有没有效果，效率是不是更高了

**尽可能使用不透明图层**

设置opaque属性为YES可以让核心动画知道不需要给图层维持alpha通道，没有alpha通道意味着就不需要渲染这层的背景内容了，从而节省了渲染时间。然后这个属性主要是用于设置层或者以层为基础的视图的，也或者是用于核心动画创造的底层bitmap层的情况。如果把一张图像直接设置为层的contents属性，那么这个图像的alpha通道会被强制保留，无论你设不设定这个值。

**将复杂路径拆分成简单路径**

CAShapeLayer类根据你提供的路径来渲染到bitmap图像，在合成的时候渲染成内容。这么做的优点是层总是在最佳分辨率绘制路径，但是这个优点会消耗额外的渲染时间。如果这个路径太复杂,渲染的代价就会很高，并且如果这个路径的尺寸经常改变（这会导致重绘也经常发生），用于绘画的时间也会增加，这会成为一个阻止最佳表现性能的瓶颈

有一个办法去降低绘制形状层的时间，就是把复杂的形状分拆成简单的形状。用更简单的路径和多层用于CAShapeLayer对象，这比绘制一个大的复杂路径时间快得多。因为绘制操作发生在CPU，合成工作发生在GPU，当然这种优化也取决于你的内容。因此，优化前以现有效果为基准很重要。

**显式为相同的图层设置contents属性**

如果你在多个层对象上使用同一张图片，自己加载图像，把这个图像直接分派给这些层对象的contents属性。分配一个图像到contents属性可以预防分配用于内容储备的内存空间（UIView实际并不将自己绘制到屏幕上，而是先绘制到它的图层上，然后是图层显示在屏幕上，视图并不会频繁的重绘；相反，它的绘图结果会被缓存起来，而绘图的缓存版本（后备存储）将被用到适当的地方）。反而这个层用你提供的图像当做后备存储。当几个层用同样的图片，那么这些层就在共享一份内存而不是为自己再分配一个图片拷贝。

**总是将图层的尺寸设置为整数值**

为了最好的效果，应该将层对象的宽和高设置为整数值，虽然你使用浮点数的形式设定图层边界的宽高，图层的边界最终用于创建一个bitmap图片。指定图层的宽高为整型值会简化Core Animation必要的创建和管理备份存储与其他图层信息的工作。

**如果需要，可以使用异步的方式渲染图层**

任何在代理方法drawLayer:inContext或视图的drawRect：方法中的绘制操作都默认是和主线程是同步的，在某种情况下，同步的绘制你的内容可能不会有最好的效果和表现。如果注意到动画执行的不好，可能就得试试drawsAsynchronously这个层的属性（iOS 6引入），让这些操作在后台线程中工作。如果你这么做了，得确定绘制代码是线程安全的，而且理所应当你应该在将异步绘图的代码置入你的产品代码之前总是测试异步绘图的性能。

**当给图层添加一个阴影指定一个阴影路径**
让Core Animation自己决定阴影的形状是个大的开销且影响app的表现。相比让它自己决定，应该用shadowPath属性明确地指定一个阴影形状。当你这么干的时候，核心动画用这个形状去绘制和缓存阴影特效。对那些从不改变或者很少改变形状的层，这是一个很好的效果提升通过减少渲染数量。




##参考
>iOS Core Animation手册：没人比我更全https://www.jianshu.com/p/bd041182ae2d
>CABasicAnimation动画和keypath说明https://www.jianshu.com/p/83f7e4e3ceb0
>https://www.cnblogs.com/monicaios/p/3521575.html
>Core Animation系列之CATransaction https://www.jianshu.com/p/9f0667c883f8
>iOS动画篇_CoreAnimation(超详细解析核心动画)https://www.jianshu.com/p/51483b560244
>质量监控-隐式动画的性能瓶颈http://sindrilin.com/2017/12/14/bottleeneck_of_transacation.html
> Core Animation编程指南 https://www.cnblogs.com/xdream86/p/3250782.html
> iOS动画原理--隐式动画 https://www.jianshu.com/p/90415eb764bf
> http://www.360doc.com/content/15/0210/11/19175681_447649001.shtml
> Core Animation编程指南
> https://www.cnblogs.com/xdream86/p/3250782.html
> https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html#//apple_ref/doc/uid/TP40004514-CH7-SW1
> https://legacy.gitbook.com/book/zsisme/ios-/details
> 交互式动画(下)：UIViewPropertyAnimator in iOS 10 https://www.jianshu.com/p/6ac70183631e
> 交互式动画(上)：iOS 10 以下的实现https://www.jianshu.com/p/bbbdff8f01c5