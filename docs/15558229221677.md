第二章 简单的HTTP协议

[TOC]

##2.1 HTTP协议用于客户端和服务端之间的通信
两台计算机之间使用HTTP协议通信时，必定一端是客户端，另一端是服务端。两台计算机的角色可能会发生互换，但仅从一条通信路线上来说，角色是固定的。HTTP协议能明确区分哪个是客户端，哪个是服务端。

##2.2 通过请求和响应的交换达成通信
HTTP协议规定请求从客户端发出，服务端响应该请求并返回。通信是从客户端开始建立的，服务端在没有接收到请求前不会发送响应。

请求报文和响应报文的组成见后文。

##2.3 HTTP是不保存状态的通信
HTTP协议本身不会保存请求和响应，不保存状态，是无状态协议。为了实现保持状态功能，引入了Cookie技术。

##2.4 请求URI定位资源
客户端请求访问资源而发送请求时，URI需要作为请求报文中的请求URI包含在内。URI可以是完整的请求URI。也可以在首部字段写明Host的情况下，使用相对URI。如果不是访问特定资源，而是对服务器本身发起请求，可以用*来代替请求URI。例如OPTIONS * HTTP/1.1可查询服务端支持的HTTP方法种类。

##2.5 告知服务器意图的HTTP方法
GET：获取资源。请求的是文本资源，就原样返回。如果是CGI那样的程序，则返回经过执行后的输出结果。
```
请求
GET /index.html HTTP/1.1
Host:www.hack.com
If-Modified-Since:Thu,12 jul 2012 07:00:00 GMT
响应
仅返回2012年7月12日7点以后经过更新的index.html页面资源。如果未更新，则以状态码304 Not Modified作为响应返回。
```
POST：传输实体主体，和GET相似，但主要目的并不是获取响应的主体内容。

PUT:传输文件，不带验证机制，任何人都可以上传文件，存在安全性问题。需要配合Web应用的验证机制或者REST标准的web网站。
响应204 No Content表示文件已存在于服务器上

HEAD:获得报文首部，不返回报文主体，用于确认URI的有效性和资源更新日期。

DELETE：删除文件，不带验证机制，任何人都可以上传文件，存在安全性问题。需要配合Web应用的验证机制或者REST标准的web网站。
响应204 No Content表示文件已从该服务器上删除

OPTIONS：询问对请求URI指定的资源支持的方法。
响应Allow：GET,POST,HEAD,OPTIONS

TRACE:让web服务器将之前的请求通信环回给客户端。发送请求时在Max-Forwards首部字段中填入数值，每经过一个服务端就将该数值减1，当数值为0时，停止继续传输，最后接收到请求的服务端则返回状态码200 OK的响应。
客户端通过TRACE方法查询发出去的请求是如何被修改的。因为请求可能会被途经的代理中转，可能会被修改。
TRACE容易引发XST跨站追踪攻击，通常不用。

CONNECT：要求用隧道协议连接代理。要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。
CONNECT 代理服务器名:端口号 HTTP版本

LINK、UNLINK:HTTP/1.1中已废弃

##2.6 使用方法下达命令
向情求URI指定的资源发送请求报文时，采用称为方法的命令。方法的作用在于，可以指定请求的资源按期望产生某种行为。

##2.7 持久连接增加通信量
HTTP协议初始版本中，每进行一次HTTP通信就要断开一次TCP连接。
使用浏览器浏览一个包含多图的HTML网页时，在发送请求访问的HTML页面资源同时，也会请求该页面包含的其他资源。因此，每次的请求都会造成无谓的TCP连接和断开，增加通信量。

###2.7.1 持久连接
为解决上述问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接（HTTP Persistent Connections，或HTTP keep-alive或HTTP Connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，就保持TCP连接状态。
持久连接减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，提高了web页面的显示速度。
HTTP/1.1中所有连接默认都是持久连接。1，0内并未标准化，此外客户端也需要支持持久连接。

###2.7.2 管线化
持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需要等待并收到响应后，才能发送下一个请求。管线化技术出现后，不用等待响应就可以直接发送下个请求。这样就能同时并行发送多个请求。

##2.8 使用Cookie的状态管理
HTTP协议是无状态的，不对之前发送过的请求和响应的状态进行管理。
Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。
Cookie会根据从服务端发送的响应报文内的一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie。下次客户端再往该服务端发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。
服务端发现客户端发送来的Cookie后，然后对比服务器上的记录，确定是哪个用户及其之前的状态信息。
1.请求报文（无cookie）
2.响应报文（服务端生成cookie）
Set-Cookie:sid=xxxx;path=/;expires=xxxx
3.请求报文(自动发送保存着的cookie信息)
Cookie:sid=xxxxx