第二章 简单的HTTP协议

[TOC]

##2.1 HTTP协议用于客户端和服务端之间的通信
两台计算机之间使用HTTP协议通信时，必定一端是客户端，另一端是服务端。两台计算机的角色可能会发生互换，但仅从一条通信路线上来说，角色是固定的。HTTP协议能明确区分哪个是客户端，哪个是服务端。

##2.2 通过请求和响应的交换达成通信
HTTP协议规定请求从客户端发出，服务端响应该请求并返回。通信是从客户端开始建立的，服务端在没有接收到请求前不会发送响应。

请求报文和响应报文的组成见后文。

##2.3 HTTP是不保存状态的通信
HTTP协议本身不会保存请求和响应，不保存状态，是无状态协议。为了实现保持状态功能，引入了Cookie技术。

##2.4 请求URI定位资源
客户端请求访问资源而发送请求时，URI需要作为请求报文中的请求URI包含在内。URI可以是完整的请求URI。也可以在首部字段写明Host的情况下，使用相对URI。如果不是访问特定资源，而是对服务器本身发起请求，可以用*来代替请求URI。例如OPTIONS * HTTP/1.1可查询服务端支持的HTTP方法种类。

##2.5 告知服务器意图的HTTP方法
GET：获取资源。请求的是文本资源，就原样返回。如果是CGI那样的程序，则返回经过执行后的输出结果。
```
请求
GET /index.html HTTP/1.1
Host:www.hack.com
If-Modified-Since:Thu,12 jul 2012 07:00:00 GMT
响应
仅返回2012年7月12日7点以后经过更新的index.html页面资源。如果未更新，则以状态码304 Not Modified作为响应返回。
```
POST：传输实体主体，和GET相似，但主要目的并不是获取响应的主体内容。

PUT:传输文件，不带验证机制，任何人都可以上传文件，存在安全性问题。需要配合Web应用的验证机制或者REST标准的web网站。
响应204 No Content表示文件已存在于服务器上

HEAD:获得报文首部，不返回报文主体，用于确认URI的有效性和资源更新日期。

DELETE：删除文件，不带验证机制，任何人都可以上传文件，存在安全性问题。需要配合Web应用的验证机制或者REST标准的web网站。
响应204 No Content表示文件已从该服务器上删除

OPTIONS：询问对请求URI指定的资源支持的方法。
响应Allow：GET,POST,HEAD,OPTIONS

TRACE:让web服务器将之前的请求通信环回给客户端。发送请求时在Max-Forwards首部字段中填入数值，每经过一个服务端就将该数值减1，当数值为0时，停止继续传输，最后接收到请求的服务端则返回状态码200 OK的响应。
客户端通过TRACE方法查询发出去的请求是如何被修改的。因为请求可能会被途经的代理中转，可能会被修改。
TRACE容易引发XST跨站追踪攻击，通常不用。

CONNECT：要求用隧道协议连接代理。要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。
CONNECT 代理服务器名:端口号 HTTP版本

LINK、UNLINK:HTTP/1.1中已废弃

##2.6 使用方法下达命令
向情求URI指定的资源发送请求报文时，采用称为方法的命令。方法的作用在于，可以指定请求的资源按期望产生某种行为。

##2.7 持久连接增加通信量
HTTP协议初始版本中，每进行一次HTTP通信就要断开一次TCP连接。
使用浏览器浏览一个包含多图的HTML网页时，在发送请求访问的HTML页面资源同时，也会请求该页面包含的其他资源。因此，每次的请求都会造成无谓的TCP连接和断开，增加通信量。

###2.7.1 持久连接
为解决上述问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接（HTTP Persistent Connections，或HTTP keep-alive或HTTP Connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，就保持TCP连接状态。
持久连接减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，提高了web页面的显示速度。
HTTP/1.1中所有连接默认都是持久连接。1，0内并未标准化，此外客户端也需要支持持久连接。

###2.7.2 管线化
持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需要等待并收到响应后，才能发送下一个请求。管线化技术出现后，不用等待响应就可以直接发送下个请求。这样就能同时并行发送多个请求。

##2.8 使用Cookie的状态管理
HTTP协议是无状态的，不对之前发送过的请求和响应的状态进行管理。
Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。
Cookie会根据从服务端发送的响应报文内的一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie。下次客户端再往该服务端发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。
服务端发现客户端发送来的Cookie后，然后对比服务器上的记录，确定是哪个用户及其之前的状态信息。
1.请求报文（无cookie）
2.响应报文（服务端生成cookie）
Set-Cookie:sid=xxxx;path=/;expires=xxxx
3.请求报文(自动发送保存着的cookie信息)
Cookie:sid=xxxxx

##拓展
###不同版本的HTTP
####HTTP/0.9
当时网络资源匮乏，0.9版本相对简单，采用纯文本格式，且设置为只读，所以当时只能使用"Get"的方式从服务器获得HTML文档，响应以后则关闭。如下图所示
```
GET /Mysite.html
```
响应中只包含了文档本身。响应内容无响应头，无错误码，无状态码，可以说是"裸奔"。
```
<HTML>
Hello world
</HTML>
HTTP/1.0
```
此时HTTP/0.9请求过程如下
* 应用层的HTTP建立在传输层的TCP之上并运用TCP可靠性等特性，先三次握手建立连接
* 客户端请求建立连接(此时只有GET)
* 服务端响应请求，数据以 ASCII 字符流返回给客戶端
* 传输完成，断开连接。

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OZHNkb3Vad2ljYWN1Z1BnUHV4Q2dMVVRmOUVyTTB4cGFoNFNDY0J4NmRLaFhTY2NKYVI0VW1qeG96M0ZTaktubjNaUmhVaWJIdmlhV2NncXg5ckRwWlNWQS82NDA?x-oss-process=image/format,png)

####HTTP1.0

随着时代的进步，仅仅文本的传输无法满足需求，更多情况需要采用图文的方式才能生动的表达出自己的观点。随着1995年开发出Apache，同时其他的多媒体等技术发展迅速，从而进一步的促使HTTP新功能的出现。HTTP1.0在1996年诞生，增加了一下几个方面：
* 之前只有Get方法，现在增加Post(加参数)，Head方法
* 加入协议版本号，同时添加文件处理类型
* 加入HTTP Header，让HTTP处理请求更加灵活
* 增加响应状态码，标记出错的原因
* 提供国际化(不同语言)支持

典型的请求过程
```
GET /image.html HTTP/1.0
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
 
200 OK
Date: Tue, 17 Nov 2020 09:15:31 GMT
Content-Type: text/html
<HTML> 
一个包含图片的页面
  <IMG SRC="/image.gif">
</HTML>
```
HTTP1.0通信过程
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OZHNkb3Vad2ljYWN1Z1BnUHV4Q2dMVVRmOUVyTTB4cGE5bWdwU0tVV1NRaWFHaWNDeVN1WXpkV25KdkNreTU1dGtXaWJLaWN0bXQ4ZjkzTUNtM0Z2VG1jVU9BLzY0MA?x-oss-process=image/format,png)

####HTTP /1.1

1995年是不平凡的一年，网景公司和微软开启浏览器大战，谁都想当老大。1999年HTTP/1.1发布并成为标准，写入RFC，以为以后不管是网关还是APP等，只要你要使用HTTP，就得遵守这个标准。
* 继续增加了PUT等方法
* 允许持久连接
* 强制要求Host头

随着文件越来越大，图片等信息越来越复杂，如果每一次上传下载文件都需要建立连接断开连接的过程将增加大量的开销。为此，提出了持久连接，也就是一次TCP连接可以具有多个HTTP请求。当然持久连接是可选择的，如果考虑关闭，只需要使用Connecttion:close关闭即可。长连接如下图所示
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OZHNkb3Vad2ljYWN1Z1BnUHV4Q2dMVVRmOUVyTTB4cGFJV0kycmljRFlLTzBEN0RHT2hwZ0MzSVpLdk1GNGpGemliMVFieUljVVFocU90a3lNYmYwMHNVUS82NDA?x-oss-process=image/format,png)

我们知道，在电商系统中，经常会因为促销活动导致流量飙升，为了缓解流量，其中有种方法即加缓存或者加服务器。如果是单台服务器负载过大，数据库可能分库分表。数据结构算法中分而治之方法亦是如此。那么HTTP中，同样的道理，如果文件太大，就大文件切分为小文件块发送。

####HTTP/2
HTTP/1.1的出现，几年间出来大量牛掰的互联网公司，发展实在是太快，但是HTTP1.1中这几点成为诟病。

* 原因1 TCP自带慢启动

顾名思义，"慢启动"从0到1循循渐进。轿车启动不会按下按钮就直接起飞，而是缓慢调节到适合的速度。这不是挺好的？为什么会带来性能问题呢。我们知道一个页面有静态数据，动态页面，很多小文件在加载的过程中就会直接发起请求，这样导致太多的请求都会经历慢启动过程，花费时间太多。

* 原因2 多条TCP连接带宽竞争

带宽固定，多条TCP连接同时发起竞争带宽资源，由于各个TCP连接之间没有通信机制，也无法得知哪些资源优先级更高，从而导致想快速下载的资源反而延迟下载。

* 原因3 头部阻塞

阻塞，在网络编程中，我们采用异步，多路复用(epoll)方式尽量让cpu少等待多干事。在HTTP1.1中，虽然大家共用了一条TCP通道，但是第一个请求没有结束，第二请求就可能阻塞等待，也就是说不能同时发送接收数据。那么一个网页很多数据文件，如果能够同时发出请求，让部分数据文件能够得到响应并预处理，这样就大大的利用了带宽和cpu的资源。基于这些因素，在HTTP2中出现了新的方案。

如何解决头部阻塞呢？

HTTP是一问一答的模式，大家都在这个队列排队导致堵塞，那就多个队列并发进行，也就是"对同一个域名发起多个长连接"。举个例子，在火车站排队买票的时候，如果只有一个窗口可用，大家只能苦等，多开几个窗口就可缓解这个问题。

这个时候用户数 * 并发数(上限6-8)已经不错得效果，但是互联网速度太快，火车站就这么大，窗口也就这么多，怎么办，建新的火车站进行分流(大部分城市都有什么东站 西站)。在这里叫做"域名分片"，使用多个域名，这些域名指向同一服务器。

####HTTP/3

HTTP/2看似很完美了吧，但是Google轮子哥可不服，其他人在研究HTTP/2的时候，它们就在琢磨QUIC。那QUIC有啥牛掰的地方呢。
>QUIC是Google开发的一个基于UDP且能像TCP一样具有可靠性特点的协议。具备像HTTP/2一样的应用数据二进制分帧传输。其主要解决的问题有两个。

* 进一步解决线头阻塞问题。通过独立不同流，让各个流之间实现相互独立传输，互不干扰

* 切换网络时的连接保持。wifi和3G/4G经常需要来回切换。基于TCP的协议，会因为网络的切换导致IP地址的改变。而基于UDP的QUIC协议，及时切换也可以恢复之前与服务器的连接。(这里推荐大家可以去看看MPTCP)

 
