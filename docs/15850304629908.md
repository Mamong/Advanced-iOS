Runtime的加载过程（四）_read_images

[TOC]

本章我们将介绍_read_images的实现细节。

##背景
Mach-O 运行的时候，通过dylb加载到内存，须进一步提取出详细的信息，进而使用Mach-O中的类、方法。dylb加载完Mach-O文件后，通知runtime，调用_read_images ，_read_images就是将Mach-O文件中的DATA segment中的数据读入到对应的数据结构中，方便使用。
![_read_images的意义](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/read_image_overal.png)
读取的所有section：
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/DATA%20Segment.png)

###读取Mach-O指定Section的基础设施

首先登场的是GETSECT，位于objc-file.mm文件中，GETSECT宏可以生成不同的函数。函数名为name，这些函数完成读取Mach-O文件指定Section的内容。
```c++
#define GETSECT(name, type, sectname)                                   \
type *name(const headerType *mhdr, size_t *outCount) {              \
    return getDataSection<type>(mhdr, sectname, nil, outCount);     \
}                                                                   \
type *name(const header_info *hi, size_t *outCount) {               \
    return getDataSection<type>(hi->mhdr, sectname, nil, outCount); \
}
```
内部会调用getDataSection 函数。
```c++
template <typename T>
T* getDataSection(const headerType *mhdr, const char *sectname, 
                  size_t *outBytes, size_t *outCount)
{
    unsigned long byteCount = 0;
    T* data = (T*)getsectiondata(mhdr, "__DATA", sectname, &byteCount);
    if (!data) {
        data = (T*)getsectiondata(mhdr, "__DATA_CONST", sectname, &byteCount);
    }
    if (!data) {
        data = (T*)getsectiondata(mhdr, "__DATA_DIRTY", sectname, &byteCount);
    }
    if (outBytes) *outBytes = byteCount;
    if (outCount) *outCount = byteCount / sizeof(T);
    return data;
}
```
getDataSection 函数会读取DATA、DATA_CONST、__DATA_DIRTY Segement中名为sectname的section。

下面是使用GETSECT定义的函数列表。
```c++
//      function name                 content type     section name
GETSECT(_getObjc2SelectorRefs,        SEL,             "__objc_selrefs"); 
GETSECT(_getObjc2MessageRefs,         message_ref_t,   "__objc_msgrefs"); 
GETSECT(_getObjc2ClassRefs,           Class,           "__objc_classrefs");
GETSECT(_getObjc2SuperRefs,           Class,           "__objc_superrefs");
GETSECT(_getObjc2ClassList,           classref_t,      "__objc_classlist");
GETSECT(_getObjc2NonlazyClassList,    classref_t,      "__objc_nlclslist");
GETSECT(_getObjc2CategoryList,        category_t *,    "__objc_catlist");
GETSECT(_getObjc2NonlazyCategoryList, category_t *,    "__objc_nlcatlist");
GETSECT(_getObjc2ProtocolList,        protocol_t *,    "__objc_protolist");
GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    "__objc_protorefs");
```
上面10行代码定了了10个函数，分别读取10种section的内容。例如_getObjc2ClassList 函数，会读取 __objc_classlist section，也就是读取镜像中的所有类的列表。 这些函数下面都会用到，是这篇文章的基础。

上面的代码里有两个函数NonlazyClass和NonlazyCategory，这里需要提前了解一下什么是non lazy。这里以NonlazyClass为例。

###Non lazy Class
来自Stack Overflow的[Objective-C: What is a lazy class?](https://stackoverflow.com/questions/15315668/objective-c-what-is-a-lazy-class)：

>It's all about a class implementing or not a +load method.

>All the classes implemented in a given image file have a reference in a list stored in the "\_\_DATA, \_\_objc_classlist, regular, no_dead_strip" binary's section. This list allows the runtime system to keep track of all the classes stored in such file. However, not all of the classes need to be realized when the program starts up. That's why when a class implements a +load method, it also has a reference in a list stored in the "__DATA, \__objc_nlclslist, regular, no_dead_strip" section.

>So, _getObjc2NonlazyClassList retrieves the list of classes that do implement a +load method and are so called non-lazy. _getObjc2ClassList retrieves a list of all the classes in a image file, including the classes that don't have a +load method (and are called lazy) and the non-lazy ones. Non-lazy classes must be realized when the program starts up. Lazy classes, on the other hand, don't need to be realized immediately. This may be delayed until the class receives a message for the first time, for example (that's the reason for them to be considered "lazy").

>The same is true for categories, by the way.

某个类中有 load 方法，该类就变成了 non-lazy class，而 non-lazy class 会提前调用 realizeClass方法，该方法会对类里面的一些属性进行改变。比如调用 setHasCxxCtor 设置 hasCxxCtor 等。

non-lazy class 是一个很特殊的区中取出来的 class 列表，至于苹果为什么这么设计，原因笔者估计就是为了提高效率：只有 load 方法实现的类中才提前设置它的一些属性，否则，只加载最基本的数据即可，具体会在源码分析中介绍。

##源码分析

```c
//入参是map_images_nolock函数处理过的、非重复的、镜像列表和个数，总的类个数，未优化类个数。
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)
{
    header_info *hi;
    uint32_t hIndex;
    size_t count;
    size_t i;
    Class *resolvedFutureClasses = nil;
    size_t resolvedFutureClassCount = 0;
    static bool doneOnce;
    TimeLogger ts(PrintImageTimes);

#define EACH_HEADER \
    hIndex = 0;         \
    hIndex < hCount && (hi = hList[hIndex]); \
    hIndex++
    if (!doneOnce) {
        doneOnce = YES;
        // gdb_objc_realized_classes 中装的是不在shared cache中的类，无论是否realized。所以如果经过了预优化，那么就只考虑未优化的那些类，即 unoptimizedTotal，否则考虑全部类 total
        // 实例化存储类的哈希表，并且根据当前类数量做动态扩容
        int namedClassesSize = (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
        gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
    }
    
    // 由编译器读取类列表，并将所有类添加到类的哈希表中，并且标记懒加载的类并初始化内存空间
    for (EACH_HEADER) {
        if (! mustReadClasses(hi)) {
            continue;
        }

        bool headerIsBundle = hi->isBundle();// header 是否是 bundle 类型
        bool headerIsPreoptimized = hi->isPreoptimized(); // header 是否经过预优化

        // 从编译后的类列表中取出所有类，获取到的是一个classref_t类型的指针
        classref_t *classlist = _getObjc2ClassList(hi, &count);
        for (i = 0; i < count; i++) {
            // 数组中会取出OS_dispatch_queue_concurrent、OS_xpc_object、NSRunloop等系统类，例如CF、Fundation、libdispatch中的类。以及自己创建的类
            Class cls = (Class)classlist[i];
            // 通过readClass函数获取处理后的新类，内部主要操作ro和rw结构体
            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);
    
            // readClass如果返回的类是future类，存储到resolvedFutureClasses数组中，后面会实现这些future类。一般不会走该逻辑。
            if (newCls != cls  &&  newCls) {
            // Class was moved but not deleted. Currently this occurs 
            // only when the new class resolved a future class.
            // Non-lazily realize the class below.
            
            // 类被移动了，但是没有被删除，
            // 这只会发生在新类 resolve 了一个 future 类的情况下
            // 下面以非惰性的方法 realize 了 newCls
            // 为 resolvedFutureClasses 数组重新开辟一块更大的空间，并将原来的数据拷贝进来
                // 将懒加载的类添加到数组中
                // 将 newCls 添加到数组的末尾，resolvedFutureClassCount 加 1
                resolvedFutureClasses = (Class *)realloc(resolvedFutureClasses,(resolvedFutureClassCount+1) * sizeof(Class));
                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;
            }
        }
    }
    // 将未映射Class和Super Class重映射，被remap的类都是非懒加载的类
    if (!noClassesRemapped()) {
        for (EACH_HEADER) {
            // 重映射Class，注意是从_getObjc2ClassRefs函数中取出类的引用
            Class *classrefs = _getObjc2ClassRefs(hi, &count);
            for (i = 0; i < count; i++) {
                remapClassRef(&classrefs[i]);
            }
            // 重映射父类
            classrefs = _getObjc2SuperRefs(hi, &count);
            for (i = 0; i < count; i++) {
                remapClassRef(&classrefs[i]);
            }
        }
    }
    
    // 将所有SEL都注册到哈希表中，是另外一张哈希表
    static size_t UnfixedSelectors;
    sel_lock();
    for (EACH_HEADER) {
        if (hi->isPreoptimized()) continue;

        bool isBundle = hi->isBundle();
    
        SEL *sels = _getObjc2SelectorRefs(hi, &count);
        UnfixedSelectors += count;
        for (i = 0; i < count; i++) {
            const char *name = sel_cname(sels[i]);
            // 注册SEL的操作
            sels[i] = sel_registerNameNoLock(name, isBundle);
        }
    }
    // 修复旧的函数指针调用遗留
    for (EACH_HEADER) {
        message_ref_t *refs = _getObjc2MessageRefs(hi, &count);
        if (count == 0) continue;
        for (i = 0; i < count; i++) {
            // 内部将常用的alloc、objc_msgSend等函数指针进行注册，并fix为新的函数指针
            fixupMessageRef(refs+i);
        }
    }
    // 遍历所有协议列表，并且将协议列表加载到Protocol的哈希表中
    for (EACH_HEADER) {
        extern objc_class OBJC_CLASS_$_Protocol;
        // cls = Protocol类，所有协议和对象的结构体都类似，isa都对应Protocol类
        Class cls = (Class)&OBJC_CLASS_$_Protocol;
        assert(cls);
        // 获取protocol哈希表
        NXMapTable *protocol_map = protocols();
        bool isPreoptimized = hi->isPreoptimized();
        bool isBundle = hi->isBundle();
        
        // 从编译器中读取并初始化Protocol
        protocol_t **protolist = _getObjc2ProtocolList(hi, &count);
        for (i = 0; i < count; i++) {
            readProtocol(protolist[i], cls, protocol_map, 
                         isPreoptimized, isBundle);
        }
    }
    // 修复协议列表引用，优化后的images可能是正确的，但是并不确定
    for (EACH_HEADER) {
        // 需要注意到是，下面的函数是_getObjc2ProtocolRefs，和上面的_getObjc2ProtocolList
        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &count);
        for (i = 0; i < count; i++) {
            remapProtocolRef(&protolist[i]);
        }
    }
    // 实现非懒加载的类，对于load方法和静态实例变量
    for (EACH_HEADER) {
        classref_t *classlist = 
            _getObjc2NonlazyClassList(hi, &count);
        for (i = 0; i < count; i++) {
        Class cls = remapClass(classlist[i]);
        if (!cls) continue;
        // 实现所有非懒加载的类(实例化类对象的一些信息，例如rw)
            realizeClass(cls);
        }
    }
    // 遍历resolvedFutureClasses数组，并对每个类进行实现
    if (resolvedFutureClasses) {
        for (i = 0; i < resolvedFutureClassCount; i++) {
                    realizeClass(resolvedFutureClasses[i]);
            resolvedFutureClasses[i]->setInstancesRequireRawIsa(false/*inherited*/);
        }
        free(resolvedFutureClasses);
    }
    
    // 发现和处理所有Category
    for (EACH_HEADER) {
        // 外部循环遍历找到当前类，查找类对应的Category数组
        category_t **catlist = 
            _getObjc2CategoryList(hi, &count);
        bool hasClassProperties = hi->info()->hasCategoryClassProperties();
        // 内部循环遍历当前类的所有Category
        for (i = 0; i < count; i++) {
            category_t *cat = catlist[i];
            Class cls = remapClass(cat->cls);

            // 首先，通过其所属的类注册Category。如果这个类已经被实现，则重新构造类的方法列表。
            bool classExists = NO;
            if (cat->instanceMethods ||  cat->protocols  
                ||  cat->instanceProperties) 
            {
                // 将Category添加到对应Class的value中，value是Class对应的所有category数组
                addUnattachedCategoryForClass(cat, cls, hi);
                // 将Category的method、protocol、property添加到Class
                if (cls->isRealized()) {
                    remethodizeClass(cls);
                    classExists = YES;
                }
            }

            // 这块和上面逻辑一样，区别在于这块是对Meta Class做操作，而上面则是对Class做操作
            // 根据下面的逻辑，从代码的角度来说，是可以对原类添加Category的
            if (cat->classMethods  ||  cat->protocols  
                ||  (hasClassProperties && cat->_classProperties)) 
            {
                addUnattachedCategoryForClass(cat, cls->ISA(), hi);
                if (cls->ISA()->isRealized()) {
                    remethodizeClass(cls->ISA());
                }
            }
        }
    }

    // 初始化从磁盘中加载的所有类，发现Category必须是最后执行的
        // 从runtime objc4-532版本源码来看，DebugNonFragileIvars字段一直是-1，所以不会进入这个方法中
    if (DebugNonFragileIvars) {
        realizeAllClasses();
    }
#undef EACH_HEADER
}
```
这个方法作用就是读取各个 section 中的数据并放到缓存中，这里的缓存大部分都是全局静态变量，载体就是我们之前分析的 hashmap，我们先回顾上一篇文章中的所有 hashmap：
pendingInitializeMap 、 category_map 、nonmeta_class_map 、future_named_class_map 、remapped_class_map 、protocol_map 、gdb_objc_realized_classes。

我们把这里面的 hashmap 分为几类：

关于 class 的：
gdb_objc_realized_classes、remapped_class_map、future_named_class_map、nonmeta_class_map

关于 protocol 的：
protocol_map

关于 category 的：
category_map

本文带大家了解 _read_images 方法的过程中会揭开其中的几个 hashmap 的作用。

精简一下上面的代码：
```
if (!doneOnce) {
    gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
}

for (EACH_HEADER) {
    classref_t *classlist = _getObjc2ClassList(hi, &count);
}

for (EACH_HEADER) {
    Class *classrefs = _getObjc2ClassRefs(hi, &count);
}

for (EACH_HEADER) {
    SEL *sels = _getObjc2SelectorRefs(hi, &count);
}

for (EACH_HEADER) {
    message_ref_t *refs = _getObjc2MessageRefs(hi, &count);
}

for (EACH_HEADER) {
    protocol_t **protolist = _getObjc2ProtocolList(hi, &count);
}

for (EACH_HEADER) {
    protocol_t **protolist = _getObjc2ProtocolRefs(hi, &count);
}

for (EACH_HEADER) {
    classref_t *classlist = _getObjc2NonlazyClassList(hi, &count);
}

for (EACH_HEADER) {
    category_t **catlist = 
        _getObjc2CategoryList(hi, &count);
}
```
发现很多类似的方法，这些方法在笔者之前已经讲解过，都是获取 section 的方法。

因此 _read_images 方法的作用也很明显了： 把对应 section 里的数据取出来，然后进行加工，最后添加到缓存中。虽然说 _read_images 只有几百行，但其中又会调用其他很多方法，因此总的来说 _read_images 方法还是比较复杂的。下面进行分段讲解。

###创建gdb_objc_realized_classes
```
if (!doneOnce) {
        doneOnce = YES;
        // gdb_objc_realized_classes 中装的是不在shared cache中的类，无论是否realized。所以如果经过了预优化，那么就只考虑未优化的那些类，即 unoptimizedTotal，否则考虑全部类 total
        // 实例化存储类的哈希表，并且根据当前类数量做动态扩容
        int namedClassesSize = (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
        gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
    }
```
从上述_read_images源码中可以看到，最先遇到的hashmap是gdb_objc_realized_classes。这里主要是根据是否优化来决定gdb_objc_realized_classes的大小。

###readClass
接着是遍历header info，通过_getObjc2ClassList读取__objc_classlist section，也即是项目中全部类的列表。这里会先通过mustReadClasses来判断这个image中的类是否是必需读取的。必需读取类的image包括存在missing weak superclasses的类和unresolved future classes。这两个我们后续会介绍是什么东西。紧接着是遍历前面获取的class list，并对每个class调用readClass方法。
其实现为：
```
/***********************************************************************
 读取一个编译器写的 类 或 元类，
 返回新类的指针，有可能是：
    - cls
    - nil (cls 有一个 missing weak-linked 的父类)
    - 同名的 future 类，该 future 类填充了 cls 类的信息
 调用者：_read_images() / objc_readClassPair()
**********************************************************************/
Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)
{
    const char *mangledName = cls->mangledName();// 取得 cls 的重整后的名字
    if (missingWeakSuperclass(cls)) {
    // 查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing
        // 祖宗类里有 missing weak-linked 的
        // 则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -> nil
        addRemappedClass(cls, nil);// 将其添加到重映射表里，映射为nil
        cls->superclass = nil;// 父类指针指向 nil
        return nil;
    }

    Class replacing = nil;
    // 尝试将 mangledName 对应的 future 的类从 future_named_class_map 中弹出
    // 如果返回的 newCls 有值，则 newcls 类是以前开辟的一个同名的 future 类，
    // 这个 future 类现在得到了兑现，因为有一个同名的新类 cls 进来了，
    // future 类里的信息会由 cls 中的信息填充（原来 future 类只开辟了内存，里面其实是啥都没的）
    // 并将 cls 代替
    if (Class newCls = popFutureNamedClass(mangledName)) {
        if (newCls->isSwift()) {
            _objc_fatal("Can't complete future class request for '%s' "
                        "because the real class is too big.", 
                        cls->nameForLogging());
        }
        
        class_rw_t *rw = newCls->data();
        const class_ro_t *old_ro = rw->ro;
        memcpy(newCls, cls, sizeof(objc_class));
        rw->ro = (class_ro_t *)newCls->data();
        newCls->setData(rw);
        freeIfMutable((char *)old_ro->name);
        free((void *)old_ro);
        
        addRemappedClass(cls, newCls);
        
        replacing = cls;
        cls = newCls;
    }
    
    if (headerIsPreoptimized  &&  !replacing) {// 预优化过，且没有被代替
        assert(getClass(mangledName));
    } else {
    // 否则将 mangledName -> cls 的映射添加到 gdb_objc_realized_classes 表中
        // 如果上 cls 被 newCls 代替了，那么 replacing 就是老的 cls，即在 gdb_objc_realized_classes 中
        // 也会将老的 cls 代替
        addNamedClass(cls, mangledName, replacing);
    }
    
    // for future reference: shared cache never contains MH_BUNDLEs
    if (headerIsBundle) {
        cls->data()->flags |= RO_FROM_BUNDLE;
        cls->ISA()->data()->flags |= RO_FROM_BUNDLE;
    }
    
    return cls;
}
```
首先判断class的super class是不是missing Weak Superclass，如果是的话就通过addRemappedClass函数将cls->nil对放入RemappedClass hash map，然后返回nil。如果是Future named class，就从future_named_class_map弹出，然后对它的class_ro_t和class_rw_t进行处理（算是轻量的realize），然后将cls->newCls对通过addRemappedClass进行类似操作。然后通过addNamedClass更新在gdb_objc_realized_classes里的存储。根据readClass返回的结果，如果是Future Named Class就会进入if语句，这里表示我们resolve了一个Future Named Class，需要把它放进对应的数组里。这里我们已经引入了好几个新的函数和hash map，我们需要赶紧在下一节解释它们。

###class相关的hash表
_read_images中讲解了 class 相关的多个 hash 表：
* gdb_objc_realized_classes
* remapped_class_map
* future_named_class_map
* nonmeta_class_map

####gdb_objc_realized_classes
>gdb_objc_realized_classes is actually a list of named classes not in the dyld shared cache, whether realized or not.

这段文字出现在文件 objc_runtime_new.mm 中：
![](https://upload-images.jianshu.io/upload_images/1672498-bb7f714823f5cc8e.png?imageMogr2/auto-orient/strip|imageView2/2/w/720)
gdb_objc_realized_classes 是一系列的类列表，这些类不管有没有实现，都不在 dyld 的共享缓存中。

全局搜索 gdb_objc_realized_classes，我们可以看到一系列方法，
![](https://upload-images.jianshu.io/upload_images/1672498-ebecf30966f5015c.png?imageMogr2/auto-orient/strip|imageView2/2/w/295)
这些方法涉及到对于 gdb_objc_realized_classes 的一系列操作，包括：
获取某个类：
```
static Class getClass_impl(const char *name)
{
    runtimeLock.assertLocked();
    // allocated in _read_images
    assert(gdb_objc_realized_classes);
    // Try runtime-allocated table
    Class result = (Class)NXMapGet(gdb_objc_realized_classes, name);
    if (result) return result;
    // Try table from dyld shared cache
    return getPreoptimizedClass(name);
}
```
添加某个类：
```
/***********************************************************************
* addNamedClass
* Adds name => cls to the named non-meta class map.
* Warns about duplicate class names and keeps the old mapping.
* Locking: runtimeLock must be held by the caller

添加 name -> cls 对到 named non-meta class map（gdb_objc_realized_classes）中
 警告有副本，但是会保持老的映射，即会有多份，
 新的映射被存在了 secondary metaclass map(二级元类映射表) 表中，见 addNonMetaClass()，
 replacing : 被代替的老的 cls (见 readClass()) 如果有旧映射，但是与 replacing 不符合，还是会保留旧映射，
             否则新值会将 gdb_objc_realized_classes 中的旧映射覆盖
 调用者：objc_duplicateClass() / objc_registerClassPair() / readClass()
**********************************************************************/
static void addNamedClass(Class cls, const char *name, Class replacing = nil)
{
    runtimeLock.assertWriting();
    Class old;
    // 先根据 name 查找是否有对应的旧类，如果有，并且 old 与 replacing 不同
    // 则报警告，但是会保持老的映射，插入新的映射
    if ((old = getClass(name))  &&  old != replacing) {
        inform_duplicate(name, old, cls);

        // getNonMetaClass uses name lookups. Classes not found by name 
        // lookup must be in the secondary meta->nonmeta table.
        // 将 cls 存入 matacls->cls 的二级映射表中
        addNonMetaClass(cls);
    } else {
         // 如果没有旧值，或者指定要覆盖旧值（replacing == old），就将新的 name->cls 对插入 gdb_objc_realized_classes
         NXMapInsert(gdb_objc_realized_classes, name, cls);
    }
    assert(!(cls->data()->flags & RO_META));

    // wrong: constructed classes are already realized when they get here
    // assert(!cls->isRealized());
}
```
移除某个类：
```
/***********************************************************************
* removeNamedClass
* Removes cls from the name => cls map.
* Locking: runtimeLock must be held by the caller
**********************************************************************/
static void removeNamedClass(Class cls, const char *name)
{
    runtimeLock.assertWriting();
    assert(!(cls->data()->flags & RO_META));
    if (cls == NXMapGet(gdb_objc_realized_classes, name)) {
        NXMapRemove(gdb_objc_realized_classes, name);
    } else {
        // cls has a name collision with another class - don't remove the other
        // but do remove cls from the secondary metaclass->class map.
        removeNonMetaClass(cls);
    }
}
```
而初始化的位置就是我们所知道的 _read_images 方法中：
```
// namedClasses
// Preoptimized classes don't go in this table.
// 4/3 is NXMapTable's load factor
int namedClassesSize = 
    (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
gdb_objc_realized_classes =
    NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
```
add 方法的也位于 _read_images 调用栈中：
```
- void _objc_init(void)
    - void _dyld_objc_notify_register();
        - void map_2_images();
            - void map_images_nolock();
                - void _read_images();
                    - Class readClass();
                        - void addNamedClass();
```
需要注意的是：`addNamedClass(cls, mangledName, replacing);`的第二个参数是 mangledName， 也就是从 section 中获取的数据。

现在看来，gdb_objc_realized_classes 的作用已经很明显了，即是对所有的类进行缓存：从对应的 section 中读取所有的类，取出来后以 mangledName 作为键，以 class 结构体作为值。

####remapped_class_map
 全局搜索 remapped_class_map 我们看到如下结果：
 ![](https://upload-images.jianshu.io/upload_images/1672498-6c9e01230efe80fe.png?imageMogr2/auto-orient/strip|imageView2/2/w/477)
可以发现，关于 remapped_class_map 的一些引用都位于文件 objc-runtime-new.m 中。

其中，获取 remapped_class_map 的方法为：
```
static NXMapTable *remappedClasses(bool create)
{
    static NXMapTable *remapped_class_map = nil;
    runtimeLock.assertLocked();
    if (remapped_class_map) return remapped_class_map;
    if (!create) return nil;
    // remapped_class_map is big enough to hold CF's classes and a few others
    INIT_ONCE_PTR(remapped_class_map, 
                  NXCreateMapTable(NXPtrValueMapPrototype, 32), 
                  NXFreeMapTable(v));
    return remapped_class_map;
```
在该方法上下查看，可以发现一系列和 remap 相关的函数：
![](https://upload-images.jianshu.io/upload_images/1672498-6b1f1c10bd35036b.png?imageMogr2/auto-orient/strip|imageView2/2/w/402)
这里总结如下：

添加一个 class：
```
static void addRemappedClass(Class oldcls, Class newcls) {
    runtimeLock.assertWriting();
    if (PrintFuture) {
        _objc_inform("FUTURE: using %p instead of %p for %s", 
                     (void*)newcls, (void*)oldcls, oldcls->nameForLogging());
    }
    void *old;
    old = NXMapInsert(remappedClasses(YES), oldcls, newcls);
    assert(!old);
}
```
将一个 class 进行 remap：
```
static Class remapClass(classref_t cls)
{
    return remapClass((Class)cls);
}
```

大家注意一下，这边的参数类型是 classref_t，经过前面的文章，我们了解到，这是从 secion 中取出来的原始的 class 类型。
这个方法是在 _read_images 方法中被调用的：
```
// Realize non-lazy classes (for +load methods and static instances)
for (EACH_HEADER) {
    classref_t *classlist =
    _getObjc2NonlazyClassList(hi, &count);
    for (i = 0; i < count; i++) {
        Class cls = remapClass(classlist[i]);
        if (!cls) continue;
        realizeClass(cls);
    }
}
```
remapped_class_map 相关的方法介绍完了，但大家可能还是一头雾水
* 什么是 remapped class ？
* 为什么 class 要 remap？
* remap 过程？

本文就带大家研究一下 remap class 的实现。

##### 什么是 remapped class ？

remap class，字面意思是 重新映射 class，那肯定有一个映射者和映射结果。所以我们看方法：
```
static Class remapClass(classref_t cls) {
    return remapClass((Class)cls);
}
```
参数类型是 classref_t，返回值类型是 Class。classref_t 我们很熟悉了，在前面的文章中我们知道，section 为 __objc_classlist 以及 __objc_nlclslist 的返回类型都是 classref_t，也就是说， remap 的参数从这两个 section 中拿到的。其实现如下：
```
static Class remapClass(Class cls)
{
    runtimeLock.assertLocked();
    Class c2;
    if (!cls) return nil;
    NXMapTable *map = remappedClasses(NO);
    if (!map  ||  NXMapMember(map, cls, (void**)&c2) == NX_MAPNOTAKEY) {
        return cls;
    } else {
        return c2;
    }
}
```
从该方法实现中可以看出：map 的键是 cls，也就是 section 中拿到的 cls，而 value 就是我们 remap 的结果。而 remap 的 操作肯定是在方法
```
static void addRemappedClass(Class oldcls, Class newcls) {
}
```
中的，因为两个参数分别为 oldcls ，newcls。

#####为什么 Class 要 remap？
要知道原因，我们看一下调用时机，他们都在方法 readClass 中，其调用栈为：
全局搜索 addRemappedClass，发现其实调用时机只有一个地方,且调用栈为：
```
void _objc_init()
    void map_2_images()
        void map_images_nolock()
            void _read_images()
                Class readClass()
                    void addRemappedClass()
```
如上代码可知，有两个分支有机会进入方法 addRemappedClass，一个是 missingWeakSuperclass 方法是否为真，另外一个是 popFutureNamedClass(mangledName) 方法返回是否为真。这里会有两个概念
* WeakSuperclass
* FutureNamedClass

而这两个条件为true 的情况就是需要 remap 的情况。

#####weak-linked class
missingWeakSuperclass 的源码为：
```
/***********************************************************************
* missingWeakSuperclass
* Return YES if some superclass of cls was weak-linked and is missing.
**********************************************************************/
static bool  missingWeakSuperclass(Class cls) {
    assert(!cls->isRealized());

    if (!cls->superclass) {
        // superclass nil. This is normal for root classes only.
        return (!(cls->data()->flags & RO_ROOT));
    } else {
        // superclass not nil. Check if a higher superclass is missing.
        Class supercls = remapClass(cls->superclass);
        assert(cls != cls->superclass);
        assert(cls != supercls);
        if (!supercls) return YES;
        if (supercls->isRealized()) return NO;
        return missingWeakSuperclass(supercls);
    }
}
```
代码的注释已经一目了然：该函数就是判断某个 class 的父类是否是 weak-linked 并且缺失了。那 什么叫做 weak-linked？比如 NSObject 是否是 weak-linbked ？很显然不是的。那么什么是 weak-linked？
>weak-linked
我们开发的时候，都会使用最新的SDK，但是为了让老的设备可以下载并运行我们的应用，就要将Deployment Target设置成之前系统的版本号。例如我们应用使用iOS 8.1的SDK，Deployment Target设置成iOS 5.1.1，虽然我们开发的时候使用的是8.1的SDK，但是程序运行在的设备中却可能是6.0 or 7.0的SDK上，按照苹果的说法，如果我们应用使用了最新SDK引入的特性，比如符号、函数等，那么在版本较旧的设备上就运行不了。下面是苹果官方文档的一段话：
Normally, if an application uses a new feature in a framework, it is unable to run on earlier versions of the framework that do not support that feature. Such applications would either fail to launch or crash when an attempt to use the feature was made.
那么为什么我们使用最新的SDK开发的应用却可以运行在旧的系统中呢？答案是使用了弱引用。资料里面说过，我们自己创建的framework，如果需要做版本兼容，那么就要对今后加入的符号等使用弱引用，使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL，下面就是教我们怎样定义弱引用。有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用整个framework就好，方法就是链接的时候使用 -weak_framework frameworkName
```
// weak link the function
extern int MyFunction() __attribute__((weak_import));
// weak link the variable
extern int MyVariable __attribute__((weak_import));
```
这么一来， missingWeakSuperclass 的作用的作用就不言而喻了：查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing，祖宗类里有 missing weak-linked 的，则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -> nil。

####future_named_class_map
在前面的文章中我们分析过，存储在 hash map 中数据的几个类：
* gdb_objc_realized_classes：已经实现过的类列表
* remapped_class_map，已经重映射的类列表

今天我们就讲另外一个和上面两个息息相关的 hash map ：future_named_class_map，它存储了 未来要实现的类。

创建:
```
static NXMapTable *future_named_class_map = nil;
static NXMapTable *futureNamedClasses()
{
    runtimeLock.assertWriting();
    if (future_named_class_map) return future_named_class_map;
    // future_named_class_map is big enough for CF's classes and a few others
    future_named_class_map =  NXCreateMapTable(NXStrValueMapPrototype, 32);
    return future_named_class_map;
}
```
以上代码清晰明了：如果有的话使用，没有的话则创建。

获取:
```
OBJC_EXPORT Class objc_getFutureClass(const char *name) 
    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0)
    OBJC_ARC_UNAVAILABLE;
```
这个方法需要注意，它是在 runtime.h 中声明的，也就是说，他其实是对外暴露的，可以直接使用，不过看其注释：
```
/*** Used by CoreFoundation's toll-free bridging.
Return the id of the named class.
@return The id of the named class, or an uninitialized class
structure that will be used for the class when and if it does
get loaded.
@warning Do not call this function yourself.
***/
```
注意最后一句： 不要主动调用这个函数！

我们来看一下这个函数的实现：
```
Class objc_getFutureClass(const char *name)
{
    Class cls;
    cls = look_up_class(name, YES, NO);
    if (cls) {
        if (PrintFuture) {
            _objc_inform("FUTURE: found %p already in use for %s", 
                         (void*)cls, name);
        }
        return cls;
    }
    return _objc_allocateFutureClass(name);
}
```
其中函数 look_up_class 这里先不多做介绍了，里面逻辑较多，而且不是这个函数的重点，重点是最后一句：_objc_allocateFutureClass(name) 它才是从 hash map 中获取对应值的函数，其实现如下 ：
```
Class _objc_allocateFutureClass(const char *name)
{
    rwlock_writer_t lock(runtimeLock);
    Class cls;
    NXMapTable *map = futureNamedClasses();
    if ((cls = (Class)NXMapGet(map, name))) {
        // Already have a future class for this name.
        return cls;
    }
    cls = _calloc_class(sizeof(objc_class));
    addFutureNamedClass(name, cls);
    return cls;
}
```
很容易理解：有的话就通过方法 NXMapGet 取出来，没有的话则创建。

移除:
```
// 将指定 name 对应的 future 类从 future_named_class_map 中移除
// 因为 这个类 已经被 realized 过了，它已经不再处于 future 状态
// 返回 name 对应的 future class，如果没有对应的 future class，就返回 nil
// caller : readClass()
static Class popFutureNamedClass(const char *name)
{
    runtimeLock.assertWriting();

    Class cls = nil;

    if (future_named_class_map) {
    // 如果 future_named_class_map 非空
        // 利用 key name 将 future class 从 future_named_class_map 移除
        // NXMapKeyFreeingRemove 与 NXMapRemove 功能一样，但是会释放 key，因为 key 是在堆中分配的，原因见 NXMapKeyCopyingInsert()
       
        cls = (Class)NXMapKeyFreeingRemove(future_named_class_map, name);
        // 如果 name 确实有对应的 future class，并且当前 future_named_class_map 已经空了
        // 就将 future_named_class_map 释放
        if (cls && NXCountMapTable(future_named_class_map) == 0) {
            NXFreeMapTable(future_named_class_map);
            future_named_class_map = nil;
        }
    }

    return cls;
}
```
这个方法有点熟悉了，正是上文介绍的 remap 的条件之一。上一篇文章讲述的是第一个条件，本文讲的是第二个条件。这两个条件无论哪一个符合都会调用方法：addRemappedClass，即向 remapped_class_map 中插入数据。这里画一幅图加深理解：
![](https://upload-images.jianshu.io/upload_images/1672498-908955a0c5589aeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/994)
以上这张图已经说明了之前笔者分析的两个 map 与本文的 map 之间的关系。

###readClass总结

readClass 做了下面三件事：
1.如果class的祖宗类丢失，将类添加到NXMapTable *remapped_class_map表中，key是cls，value是nil。 最后直接返回 nil。
2.从future_named_class_map中查找cls是否是future类，如果是，通过cls实现future类，然后将结果添加到remapped_class_map中，key是cls，value是实现完成的future类——newCls。 同时调用addNamedClass函数，将newCls添加到gdb_objc_realized_classes或 nonmeta_class_map表中。
3.其他情况，直接调用addNamedClass函数，将类添加到gdb_objc_realized_classes或nonmeta_class_map表中。 返回cls。 一般代码走这一步。

下面是这段代码使用的几个新表:
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_readImage_data.png)

##remapClassRef
接下去是通过remapClassRef修复_getObjc2ClassRefs中获取的类引用列表。因为我们前面通过remapClass对class进行了修正，可能被设为了nil，也可能reallocate了，这一步就是为了进行同步。
```
/***********************************************************************
* remapClassRef
* Fix up a class ref, in case the class referenced has been reallocated 
* or is an ignored weak-linked class.
* Locking: runtimeLock must be read- or write-locked by the caller
**********************************************************************/
static void remapClassRef(Class *clsref)
{
    runtimeLock.assertLocked();

    Class newcls = remapClass(*clsref);    
    if (*clsref != newcls) *clsref = newcls;
}
```
##注册SEL
紧接着是将_getObjc2SelectorRefs获取的所有SEL注册到namedSelectors这个hash map中。

|区 	|__objc_selrefs|
|----|----|
|含义 |	方法列表|
|方法名| 	_getObjc2SelectorRefs|
|对应全局变量| 	namedSelectors|

创建
```
namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, (unsigned)SelrefCount);
```
插入
```
NXMapInsert(namedSelectors, sel_getName(result), result);
```

获取
```
result = (SEL)NXMapGet(namedSelectors, name);
```

##fixupMessageRef
接着是通过_getObjc2MessageRefs获取所有的方法，然后遍历这些方法，如果是一些常用的alloc、objc_msgSend等函数，就给其设置函数实现的地址，方便后续调用。

##readProtocol和remapProtocolRef
读取并保存protocol和修复protocol引用，这里暂不深入探究。protocol也有需要remap的情况。

接着是对非懒加载的类进行realizeClass。下面我们要重点分析realizeClass函数。

##realizeClass非懒加载类
```c
static Class realizeClass(Class cls)
{
    const class_ro_t *ro;
    class_rw_t *rw;
    Class supercls;
    Class metacls;
    bool isMeta;

    if (!cls) return nil;
    if (cls->isRealized()) return cls;
    assert(cls == remapClass(cls));

    // fixme verify class is not in an un-dlopened part of the shared cache?
    // 最开始cls->data是指向ro的
    ro = (const class_ro_t *)cls->data();
    if (ro->flags & RO_FUTURE) {
        // This was a future class. rw data is already allocated.
        // rw已经初始化并且分配内存空间
        rw = cls->data();
        ro = cls->data()->ro;
        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);
    } else {
        // Normal class. Allocate writeable class data.
        // 如果rw并不存在，则为rw分配空间
        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);
        rw->ro = ro;
        rw->flags = RW_REALIZED|RW_REALIZING;
        // 将rw传入setData函数，等于cls->data()重新指向rw
        cls->setData(rw);
    }

    isMeta = ro->flags & RO_META;

    rw->version = isMeta ? 7 : 0;  // old runtime went up to 6


    // Choose an index for this class.
    // Sets cls->instancesRequireRawIsa if indexes no more indexes are available
    cls->chooseClassArrayIndex();

    // Realize superclass and metaclass, if they aren't already.
    // This needs to be done after RW_REALIZED is set above, for root classes.
    // This needs to be done after class index is chosen, for root metaclasses.
    
    // 如果父类或元类没有初始化，必须先初始化父类或元类
    supercls = realizeClass(remapClass(cls->superclass));
    metacls = realizeClass(remapClass(cls->ISA()));

#if SUPPORT_NONPOINTER_ISA
    // Disable non-pointer isa for some classes and/or platforms.
    // Set instancesRequireRawIsa.
    bool instancesRequireRawIsa = cls->instancesRequireRawIsa();
    bool rawIsaIsInherited = false;
    static bool hackedDispatch = false;

    if (DisableNonpointerIsa) {
        // Non-pointer isa disabled by environment or app SDK version
        instancesRequireRawIsa = true;
    }
    else if (!hackedDispatch  &&  !(ro->flags & RO_META)  &&  
             0 == strcmp(ro->name, "OS_object")) 
    {
        // hack for libdispatch et al - isa also acts as vtable pointer
        hackedDispatch = true;
        instancesRequireRawIsa = true;
    }
    else if (supercls  &&  supercls->superclass  &&  
             supercls->instancesRequireRawIsa()) 
    {
        // This is also propagated by addSubclass() 
        // but nonpointer isa setup needs it earlier.
        // Special case: instancesRequireRawIsa does not propagate 
        // from root class to root metaclass
        instancesRequireRawIsa = true;
        rawIsaIsInherited = true;
    }
    
    if (instancesRequireRawIsa) {
        cls->setInstancesRequireRawIsa(rawIsaIsInherited);
    }
// SUPPORT_NONPOINTER_ISA
#endif

    // Update superclass and metaclass in case of remapping
    cls->superclass = supercls;
    cls->initClassIsa(metacls);

    // Reconcile instance variable offsets / layout.
    // This may reallocate class_ro_t, updating our ro variable.
    if (supercls  &&  !isMeta) reconcileInstanceVariables(cls, supercls, ro);

    // Set fastInstanceSize if it wasn't set already.
    cls->setInstanceSize(ro->instanceSize);

    // Copy some flags from ro to rw
    if (ro->flags & RO_HAS_CXX_STRUCTORS) {
        cls->setHasCxxDtor();
        if (! (ro->flags & RO_HAS_CXX_DTOR_ONLY)) {
            cls->setHasCxxCtor();
        }
    }

    // Connect this class to its superclass's subclass lists
    if (supercls) {
        addSubclass(supercls, cls);
    } else {
        addRootClass(cls);
    }

    // 初始化class_rw_t
    methodizeClass(cls);

    return cls;
}
```
realizeClass realize(实现) 指定的 cls 类：

1.包括开辟它的 read-write data，也就是 rw，见 class_rw_t 结构体；
2.设置类的类型，元类or 普通类；
3.递归超类、元类，调用realizeClass。确保超类全部实现过；
4.设置superclass指针、元类指针；
5.reconcileInstanceVariables ；
6.addSubclass 构建类继承体系的链表；
7.methodizeClass 调整方法 ；
8.添加到全局表中。

realizeClass 的总体流程如下图：
![realizeClass 的总体流程](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/relizeClass.png)

###创建class_rw_t结构
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/relizemethod_rw.png)
开辟RW的工作就是：将class_data_bits_t结构中bits的3->47位指定的RO切断，创建新的class_rw_t结构，3->47位 重新存储新的class_rw_t结构地址，然后将class_rw_t结构中的ro指针指向原始的class_ro_t结构。

那么从上述源码中就可以发现，类的初始信息本来其实是存储在class_ro_t中的，并且ro本来是指向cls->data()的，也就是说bits.data()得到的是ro，但是在运行过程中创建了class_rw_t，并将cls->data指向rw，同时将初始信息ro赋值给rw中的ro。最后在通过setData(rw)设置data。那么此时bits.data()得到的就是rw，之后再去检查是否有分类，同时将分类的方法，属性，协议列表整合存储在class_rw_t的方法，属性及协议列表中。

在上面的代码中我们还发现了两个函数，addRootClass和addSubclass函数，这两个函数的职责是将某个类的子类串成一个列表，大致是下面的链接顺序。由此可知，我们是可以通过class_rw_t，获取到当前类的所有子类。
```c
superClass.firstSubclass -> subClass1.nextSiblingClass -> subClass2.nextSiblingClass -> ...
```
通过上述对源码的分析，我们对class_rw_t内存储方法、属性、协议列表的过程有了更清晰的认识。

###addSubclass
构建出的链表如下：
![addSubclass 构成链表的示意图](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/addClass.png)

###methodizeClass
初始化rw和ro之后，rw的method list、protocol list、property list都是空的，需要在下面methodizeClass函数中进行赋值。函数中会把ro的list都取出来，然后赋值给rw，如果在运行时动态修改，也是对rw做的操作。所以ro中存储的是编译时就已经决定的原数据，rw才是运行时动态修改的数据。
```c
// 1. fix-up cls 类的方法列表、协议列表、属性列表（但是看代码，被 fix-up 的只有方法列表啊）
//    将 cls 类的所有没有被 attach 的分类 attach 到 cls 上
// 2. 即将分类中的方法、属性、协议添加到 methods、 properties 和 protocols 中
//    runtimeLock 读写锁必须被调用者上写锁，保证线程安全
static void methodizeClass(Class cls)
{
    bool isMeta = cls->isMetaClass();
    auto rw = cls->data();
    auto ro = rw->ro;
    
    // 将ro中的method list、property list、protocol list加载到rw中，也就是将编译时确定的只读参数加载到rw的读写可操作参数中
    method_list_t *list = ro->baseMethods();
    if (list) {
        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));
        rw->methods.attachLists(&list, 1);
    }

    property_list_t *proplist = ro->baseProperties;
    if (proplist) {
        rw->properties.attachLists(&proplist, 1);
    }

    protocol_list_t *protolist = ro->baseProtocols;
    if (protolist) {
        rw->protocols.attachLists(&protolist, 1);
    }

    // Root classes get bonus method implementations if they don't have 
    // them already. These apply before category replacements.
    
    // 处理根元类的一些操作，添加一个objc_noop_imp的函数指针
    if (cls->isRootMetaclass()) {
        // root metaclass
        // 给根元类的 SEL_initialize 指定了对应的 IMP - objc_noop_imp
        // 即给根元类发送 SEL_initialize 消息，不会走到它的 +initialize，而是走 objc_noop_imp，里面啥也不干
        addMethod(cls, SEL_initialize, (IMP)&objc_noop_imp, "", NO);
    }

    // 获取到类对应的Category，并将Category从哈希表中移除
        // 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类
    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);
    // 添加Category到类中，添加到rw中
    // 从分类列表中添加方法列表、属性和协议到 cls 类中
    // attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？
    // 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的
    //         所以压根儿不用再另外排序
    attachCategories(cls, cats, false /*don't flush caches*/);
    
    if (cats) free(cats);
}
```
而prepareMethodLists的实现：
```
static void 
prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount, 
                   bool baseMethods, bool methodsFromBundle)
{
    runtimeLock.assertWriting();

    if (addedCount == 0) return;

    // Don't scan redundantly
    bool scanForCustomRR = !cls->hasCustomRR();
    bool scanForCustomAWZ = !cls->hasCustomAWZ();

    // There exist RR/AWZ special cases for some class's base methods. 
    // But this code should never need to scan base methods for RR/AWZ: 
    // default RR/AWZ cannot be set before setInitialized().
    // Therefore we need not handle any special cases here.
    if (baseMethods) {
        assert(!scanForCustomRR  &&  !scanForCustomAWZ);
    }

    // Add method lists to array.
    // Reallocate un-fixed method lists.
    // The new methods are PREPENDED to the method list array.

    for (int i = 0; i < addedCount; i++) {
        method_list_t *mlist = addedLists[i];
        assert(mlist);

        // Fixup selectors if necessary
        if (!mlist->isFixedUp()) {
            fixupMethodList(mlist, methodsFromBundle, true/*sort*/);
        }

        // Scan for method implementations tracked by the class's flags
        if (scanForCustomRR  &&  methodListImplementsRR(mlist)) {
            cls->setHasCustomRR();
            scanForCustomRR = false;
        }
        if (scanForCustomAWZ  &&  methodListImplementsAWZ(mlist)) {
            cls->setHasCustomAWZ();
            scanForCustomAWZ = false;
        }
    }
}
```
在fixupMethodList中会对方法列表进行排序：
```
static void 
fixupMethodList(method_list_t *mlist, bool bundleCopy, bool sort)
{
    runtimeLock.assertWriting();
    assert(!mlist->isFixedUp());

    // fixme lock less in attachMethodLists ?
    sel_lock();
    
    // Unique selectors in list.
    for (auto& meth : *mlist) {
        const char *name = sel_cname(meth.name);
        meth.name = sel_registerNameNoLock(name, bundleCopy);
    }
    
    sel_unlock();

    // Sort by selector address.
    if (sort) {
        method_t::SortBySELAddress sorter;
        std::stable_sort(mlist->begin(), mlist->end(), sorter);
    }
    
    // Mark method list as uniqued and sorted
    mlist->setFixedUp();
}
```
也就是根据SEL的地址进行稳定排序，这样确保相同SEL的method能保持原有的顺序，也就确保了分类的method会在类的method之前。


![类结构体](https://upload-images.jianshu.io/upload_images/270478-6a2db4356819af18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

上面的代码完成的四个工作用图中的4条虚线表示：
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/relizemethod_method.png)

##realizeClass Future named class

##分类处理


分类的数据结构
```
// 存放 locstamped_category_t 的列表
struct locstamped_category_list_t {
    uint32_t count;  // 数组有几个元素
#if __LP64__
    uint32_t reserved;
#endif
    locstamped_category_t list[0]; // 数组的起始地址
};
```

```
// 本地的盖了戳的 category，即已经被添加进了 unattachedCategories
struct locstamped_category_t {
    category_t *cat;   //  category
    struct header_info *hi;  // 所属的 header，即所属的镜像
};
```

```
struct category_t {
    const char *name; // 分类的名字
    classref_t cls;   // 分类所属的类，classref_t 专门用于 unremapped 的类
    struct method_list_t *instanceMethods;  // 实例方法列表
    struct method_list_t *classMethods;     // 类方法列表
    struct protocol_list_t *protocols;      // 遵循的协议列表
    struct property_list_t *instanceProperties; // 属性列表，但是并没有卵用... 唉....
}
```
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/catogory_class.png)

存储所有分类的Map结构
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/category_map.png)

###向category_map中添加新的分类
向category_map中添加新的分类 调用addUnattachedCategoryForClass方法：
```
static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader)
{
    runtimeLock.assertWriting();

    // DO NOT use cat->cls! cls may be cat->cls->isa instead
    NXMapTable *cats = unattachedCategories(); // 取得存储所有没有被 attached 的分类的列表
    category_list *list;

    // 从所有 unattached 的分类列表中取得 cls 类对应的所有没有被 attach 的分类列表
    list = (category_list *)NXMapGet(cats, cls);
    if (!list) { // 如果 cls 没有未  attach 的分类
        // 就开辟出一个单位的空间，用来放新来的这个分类
        list = (category_list *)
            calloc(sizeof(*list) + sizeof(list->list[0]), 1);
    } else {
        // 否则开辟出比原来多一个单位的空间，用来放新来的这个分类，因为 realloc ，所以原来的数据会被拷贝过来
        list = (category_list *)
            realloc(list, sizeof(*list) + sizeof(list->list[0]) * (list->count + 1));
    }
    // 将新来的分类 cat 添加刚刚开辟的位置上
    list->list[list->count++] = (locstamped_category_t){cat, catHeader};
    // 将新的 list 重新插入 cats 中，会覆盖老的 list
    NXMapInsert(cats, cls, list);
}
```
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/addUnattachedCategoryForClass.png)

###将分类附着（attachCategories）到类中
```
// Attach categories.
// 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类
category_list *cats = unattachedCategoriesForClass(cls, true /*realizing 其实这个参数压根没用*/);
// 从分类列表中添加方法列表、属性和协议到 cls 类中
// attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？
// 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的
//         所以压根儿不用再另外排序
attachCategories(cls, cats, false /*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/);
```

```
static void 
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return; // 如果列表是 nil，直接返回
    
    // 打印一些信息
    if (PrintReplacedMethods) {
        printReplacements(cls, cats);
    }

    bool isMeta = cls->isMetaClass(); // 记录 cls 类是否是元类

    // fixme rearrange to remove these intermediate allocations
    
    // 在堆中为方法列表数组、属性列表数组、协议列表数组分配足够大内存，注意，它们都是二维数组
    // 后面会将所有分类中的方法列表、属性列表、协议列表的首地址放到里面
    method_list_t **mlists = (method_list_t **)
        malloc(cats->count * sizeof(*mlists));
    property_list_t **proplists = (property_list_t **)
        malloc(cats->count * sizeof(*proplists));
    protocol_list_t **protolists = (protocol_list_t **)
        malloc(cats->count * sizeof(*protolists));

    // Count backwards through cats to get newest categories first
    int mcount = 0; // 记录方法的数量
    int propcount = 0; // 记录属性的数量
    int protocount = 0; // 记录协议的数量
    int i = cats->count; // 从后开始，保证先取最新的分类
    bool fromBundle = NO; // 记录是否是从 bundle 中取的
    while (i--) { // 从后往前遍历
        
        auto& entry = cats->list[i]; // 分类，locstamped_category_t 类型

        // 取出分类中的方法列表；如果是元类，取得的是类方法列表；否则取得的是实例方法列表
        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
        if (mlist) {
            mlists[mcount++] = mlist; // 将方法列表放入 mlists 方法列表数组中
            fromBundle |= entry.hi->isBundle(); // 分类的头部信息中存储了是否是 bundle，将其记住
        }

        // 取出分类中的属性列表，如果是元类，取得是nil
        property_list_t *proplist = entry.cat->propertiesForMeta(isMeta);
        if (proplist) {
            proplists[propcount++] = proplist; // 将属性列表放入 proplists 属性列表数组中
        }

        // 取出分类中遵循的协议列表
        protocol_list_t *protolist = entry.cat->protocols;
        if (protolist) {
            protolists[protocount++] = protolist; // 将协议列表放入 protolists 协议列表数组中
        }
    }

    auto rw = cls->data(); // 取出 cls 的 class_rw_t 数据

    // 准备 mlists 中的方法列表们
    prepareMethodLists(cls, mlists, mcount/*方法列表的数量*/, NO/*不是基本方法*/, fromBundle/*是否来自bundle*/);
    rw->methods.attachLists(mlists, mcount); // 将准备完毕的新方法列表们添加到 rw 中的方法列表数组中
    free(mlists); // 释放 mlists
    if (flush_caches  &&  mcount > 0) { // 如果需要清空方法缓存，并且刚才确实有方法列表添加进 rw 中，
                                        // 不然没有新方法加进来，就没有必要清空，清空是为了避免无法命中缓存的错误
                                        // 因为缓存位置是按照 hash 的方法确定的，详情见 cache_t::find() 函数
        flushCaches(cls); // 清空 cls 类 / cls 类的元类 / cls 类的子孙类 的方法缓存
    }

    rw->properties.attachLists(proplists, propcount); // 将新属性列表添加到 rw 中的属性列表数组中
    free(proplists); // 释放 proplists

    rw->protocols.attachLists(protolists, protocount); // 将新协议列表添加到 rw 中的协议列表数组中
    free(protolists); // 释放 protolists
}
```
上面代码将 category_list *cats 中的list成员表示的方法列表转化为数组mlists：
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/attachCategories_ToArray.png)
转化完成后，调用attachLists方法，附着到类上：
```
void attachLists(List* const * addedLists, uint32_t addedCount) {
    if (addedCount == 0) return;

    if (hasArray()) {
        // many lists -> many lists
        uint32_t oldCount = array()->count;
        uint32_t newCount = oldCount + addedCount;
        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
        array()->count = newCount;
        memmove(array()->lists + addedCount, array()->lists, 
                oldCount * sizeof(array()->lists[0]));
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
    else if (!list  &&  addedCount == 1) {
        // 0 lists -> 1 list
        list = addedLists[0];
    } 
    else {
        // 1 list -> many lists
        List* oldList = list;
        uint32_t oldCount = oldList ? 1 : 0;
        uint32_t newCount = oldCount + addedCount;
        setArray((array_t *)malloc(array_t::byteSize(newCount)));
        array()->count = newCount;
        if (oldList) array()->lists[addedCount] = oldList;
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
}
```
将List\*\* 中的内容附着到method_array_t 上,原理如图：
![](https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/attachLists_1.png)

##参考
iOS开发之runtime(27): _read_images 浅析
https://www.jianshu.com/p/5bbb654656c4


iOS开发之 runtime(29) ：gdb_objc_realized_classes 浅析
https://www.jianshu.com/p/9718a1ba5519

iOS开发之 runtime(30) ：remapped_class_map 浅析
https://www.jianshu.com/p/1a316934f29c

IOS底层原理之类的加载过程（750.1版本，推荐）
https://www.jianshu.com/p/706838eb7922

9._read_images 从二进制文件中读取类信息
https://jianli2017.top/wiki/IOS/Runtime/objc/9__read_images/