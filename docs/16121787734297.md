第三章 语言基础

[TOC]

ECMA-262 第 5 版(ES5)目前为止实现得最为广泛，ES6次之。本章基于ES6。

# 3.1 语法
## 3.1.1 区分大小写
## 3.1.2 标识符
什么是标识符？
标识符，就是变量、函数、属性或函数参数的名称。

标识符的组成？
第一个字符必须是一个字母、下划线(_)或美元符号($);（数字不能作为开头，为什么？请举出反例）
剩下的其他字符可以是字母、下划线、美元符号或数字。
>标识符中的字母可以是扩展 ASCII(Extended ASCII)中的字母，也可以是 Unicode 的字母字符，
如 À 和 Æ(但不推荐使用)。

推荐的标识符风格？
按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，例如firstSecond。因为这种形式跟 ECMAScript 内置函数和对象的命名方式一致，所以算是最佳实践。

## 3.1.3 注释
支持C语言的单行和多行注释。

## 3.1.4 严格模式
什么是严格模式？
严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。ECMAScript 5引入。

引入严格模式
要对整个脚本启用严格模式，在脚本开头加上这一行:"use strict";函数内引入严格模式：
```
function doSomething() { "use strict";
// 函数体
}
```

## 3.1.5 语句
ECMAScript 中的语句以分号结尾。即使语句末尾的分号不是必需的，也应该加上。

## 3.2 关键字与保留字

# 3.3 变量
有 3 个关键字可以声明变量:var、const 和 let。其中，var 在 ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。

## 3.3.1 var关键字
var message;
可以用它保存任何类型的值;不初始化的情况下，变量会保存一个特殊值 undefined；不仅可以改变保存的值，也可以改变值的类型。

var声明作用域
使用var声明的变量会成为包含它的函数的局部变量，意味着该变量将在函数退出时被销毁。而在函数内定义变量时省略 var操作符，可以创建一个全局变量。

var声明提升
①在函数体内，先于声明使用var变量也不会报错，因为使用这个关键字声明的变量会自动提升到函数作用域顶部:
```
function foo() { console.log(age); var age = 26;
}
foo();  // undefined
```
等价于
```
function foo() {
var age;
console.log(age);
age = 26; }
foo();  // undefined
```
②反复多次使用var声明同一个变量也没有问题。因为变量提升后，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。

## 3.3.2 let声明
let声明和var声明的不同？
①let 声明的范围是块作用域，而var声明的范围是函数作用域。
②let 也不允许同一个块作用域中出现冗余声明，而var允许。

>JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明。

>对声明冗余报错不会因混用 let 和 var而受影响。

>块作用域
块作用域是函数作用域的子集。if，for，where的花括号区域能产生块作用域。

③let 声明的变量不会在作用域中被提升，而var会被提升。

>暂时性死区
在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”(temporal dead zone)，在此 阶段引用任何后面才声明的变量都会抛出 ReferenceError。

>条件声明
因为let的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在仅在没有声明的条件下才声明它。

④使用 let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声 明的变量则会)。

⑤for循环中的let声明和var声明的差异。
使用var在for循环内定义的迭代变量会渗透到循环体外部。
```
for (var i = 0; i < 5; ++i) { // 循环逻辑
}
console.log(i); // 5
```
而使用let的迭代变量的作用域仅限于 for 循环块内部。
```
for (let i = 0; i < 5; ++i) { // 循环逻辑
}
console.log(i); // ReferenceError: i 没有定义
```
在退出循环时，var迭代变量保存的是导致循环退出的值。
```
for (var i = 0; i < 5; ++i) { setTimeout(() => console.log(i), 0)
}
// 你可能以为会输出0、1、2、3、4 // 实际上会输出5、5、5、5、5
```
使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。
```
for (let i = 0; i < 5; ++i) { setTimeout(() => console.log(i), 0)
}
// 会输出0、1、2、3、4
```
这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of 循环。

**拓展**
[怎么理解for循环中用let声明的迭代变量每次是新的变量？](https://www.imooc.com/wenda/detail/440805)

## 3.3.3 const声明
const 的行为与 let 基本相同，唯一一个重要的区别是
①用它声明变量时必须同时初始化变量，②且尝试修改const声明的变量会导致运行时错误。

注意：const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象， 那么修改这个对象内部的属性并不违反 const 的限制。

## 3.3.4 声明风格及最佳实践
1. 不使用 var
2. const 优先，let 次之

# 3.4 数据类型
ECMAScript 有 6 种简单数据类型(也称为原始类型):
Undefined、Null、Boolean、Number、 String 和 Symbol。Symbol(符号)是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object(对象)。Object 是一种无序名值对的集合。

## 3.4.1 typeof操作符
typeof 操作符可以确定任意变量的数据类型。对一个值使用 typeof 操作符会返回下列字符串之一:
* "undefined"表示值未定义;
* "boolean"表示值为布尔值;
* "string"表示值为字符串;
* "number"表示值为数值;
* "object"表示值为对象(而不是函数)或 null; 
* "function"表示值为函数;
* "symbol"表示值为符号。

>typeof 是一个操作符而不是函数，所以不需要参数(但可以使用参数)。
>调用 typeof null 返回的是"object"。这是因为特殊值 null 被认为是一个对空对象的引用。

## 3.4.2 Undefined类型
Undefined 类型只有一个值，就是特殊值 undefined。
>字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为 了正式明确空对象指针(null)和未初始化变量的区别。

在对未初始化的变量调用 typeof 时，返回的结果是"undefined"，但对未声明的变量调用它时， 返回的结果还是"undefined"，这就有点让人看不懂了。
>即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的 同时进行初始化。这样，当 typeof 返回"undefined"时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。

## 3.4.3 Null类型
Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因。

## 3.4.4 Boolean类型
有两个字面值:true 和 false。 这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。

下表总结了不同类型与布尔值之间的转换规则。

|数据类型|转换为 true 的值|转换为 false 的值
|----|----|----|
|Boolean|true|false|
|String |非空字符串|""(空字符串)|
|Number |非零数值(包括无穷值)|0、NaN(参见后面的相关内容)
|Object |任意对象|null|
|Undefined|N/A(不存在)|undefined|

## 3.4.5 Number类型
数值转换
有 3 个函数可以将非数值转换为数值:Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。

Number()函数基于如下规则执行转换。
* 布尔值，true 转换为 1，false 转换为 0。 
* 数值，直接返回。
* null，返回 0。
* undefined，返回 NaN。
* 字符串，应用以下规则。
    * 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number("1")返回 1，Number("123")返回 123，Number("011")返回 11(忽略前面 的零)。
    * 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值(同样，忽略前面的零)。
    * 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值。
    * 如果是空字符串(不包含字符)，则返回 0。
    * 如果字符串包含除上述情况之外的其他字符，则返回 NaN。
* 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。

## 3.4.6 String类型
String(字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(")、 单引号(')或反引号(`)标示。ECMAScript 语法中表示字符串的引号没有区别。

字符字面量
由一些字符表示的特殊字符，作为单个字符被解释，表示非打印字符或有其他用途的字符。

字符串的长度
字符串的长度可以通过其length 属性获取。如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数。

字符串的特点
ECMAScript 中的字符串是不可变的(immutable)，一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。

转换为字符串
有两种方式把一个值转换为字符串。
①首先是使用几乎所有值都有的 toString()方法。

这个方法唯一的用途就是返回当前值的字符串等价物。toString()方法可见于数值、布尔值、对象和字符串值。(字符串值的 toString()方法简单地返回自身的一个副本。)null 和 undefined 值没有 toString()方法。

多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示。

②如果你不确定一个值是不是 null 或 undefined，可以使用String()转型函数，它始终会返回表示相应类型值的字符串。
String()函数遵循如下规则：
* 如果值有 toString()方法，则调用该方法(不传参数)并返回结果。 
* 如果值是 null，返回"null"。
* 如果值是 undefined，返回"undefined"。

>用加号操作符给一个值加上一个空字符串""也可以将其转换为字符串

模板字面量
ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串。模板字面量会保持反引号内部的空格，换行符。

字符串插值
可以使用模板字面量，在一个连续定义中插入一个或多个值。字符串插值通过在${}中使用一个 JavaScript 表达式实现。所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插 值。嵌套的模板字符串无须转义：
```
console.log(`Hello, ${ `World` }!`); // Hello, World!
```

标签函数
模板字面量也支持定义标签函数(tag function)，而通过标签函数可以自定义插值行为。**标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。**
```
let a = 6;
    let b = 9;
function zipTag(strings, ...expressions) { return strings[0] +
expressions.map((e, i) => `${e}${strings[i + 1]}`) .join('');
}
letuntaggedResult= `${a}+${b}=${a+b}`; let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`;
console.log(untaggedResult); // "6 + 9 = 15" console.log(taggedResult); // "6 + 9 = 15"
```

原始字符串
使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或 Unicode 字符)，而不是被转 换后的字符表示。为此，可以使用默认的 String.raw 标签函数:
```
// \u00A9 是版权符号 11 console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9
```
也可以通过标签函数的第一个参数，即字符串数组的.raw 属性取得每个字符串的原始内容:
```
function printRaw(strings) { console.log('Actual characters:'); for (const string of strings) {
console.log(string); }
console.log('Escaped characters;'); for (const rawString of strings.raw) {
console.log(rawString); }
}
printRaw`\u00A9${ 'and' }\n`; // Actual characters:
// ©
//(换行符)
    // Escaped characters:
    // \u00A9
    // \n
```

## 3.4.7 Symbol类型
**Symbol(符号)是 ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。**

符号的基本用法
```
let sym = Symbol(); console.log(typeof sym); // symbol
```
调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述(description)，将来可以通过这个字符串来调试代码:
```
let otherFooSymbol = Symbol('foo');
```
Symbol()函数不能与 new 关键字一起作为构造函数使用。

使用全局符号注册表
如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册 表中创建并重用符号。
为此，需要使用 Symbol.for()方法:
```
let fooGlobalSymbol = Symbol.for('foo');
console.log(typeof fooGlobalSymbol); // symbol
```
Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。

全局注册表中的符号必须使用字符串键来创建，作为参数传给 Symbol.for()的任何值都会被转换为字符串，注册表中使用的键同时也会被用作符号描述。

使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回undefined。如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError。
```
// 创建全局符号
let s = Symbol.for('foo'); console.log(Symbol.keyFor(s)); // foo
// 创建普通符号
let s2 = Symbol('bar'); console.log(Symbol.keyFor(s2)); // undefined
```

使用符号作为属性
符号可以作为对象字面量属性和 Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。
```
let s1 = Symbol('foo');
let o = {
      [s1]: 'foo val'
};
```
类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnProperty- Symbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnProperty- Descriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型 的键。


常用内置符号
略

## 3.4.8 Object类型

每个 Object 实例都有如下属性和方法。 
* constructor:用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。
* hasOwnProperty(propertyName):用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串(如 o.hasOwnProperty("name"))或符号。
* isPrototypeOf(object):用于判断当前对象是否为另一个对象的原型。
* propertyIsEnumerable(propertyName):用于判断给定的属性是否可以使用(本章稍后讨论的)for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。
* toLocaleString():返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
* toString():返回对象的字符串表示。
* valueOf():返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。 

因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。


# 3.5 操作符
## 3.5.1 一元操作符
1.递增/递减操作符
可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。（和Number()转型函数一样）
* 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。
* 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。
* 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。
* 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。
* 对于浮点值，加 1 或减 1。
* 如果是对象，则调用其(第 5 章会详细介绍的)valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。

2.一元加和减
如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换:布尔值 false 和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toString() 方法以得到可以转换的值。
## 3.5.2 位操作符
## 3.5.3 布尔操作符

## 3.5.4 乘性操作符
1.乘法操作符
* 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。
* 如果有任一操作数是 NaN，则返回 NaN。
* 如果是 Infinity 乘以 0，则返回 NaN。
* 如果是 Infinity 乘以非 0 的有限数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。
* 如果是 Infinity 乘以 Infinity，则返回 Infinity。
* 如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。
## 3.5.5 指数操作符
ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的
## 3.5.6 加性操作符
1.加法操作符
如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果: * 如果有任一操作数是 NaN，则返回 NaN;
* 如果是 Infinity 加 Infinity，则返回 Infinity;
* 如果是-Infinity 加-Infinity，则返回-Infinity;
* 如果是 Infinity 加-Infinity，则返回 NaN;
* 如果是+0 加+0，则返回+0;
* 如果是-0 加+0，则返回+0;
* 如果是-0 加-0，则返回-0。
不过，如果有一个操作数是字符串，则要应用如下规则:
* 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面;
* 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。如果另一个操作数是对象、数值或布尔值，则调用它们的toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取 "undefined"和"null"。 
如果一个是数值，一个是布尔值，则把布尔值转为0或1，再计算和。
## 3.5.7 关系操作符
* 如果操作数都是数值，则执行数值比较。
* 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。
* 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。
* 如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。 如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。
* 如果有任一操作数是布尔值，则将其转换为数值再执行比较。
## 3.5.8 相等操作符
1.等于和不等于
这两个操作符都会先进 行类型转换(通常称为强制类型转换)再确定操作数是否相等。
* 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。
* 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。
* 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法取得其原始值，再根据前面的规则进行比较。
在进行比较时，这两个操作符会遵循如下规则。
* null 和 undefined 相等。
* null 和 undefined 不能转换为其他类型的值再进行比较。
* 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住:即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。
* 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。

下表总结了一些特殊情况及比较的结果

2.全等和不全等
全等操 作符由 3 个等于号(===)表示，只有两个操作数在不转换的前提下相等才返回 true。
## 3.5.9 条件操作符
## 3.5.10 赋值操作符
## 3.5.11 逗号操作符

# 3.6 流控制
## 3.6.1 if语句
## 3.6.2 do-while语句
## 3.6.3 while语句
## 3.6.4 for语句

## 3.6.5 for-in语句
for-in 语句是一种严格的迭代语句，用于枚举对象中的非symbol类型键属性。

如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。

## 3.6.6 for-of语句
for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素。

如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误。

## 3.6.7 标签语句
标签语句用于给语句加标签。可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。

## 3.6.8 break和continue语句

## 3.6.9 with语句
with 语句的用途是将代码作用域设置为特定的对象。
```
with(location) {
let qs = search.substring(1); let hostName = hostname;
let url = href;
}
```
这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是 一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如 果有，则该变量会被求值为 location 对象的属性。

> 由于with语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。严格模式不允许使用 with 语句，否则会抛出错误。

## 3.6.10 switch语句
首先，switch 语句可以用于所有数据类型(在很多语言中，它只能用于数值)，因此可以使用字符串甚至对象。 其次，条件的值不需要是常量，也可以是变量或表达式。

>switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类 型(比如，字符串"10"不等于数值 10)。


# 3.7 函数
ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。

ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返 回函数的值，用法是后跟要返回的值。除了return语句之外没有任何特殊声明表明该函 数有返回值。

只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。

return 语句也可以不带返回值。这时候，函数会立即停止执行并返回 undefined。

严格模式对函数也有一些限制:
* 函数不能以 eval 或 arguments 作为名称;
* 函数的参数不能叫 eval 或 arguments;
* 两个命名参数不能拥有同一个名称。 
如果违反上述规则，则会导致语法错误，代码也不会执行。



 


 
