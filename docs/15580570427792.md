# 一句话设计模式
1.普通工厂模式：一个工厂根据不同参数生产多种产品。

多个工厂方法模式：一个工厂内提供多个工厂方法，分别创建产品。

静态工厂方法模式：将多个工厂方法模式的方法变成静态的，不需要产生实例。

2.抽象工厂模式：创建多个工厂，分别创建不同产品

3.单例

4、建造者模式（Builder）
抽象Builder类，多个具体 builder类，一个指挥者类Director。指挥者类持有一个具体builder对象，然后调用从Builder类继承的方法，按步骤建造对象。

创建一个复杂的对象，通常用各个部分的子对象用一定算法构成。由于需求的变化，组成对象的各个部分面临巨大的变化，但是把它们组合在一起的算法相对比较稳定。

一篇文章就彻底弄懂建造者模式(Builder Pattern)
https://www.jianshu.com/p/3d1c9ffb0a28

5、原型模式（Prototype），实现可拷贝的能力

6、适配器模式（Adapter）
类的适配器模式：创建一个类，继承要被适配的类，然后实现缺少的方法。
对象的适配器模式：创建一个类，持有要被适配的对象，实现所有要求的方法，已被适配对象实现的则直接调用它的实现。
接口的适配器模式：一个接口有很多方法，但我们又不想全部实现它时，引入一个抽象类，实现它的全部方法，创建一个继承这个抽象类的类，实现我们感兴趣的方法。

7、装饰模式（Decorator）
装饰对象持有被装饰对象，实现同一个接口，在接口方法里可以调用被装饰对象的对象的实现，也可以增加自己的功能。

8、代理模式（Proxy）
代理对象内部持有一个真正处理外部消息的对象，代理对象只是把外部消息，转发给了它进行处理。

为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。

9、外观模式（Facade）
使用中心化的方式解决分布式互相耦合的问题。外观模式是针对模块的外部系统使用使用，相当于外观模式把一个系统所有的功能打包好了，提供一些接口给外界来使用这个系统的功能；

为子系统的一组接口提供一个一致（稳定）的界面。提供一个高层接口使子系统更加容易使用（复用）。组件和外部客户来说，内部子系统的变化不会影响到高层接口。

外观模式 VS 中介者模式:https://www.cnblogs.com/huohuoL/p/10545594.html
中介者模式、代理模式和外观模式的Pk
https://blog.csdn.net/mengmei16/article/details/43981791

10、桥接模式（Bridge）
桥接模式类似装饰器模式，不同的是，桥接模式可以随意更换被桥接的对象，只要它们实现了相同的接口，是一种抽象化与实现化的解耦。

class A{
object b

handle(){
[self.B fetchData];
}
}

class B{

fetchData()
}

class B1:B{
fetchData(){
....
}
}

class A1:A{
handle(){
[super handle];
}
}

class A2:A{
handle(){
[super handle];
}
}

class Bridge{
fetch(){
A1 *a = [A1 new];
B *b = [B1 new];
a.b = b;
[a handle];
}
}
可以实现m x n的组合。

11、组合模式（Composite）
节点构成了树。

12、享元模式（Flyweight）
对象共享池

13、策略模式（strategy）
多个算法实现相同的协议，根据需要选择不同的方法。

14、模板方法模式（Template Method）
定义一个抽象类，定义一个类继承它，重写抽象方法，通过调用抽象类，实现对子类的调用。（可以认为父类指针指向子类对象）
定义一个操作中的算法的骨架（稳定），将一些步骤延迟（变化）到子类，使得子类可以不改变（复用）一个算法的结构，即可重定义算法的某些特定步骤。

15、观察者模式（Observer）
16、迭代子模式（Iterator）

17、责任链模式（Chain of Responsibility）

 18、命令模式（Command）
 命令模式的目的就是达到命令的发出者和执行者之间解耦。命令持有执行者，发出者持有命令，执行命令时，命令内部调用执行者去执行。
 
 19、备忘录模式（Memento）
 主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象。
 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后可以将对象恢复到原先保存的状态。
 
 20、状态模式（State）
 当对象的状态改变时，同时改变其行为。
 
 把状态枚举变成各个状态类，把行为放在状态类虚基类中，虚基类还有个指向下一个状态对象的指针PNext。在每个状态类的方法实现中，需要给PNext设置经过方法调用后的下一个状态对象。
 
 21、访问者模式（Visitor）
 访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。
 
 由于需求的改变，某些类层次结构中常常需要增加新的行为，如果直接在基类中做这样的更改，将会给子类带来繁重的负担，甚至破坏原有设计。在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作。
 适用于类层次结构稳定，而其中的操作缺面临频繁变动。
 
 22、中介者模式（Mediator）
 也是为了避免对象相互耦合，外观是内部持有对象，并提供一致的接口供外部操作。中介者是中介者外部持有对象，对对象的操作，会通过中介者内部对它们进行操作。
 
 外观模式解耦系统间（单向）的对象关联关系，中介者解耦系统内各个对象之间（双向）的关联关系。
 
 MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者
 
 23、解释器模式（Interpreter）
 解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！

