Runtime的加载过程(二) _objc_init

[TOC]

从上一节的图中
![](https://www.dllhook.com/zb_users/upload/2018/08/5b715ef891d23534311492.jpg)
可以看到，在libSystem.B.dylib的libSystem_initializer 函数中调用libdispatch.dylib的libdispatch_init函数初始化了libdispatch，然后在libdispatch_init又调用了_os_object_init函数，最终调用了_objc_init.

_objc_init函数是runtime被加载后第一个执行的方法，它调用了_dyld_objc_notify_register函数，这个函数注册dyld事件的监听。

##_objc_init
一个OC程序可以在运行过程中动态加载和链接新类或Category，新类或Category会加载到程序中，其处理方式和其他类是相同的。动态加载还可以做许多不同的事，动态加载允许应用程序进行自定义处理。

OC提供了objc_loadModules运行时函数，执行Mach-O中模块的动态加载，在上层NSBundle对象提供了更简单的访问API。

在Runtime加载时，会从调用_objc_init函数开始，并在内部注册三个函数指针`map_images`,`load_images`和`unmap_image`。void _objc_init(void)函数位于文件objc_os.mm中
![](https://upload-images.jianshu.io/upload_images/2204571-049e28e4bcc8d93b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/264)
```c
void _objc_init(void)
{
    // 标记是否已初始化
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    // 读取环境变量，并且可以在里面开启打印选项，方便调式
    environ_init();
    // 初始化线程信息
    tls_init();
    // 初始化 C++ 静态构造方法
    static_init();
    lock_init();
    // 初始化异常处理系统
    exception_init();
    // 注册镜像映射、加载镜像、卸载镜像映射
    _dyld_objc_notify_register(&map_images, load_images, unmap_image);
}
```
##environ_init
读取环境配置方法，在这个方法里会读取在Xcode 中配置的环境变量参数。如图:
![](https://upload-images.jianshu.io/upload_images/2204571-94a921254beedef0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/885)
可配置环境变量可以参见头文件**objc-env.h**
```
void environ_init(void) 
{
    if (issetugid()) {
        // All environment variables are silently ignored when setuid or setgid
        // This includes OBJC_HELP and OBJC_PRINT_OPTIONS themselves.
        return;
    } 

    bool PrintHelp = false;
    bool PrintOptions = false;
    bool maybeMallocDebugging = false;

    // Scan environ[] directly instead of calling getenv() a lot.
    // This optimizes the case where none are set.
    for (char **p = *_NSGetEnviron(); *p != nil; p++) {
        if (0 == strncmp(*p, "Malloc", 6)  ||  0 == strncmp(*p, "DYLD", 4)  ||  
            0 == strncmp(*p, "NSZombiesEnabled", 16))
        {
            maybeMallocDebugging = true;
        }

        if (0 != strncmp(*p, "OBJC_", 5)) continue;
        
        if (0 == strncmp(*p, "OBJC_HELP=", 10)) {
            PrintHelp = true;
            continue;
        }
        if (0 == strncmp(*p, "OBJC_PRINT_OPTIONS=", 19)) {
            PrintOptions = true;
            continue;
        }
        
        const char *value = strchr(*p, '=');
        if (!*value) continue;
        value++;
        
        for (size_t i = 0; i < sizeof(Settings)/sizeof(Settings[0]); i++) {
            const option_t *opt = &Settings[i];
            if ((size_t)(value - *p) == 1+opt->envlen  &&  
                0 == strncmp(*p, opt->env, opt->envlen))
            {
                *opt->var = (0 == strcmp(value, "YES"));
                break;
            }
        }            
    }

    // Special case: enable some autorelease pool debugging 
    // when some malloc debugging is enabled 
    // and OBJC_DEBUG_POOL_ALLOCATION is not set to something other than NO.
    if (maybeMallocDebugging) {
        const char *insert = getenv("DYLD_INSERT_LIBRARIES");
        const char *zombie = getenv("NSZombiesEnabled");
        const char *pooldebug = getenv("OBJC_DEBUG_POOL_ALLOCATION");
        if ((getenv("MallocStackLogging")
             || getenv("MallocStackLoggingNoCompact")
             || (zombie && (*zombie == 'Y' || *zombie == 'y'))
             || (insert && strstr(insert, "libgmalloc")))
            &&
            (!pooldebug || 0 == strcmp(pooldebug, "YES")))
        {
            DebugPoolAllocation = true;
        }
    }

    // Print OBJC_HELP and OBJC_PRINT_OPTIONS output.
    if (PrintHelp  ||  PrintOptions) {
        if (PrintHelp) {
            _objc_inform("Objective-C runtime debugging. Set variable=YES to enable.");
            _objc_inform("OBJC_HELP: describe available environment variables");
            if (PrintOptions) {
                _objc_inform("OBJC_HELP is set");
            }
            _objc_inform("OBJC_PRINT_OPTIONS: list which options are set");
        }
        if (PrintOptions) {
            _objc_inform("OBJC_PRINT_OPTIONS is set");
        }

        for (size_t i = 0; i < sizeof(Settings)/sizeof(Settings[0]); i++) {
            const option_t *opt = &Settings[i];            
            if (PrintHelp) _objc_inform("%s: %s", opt->env, opt->help);
            if (PrintOptions && *opt->var) _objc_inform("%s is set", opt->env);
        }
    }
}
```
对以上代码做个解释：
issetugid
该方法在苹果API Reference中有介绍：[issetugid](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FSystem%2FConceptual%2FManPages_iPhoneOS%2Fman2%2Fissetugid.2.html)，大概意思是判断当前App的uid或者gid有没有发生变化。这里返回的是NO，继续看后面的代码。
![](https://upload-images.jianshu.io/upload_images/1672498-c71807cb5fd5f740.png?imageMogr2/auto-orient/strip|imageView2/2/w/663)


_NSGetEnviron
获取Xcode中的环境变量，类似的函数还有：
```
extern char ***_NSGetArgv(void);
extern int *_NSGetArgc(void);
extern char **_NSGetProgname(void);
```
接下来的代码都是对环境变量进行读取以及和Settings里的变量进行比对了：
```
for (size_t i = 0; i < sizeof(Settings)/sizeof(Settings[0]); i++) {
    const option_t *opt = &Settings[i];
    if ((size_t)(value - *p) == 1+opt->envlen  &&  
        0 == strncmp(*p, opt->env, opt->envlen))
    {
        *opt->var = (0 == strcmp(value, "YES"));
        break;
    }
}
```
Settings即是本地的变量文件，我们点击进入看一下：
```
const option_t Settings[] = {
#define OPTION(var, env, help) option_t{&var, #env, help, strlen(#env)}, 
#include "objc-env.h"
#undef OPTION
};
```
可以发现，其环境变量都是在objc-env.h中进行设置的,而该文件的内容如下：
```
OPTION( PrintImages,              OBJC_PRINT_IMAGES,               "log image and library names as they are loaded")
OPTION( PrintImageTimes,          OBJC_PRINT_IMAGE_TIMES,          "measure duration of image loading steps")
OPTION( PrintLoading,             OBJC_PRINT_LOAD_METHODS,         "log calls to class and category +load methods")
OPTION( PrintInitializing,        OBJC_PRINT_INITIALIZE_METHODS,   "log calls to class +initialize methods")
OPTION( PrintResolving,           OBJC_PRINT_RESOLVED_METHODS,     "log methods created by +resolveClassMethod: and +resolveInstanceMethod:")
OPTION( PrintConnecting,          OBJC_PRINT_CLASS_SETUP,          "log progress of class and category setup")
OPTION( PrintProtocols,           OBJC_PRINT_PROTOCOL_SETUP,       "log progress of protocol setup")
OPTION( PrintIvars,               OBJC_PRINT_IVAR_SETUP,           "log processing of non-fragile ivars")
OPTION( PrintVtables,             OBJC_PRINT_VTABLE_SETUP,         "log processing of class vtables")
OPTION( PrintVtableImages,        OBJC_PRINT_VTABLE_IMAGES,        "print vtable images showing overridden methods")
OPTION( PrintCaches,              OBJC_PRINT_CACHE_SETUP,          "log processing of method caches")
OPTION( PrintFuture,              OBJC_PRINT_FUTURE_CLASSES,       "log use of future classes for toll-free bridging")
OPTION( PrintPreopt,              OBJC_PRINT_PREOPTIMIZATION,      "log preoptimization courtesy of dyld shared cache")
OPTION( PrintCxxCtors,            OBJC_PRINT_CXX_CTORS,            "log calls to C++ ctors and dtors for instance variables")
OPTION( PrintExceptions,          OBJC_PRINT_EXCEPTIONS,           "log exception handling")
OPTION( PrintExceptionThrow,      OBJC_PRINT_EXCEPTION_THROW,      "log backtrace of every objc_exception_throw()")
OPTION( PrintAltHandlers,         OBJC_PRINT_ALT_HANDLERS,         "log processing of exception alt handlers")
OPTION( PrintReplacedMethods,     OBJC_PRINT_REPLACED_METHODS,     "log methods replaced by category implementations")
OPTION( PrintDeprecation,         OBJC_PRINT_DEPRECATION_WARNINGS, "warn about calls to deprecated runtime functions")
OPTION( PrintPoolHiwat,           OBJC_PRINT_POOL_HIGHWATER,       "log high-water marks for autorelease pools")
OPTION( PrintCustomRR,            OBJC_PRINT_CUSTOM_RR,            "log classes with un-optimized custom retain/release methods")
OPTION( PrintCustomAWZ,           OBJC_PRINT_CUSTOM_AWZ,           "log classes with un-optimized custom allocWithZone methods")
OPTION( PrintRawIsa,              OBJC_PRINT_RAW_ISA,              "log classes that require raw pointer isa fields")

OPTION( DebugUnload,              OBJC_DEBUG_UNLOAD,               "warn about poorly-behaving bundles when unloaded")
OPTION( DebugFragileSuperclasses, OBJC_DEBUG_FRAGILE_SUPERCLASSES, "warn about subclasses that may have been broken by subsequent changes to superclasses")
OPTION( DebugNilSync,             OBJC_DEBUG_NIL_SYNC,             "warn about @synchronized(nil), which does no synchronization")
OPTION( DebugNonFragileIvars,     OBJC_DEBUG_NONFRAGILE_IVARS,     "capriciously rearrange non-fragile ivars")
OPTION( DebugAltHandlers,         OBJC_DEBUG_ALT_HANDLERS,         "record more info about bad alt handler use")
OPTION( DebugMissingPools,        OBJC_DEBUG_MISSING_POOLS,        "warn about autorelease with no pool in place, which may be a leak")
OPTION( DebugPoolAllocation,      OBJC_DEBUG_POOL_ALLOCATION,      "halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools")
OPTION( DebugDuplicateClasses,    OBJC_DEBUG_DUPLICATE_CLASSES,    "halt when multiple classes with the same name are present")
OPTION( DebugDontCrash,           OBJC_DEBUG_DONT_CRASH,           "halt the process by exiting instead of crashing")

OPTION( DisableVtables,           OBJC_DISABLE_VTABLES,            "disable vtable dispatch")
OPTION( DisablePreopt,            OBJC_DISABLE_PREOPTIMIZATION,    "disable preoptimization courtesy of dyld shared cache")
OPTION( DisableTaggedPointers,    OBJC_DISABLE_TAGGED_POINTERS,    "disable tagged pointer optimization of NSNumber et al.") 
OPTION( DisableNonpointerIsa,     OBJC_DISABLE_NONPOINTER_ISA,     "disable non-pointer isa fields")
```
设置里面的任何一个变量为YES，即可观察对应的代码。下面笔者举个例子，查看awz的设置过程：
```
OPTION( PrintCustomAWZ,           OBJC_PRINT_CUSTOM_AWZ,           "log classes with un-optimized custom allocWithZone methods")
```
![](https://upload-images.jianshu.io/upload_images/1672498-84ca2f1ca5588472.png?imageMogr2/auto-orient/strip|imageView2/2/w/896)
运行项目可以看到xcode中有如下日志：
![](https://upload-images.jianshu.io/upload_images/1672498-23668db61d365860.png?imageMogr2/auto-orient/strip|imageView2/2/w/607)
全局搜索CUSTOM AWZ:可以看到日志打印函数在文件objc-runtime-new.mm中：
```
void 
objc_class::printCustomAWZ(bool inherited)
{
    assert(PrintCustomAWZ);
    assert(hasCustomAWZ());
    _objc_inform("CUSTOM AWZ:  %s%s%s", nameForLogging(), 
                 isMetaClass() ? " (meta)" : "", 
                 inherited ? " (inherited)" : "");
}
```
打断点查看其调用栈可以发现，其被`objc_class::setInitialized()`调用：
![](https://upload-images.jianshu.io/upload_images/1672498-9f674f99ae7a4f89.png?imageMogr2/auto-orient/strip|imageView2/2/w/1027)

##tls_init
用于初始化不是使用pthread_key_create()创建的线程的析构函数。
```
void tls_init(void)
{
    // 支持线程
#if SUPPORT_DIRECT_THREAD_KEYS
    _objc_pthread_key = TLS_DIRECT_KEY;
    // 设置线程析构函数
    pthread_key_init_np(TLS_DIRECT_KEY, &_objc_pthread_destroyspecific);
#else
    _objc_pthread_key = tls_create(&_objc_pthread_destroyspecific);
#endif
}
```

##static_init
方法实现执行 C++ 静态构造函数功能。这里应该是libc依赖的C++ 静态构造函数。我们自己的C++ 静态构造函数会由dyld进行加载。
```
/***********************************************************************
* static_init
* Run C++ static constructor functions.
* libc calls _objc_init() before dyld would call our static constructors, 
* so we have to do it ourselves.
**********************************************************************/
static void static_init()
{
    size_t count;
    // 获取所有构造器
    Initializer *inits = getLibobjcInitializers(&_mh_dylib_header, &count);
    // 执行静态构造函数
    for (size_t i = 0; i < count; i++) {
        inits[i]();
    }
}
```
static_init函数的作用是运行C++的静态构造函数。其原因在于dyld调用我们的静态构造函数晚于libc调用_objc_init函数。这句话咋一看比较难理解，更让人难以理解的是，在断点前并不是static_init函数，而是一个方法：_GLOBAL__sub_I_objc_runtime_new，笔者进入该断点看到如下内容：
![](https://upload-images.jianshu.io/upload_images/1672498-2b88e1c75ff3a9b4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1179)
可以看到，里面有好多类似于`__cxx_global_var_init`的方法。
那么，这些方法又是做什么的呢，这是本文讨论的问题。

为了解释上面的代码，我们做个实验。
在XCode的main.m文件中输入以下代码：
```
class Person{
public:
    Person(){
        printf("Person::Person()");
    }

    ~Person(){
        printf("Person::~Person()");
    }
};

Person kyson;

int main() {
    return 0;
}
```
执行后会打印如下结果：
```
Person::Person()Person::~Person()
```
说明执行了Person类的构造函数以及析构函数。如果读者对C++的构造函数以及析构函数还有任何疑问的话，可以大概了解一下C++的语法。笔者的侧重点在于，我们只是声明了：
```
Person kyson;
```
为什么会执行构造函数以及析构函数呢。稍微debug一下，我们居然发现，Person kyson;
这句代码居然比main()函数提前执行。让我们深入研究一下C++的全局变量。

###C++ 全局变量初始化
根据 C++ 标准([Working Draft, Standard for Programming Language C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf))，全局变量的初始化要在 main 函数执行前完成，常识无疑，但是这个说法有点含糊，main 函数执行前到底具体是什么时候呢？是编译时还是运行时？答案是既有编译时，也可能会有运行时, 从语言的层面来说，全局变量的初始化可以划分为以下两个阶段：

* static initialization: 静态初始化指的是用常量来对变量进行初始化,主要包括 zero initialization 和 const initialization，静态初始化在程序加载的过程中完成，对简单类型(内建类型，POD等)来说，从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量初始化基本是一致的。
* dynamic initialization：动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a = foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。

需要明确的是：静态初始化执行先于动态初始化。 只有当所有静态初始化执行完毕，动态初始化才会执行。显然，这样的设计是很直观的，能静态初始化的变量，它的初始值都是在编译时就能确定，因此可以直接硬编码到生成的代码里，而动态初始化需要在运行时执行相应的动作才能进行，因此，静态初始化先于动态初始化是必然的。

其他在main函数之前执行的代码：??

回到源码，可以看出，getLibobjcInitializers方法是它的实现主体，点击进入可以看到如下实现：
```
GETSECT(getLibobjcInitializers,       Initializer,     "__objc_init_func");
```
其中GETSECT是一个宏：
```
#define GETSECT(name, type, sectname)                                   \
type *name(const headerType *mhdr, size_t *outCount) {              \
    return getDataSection<type>(mhdr, sectname, nil, outCount);     \
}                                                                   \
type *name(const header_info *hi, size_t *outCount) {               \
    return getDataSection<type>(hi->mhdr(), sectname, nil, outCount); \
}
```
因此我们可以将以上代码展开如下：
```
Initializer *getLibobjcInitializers(const headerType *mhdr, size_t *outCount) {
    return getDataSection<Initializer>(mhdr, "__objc_init_func", nil, outCount);
}

Initializer *getLibobjcInitializers(const header_info *hi, size_t *outCount) {
    return getDataSection<Initializer>(hi->mhdr(), "__objc_init_func", nil, outCount);
}
```
getDataSection的代码如下：
```
// Look for a __DATA or __DATA_CONST or __DATA_DIRTY section 
// with the given name that stores an array of T.
template <typename T>
T* getDataSection(const headerType *mhdr, const char *sectname, 
                  size_t *outBytes, size_t *outCount)
{
    unsigned long byteCount = 0;
    T* data = (T*)getsectiondata(mhdr, "__DATA", sectname, &byteCount);
    if (!data) {
        data = (T*)getsectiondata(mhdr, "__DATA_CONST", sectname, &byteCount);
    }
    if (!data) {
        data = (T*)getsectiondata(mhdr, "__DATA_DIRTY", sectname, &byteCount);
    }
    if (outBytes) *outBytes = byteCount;
    if (outCount) *outCount = byteCount / sizeof(T);
    return data;
}

```
其实看注释就大概清楚，这是为了获取“区”的数据，那么什么是“区”，为什么要读取区的数据，本文将带大家细细品味。

###mach-o文件
要理解区，首先要了解苹果系统的可执行文件类型：[mach-o文件的维基百科](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FMach-O)。
>Mach-O文件
Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。作为a.out格式的替代，Mach-O提供了更强的扩展性，并提升了符号表中信息的访问速度。
Mach-O曾经为大部分基于Mach核心的操作系统所使用。NeXTSTEP，Darwin和Mac OS X等系统使用这种格式作为其原生可执行文件，库和目标代码的格式。而同样使用GNU Mach作为其微内核的GNU Hurd系统则使用ELF而非Mach-O作为其标准的二进制文件格式。

也就是说不论是iOS还是Mac中的可执行文件都是Mach-O类型的，有人说，不对啊，iOS的文件类型不是IPA么。但其实IPA真正是什么呢，我们可以再次看看[维基百科的定义](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FIpa%25E6%2596%2587%25E4%25BB%25B6)：

>ipa后缀的文件是iOS系统的软件包，全称为iPhone application archive。通常情况下，ipa文件都是使用苹果公司的FairPlayDRM技术进行加密保护的。每个IPA文件都是ARM架构的可执行文件以及该应用的资源文件的打包文件，只能安装在iPhone，iPod Touch或iPad上。该文件可以通过修改后缀名为zip后，进行解压缩，查看其软件包中的内容。

也就是说IPA文件其实是个压缩包，里面包含了Mach-O，即可执行文件。那既然如此，一个Mach-O文件是如何构成的呢，这个我们可以从苹果官网找到答案：

>Overview of the Mach-O Executable Format
Mach-O is the native executable format of binaries in OS X and is the preferred format for shipping code. An executable format determines the order in which the code and data in a binary file are read into memory. The ordering of code and data has implications for memory usage and paging activity and thus directly affects the performance of your program.
A Mach-O binary is organized into segments. Each segment contains one or more sections. Code or data of different types goes into each section. Segments always start on a page boundary, but sections are not necessarily page-aligned. The size of a segment is measured by the number of bytes in all the sections it contains and rounded up to the next virtual memory page boundary. Thus, a segment is always a multiple of 4096 bytes, or 4 kilobytes, with 4096 bytes being the minimum size.
The segments and sections of a Mach-O executable are named according to their intended use. The convention for segment names is to use all-uppercase letters preceded by double underscores (for example, __TEXT); the convention for section names is to use all-lowercase letters preceded by double underscores (for example, __text).
There are several possible segments within a Mach-O executable, but only two of them are of interest in relation to performance: the __TEXT segment and the __DATA segment.

以上摘自[Introduction to Code Size Performance Guidelines](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FPerformance%2FConceptual%2FCodeFootprint%2FCodeFootprint.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2F10000149-SW1)

当然纯文字总是难以建立形象。这里给出一张大家都在用的Mach-O的结构图：
![](https://upload-images.jianshu.io/upload_images/1672498-41f1bf5d1436c220.png?imageMogr2/auto-orient/strip|imageView2/2/w/344)
从这张图上来看，Mach-O文件的数据主体可分为三大部分，分别是头部（Header）、加载命令（Load commands）、和最终的数据（Data）。具体每个部分的含义这里不多做介绍了，后面的文章会慢慢为大家揭晓。这里仅需要知道，Data部分的某些SectionData我们可以往里面写入或者读取相应的数据。而对应的读方法是：
```
extern uint8_t *getsectiondata(
    const struct mach_header_64 *mhp,
    const char *segname,
    const char *sectname,
    unsigned long *size);
```
这就能理解我们文章开头提出的static_init()方法的含义了。其实就是找出__objc_init_func区的数据，获取了Initializer指针，然后按顺序调用。

###关于__objc_init_func区
**背景**
上一篇文章中我们说道，static_init方法使用到了区__objc_init_func区的数据，那么
* 如何设置、获取数据
* 区的作用是什么
* 如何查看一个可执行文件的区
* __objc_init_func是怎样的一个区

本文将给出详细分析。
**分析**

接着上一篇文章的Mach-O的文件构成的概念，我们继续深入讲解Mach-O的构成，首先还是那张图：
![](https://upload-images.jianshu.io/upload_images/1672498-517d64e07179fe92.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)
这里不得不提到一个优秀的查看Mach-O文件内部构成的软件：[MachOView]( https://git.code.sf.net/p/machoview/code)

**Header**
Header 中记录了 Mach-O 文件的属性信息，其数据结构定义在 loader.h中，分为32位以及64位：
32位：
```
/*
* The 32-bit mach header appears at the very beginning of the object file for
* 32-bit architectures.
*/
struct mach_header {
uint32_t    magic;  /* mach magic number identifier */
cpu_type_t  cputype;    /* cpu specifier */
cpu_subtype_t   cpusubtype; /* machine specifier */
uint32_t    filetype;   /* type of file */
uint32_t    ncmds;  /* number of load commands */
uint32_t    sizeofcmds; /* the size of all the load commands */
uint32_t    flags;  /* flags */
};
/* Constant for the magic field of the mach_header (32-bit architectures) */
#define MH_MAGIC    0xfeedface  /* the mach magic number */
#define MH_CIGAM    0xcefaedfe  /* NXSwapInt(MH_MAGIC) */
```
64位：
```
/*
* The 64-bit mach header appears at the very beginning of object files for
* 64-bit architectures.
*/
struct mach_header_64 {
uint32_t    magic;  /* mach magic number identifier */
cpu_type_t  cputype;    /* cpu specifier */
cpu_subtype_t   cpusubtype; /* machine specifier */
uint32_t    filetype;   /* type of file */
uint32_t    ncmds;  /* number of load commands */
uint32_t    sizeofcmds; /* the size of all the load commands */
uint32_t    flags;  /* flags */
uint32_t    reserved;   /* reserved */
};
/* Constant for the magic field of the mach_header_64 (64-bit architectures) */
#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */
#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */
```
这里每个字段的意思如下：
![](https://upload-images.jianshu.io/upload_images/1672498-fcdf841f40ac26fb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)
因此简单总结一下就是 Headers 能帮助校验 Mach-O 合法性和定位文件的运行环境。

**Load commands**
Load commands 紧随在 Header 后，它包含了一系列的加载命令，目的是向操作系统描述如何处理 Mach-O 文件。
Load Commands 是跟在 Header 后面的加载命令区，所有 commands 的大小总和即为 Header->sizeofcmds 字段，共有 Header->ncmds 条加载命令。
```
struct load_command {
    uint32_t cmd;        /* type of load command */
    uint32_t cmdsize;    /* total size of command in bytes */
};
```
**Segment**
Mach-O 文件有多个段（Segment），每个段有不同的功能。然后每个段又分为很多小的 Section。 LC_SEGMENT 意味着这部分文件需要映射到进程的地址空间去。一般有以下段名：
__PAGEZERO:　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。
__TEXT:　包含了执行代码以及其他只读数据。该段数据可以 VM_PROT_READ(读)、VM_PROT_EXECUTE(执行)，不能被修改。
__DATA:　程序数据，该段可写 VM_PROT_WRITE/READ/EXECUTE。
__LINKEDIT:　链接器使用的符号以及其他表。
```
struct segment_command { /* for 32-bit architectures */
    uint32_t    cmd;        /* LC_SEGMENT */
    uint32_t    cmdsize;    /* includes sizeof section structs */
    char        segname[16];    /* segment name */
    uint32_t    vmaddr;     /* memory address of this segment 段的虚拟内存地址*/
    uint32_t    vmsize;     /* memory size of this segment  段的虚拟内存大小*/
    uint32_t    fileoff;    /* file offset of this segment  段在文件中的偏移量*/
    uint32_t    filesize;   /* amount to map from the file  段在文件中的大小*/
    vm_prot_t   maxprot;    /* maximum VM protection */
    vm_prot_t   initprot;   /* initial VM protection */
    uint32_t    nsects;     /* number of sections in segment */
    uint32_t    flags;      /* flags */
};
struct segment_command_64 { /* for 64-bit architectures */
    uint32_t    cmd;        /* LC_SEGMENT_64 */
    uint32_t    cmdsize;    /* includes sizeof section_64 structs */
    char        segname[16];    /* segment name */
    uint64_t    vmaddr;     /* memory address of this segment */
    uint64_t    vmsize;     /* memory size of this segment */
    uint64_t    fileoff;    /* file offset of this segment */
    uint64_t    filesize;   /* amount to map from the file */
    vm_prot_t   maxprot;    /* maximum VM protection */
    vm_prot_t   initprot;   /* initial VM protection */
    uint32_t    nsects;     /* number of sections in segment */
    uint32_t    flags;      /* flags */
};
```
其中 nsects 字段就是表明该段中有多少个 section。文件映射的起始位置是由 fileoff 给出，映射到地址空间的 vmaddr 处。

**Section**
Section 是具体有用的数据存放的地方。它的结构体跟随在 LC_SEGMENT 结构体之后，LC_SEGMENT 又在 Load Commands 中，但是 segment 的数据内容是跟在 Load Commands 之后的。它的结构体为：
```
struct section { /* for 32-bit architectures */
    char        sectname[16];   /* name of this section */
    char        segname[16];    /* segment this section goes in */
    uint32_t    addr;       /* memory address of this section 该节在内存中的起始位置*/
    uint32_t    size;       /* size in bytes of this section 该节的大小*/
    uint32_t    offset;     /* file offset of this section 该节的文件偏移*/
    uint32_t    align;      /* section alignment (power of 2) 字节大小对齐*/
    uint32_t    reloff;     /* file offset of relocation entries 重定位入口的文件偏移*/
    uint32_t    nreloc;     /* number of relocation entries 需要重定位的入口数量*/
    uint32_t    flags;      /* flags (section type and attributes) */
    uint32_t    reserved1;  /* reserved (for offset or index) */
    uint32_t    reserved2;  /* reserved (for count or sizeof) */
};
struct section_64 { /* for 64-bit architectures */
    char        sectname[16];   /* name of this section */
    char        segname[16];    /* segment this section goes in */
    uint64_t    addr;       /* memory address of this section */
    uint64_t    size;       /* size in bytes of this section */
    uint32_t    offset;     /* file offset of this section */
    uint32_t    align;      /* section alignment (power of 2) */
    uint32_t    reloff;     /* file offset of relocation entries */
    uint32_t    nreloc;     /* number of relocation entries */
    uint32_t    flags;      /* flags (section type and attributes)*/
    uint32_t    reserved1;  /* reserved (for offset or index) */
    uint32_t    reserved2;  /* reserved (for count or sizeof) */
    uint32_t    reserved3;  /* reserved */
};
```
其中 flag 字段分为两个部分，一个是区域类型（section type），一个是区域属性（section attributes）。其中 type 是互斥的，即只能有一个类型，而 attributes 不是互斥的，可以有多个属性。如果段（segment）中的任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都必须拥有这个属性。具体的flag字段内容以及意义请参考 /usr/include/mach-o/loader.h。

段名为大写，节名为小写。各节的作用主要有：

__text:　主程序代码
__stub_helper:　用于动态链接的存根
__symbolstub1:　用于动态链接的存根
__objc_methname:　Objective-C 的方法名
__objc_classname:　Objective-C 的类名
__cstring:　硬编码的字符串

__lazy_symbol:　懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接
_got:　存储引用符号的实际地址，类似于动态符号表
__nl_symbol_ptr:　非延迟加载节
__mod_init_func:　初始化的全局函数地址，在 main 之前被调用
__mod_term_func:　结束函数地址
__cfstring:　Core Foundation 用到的字符串（OC字符串）

__objc_clsslist:　Objective-C 的类列表
__objc_nlclslist:　Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行
__objc_const:　Objective-C 的常量
__data:　初始化的可变的变量
__bss:　未初始化的静态变量

这里我们并没有看到__objc_init_func,而是只有类似的__mod_init_func区。那么__objc_init_func是哪里来的呢？

全局搜索一下__objc_init_func，可以发现在markgc.cpp中有如下代码：
```
template <typename P>
void dosect(uint8_t *start, macho_section<P> *sect)
{
    if (debug) printf("section %.16s from segment %.16s\n",
                      sect->sectname(), sect->segname());

    // Strip S_MOD_INIT/TERM_FUNC_POINTERS. We don't want dyld to call 
    // our init funcs because it is too late, and we don't want anyone to 
    // call our term funcs ever.
    if (segnameStartsWith(sect->segname(), "__DATA")  &&  
        sectnameEquals(sect->sectname(), "__mod_init_func"))
    {
        // section type 0 is S_REGULAR
        sect->set_flags(sect->flags() & ~SECTION_TYPE);
        sect->set_sectname("__objc_init_func");
        if (debug) printf("disabled __mod_init_func section\n");
    }
    if (segnameStartsWith(sect->segname(), "__DATA")  &&  
        sectnameEquals(sect->sectname(), "__mod_term_func"))
    {
        // section type 0 is S_REGULAR
        sect->set_flags(sect->flags() & ~SECTION_TYPE);
        sect->set_sectname("__objc_term_func");
        if (debug) printf("disabled __mod_term_func section\n");
    }
}
```
这段方法凭借我们读者的慧眼肯定能轻易看出，作用是将区__mod_init_func替换成__objc_init_func。
瞬间豁然开朗。

那么有会有朋友问，该markgc.cpp文件是何时被调用，并被写进runtime库的，这个又是一段故事了，请听笔者下回分解。

最后我们写个Demo 来设置区数据，并获取区数据：
```
#import <Foundation/Foundation.h>
#import <dlfcn.h>
#include <mach-o/loader.h>
#include <mach-o/getsect.h>

#ifndef __LP64__
#define mach_header mach_header
#else
#define mach_header mach_header_64
#endif

const struct mach_header *machHeader = NULL;
static NSString *configuration = @"";
//设置"__DATA,__customSection"的数据为kyson
char *kString __attribute__((section("__DATA,__customSection"))) = (char *)"kyson";

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //设置machheader信息
        if (machHeader == NULL)
        {
            Dl_info info;
            dladdr((__bridge const void *)(configuration), &info);
            machHeader = (struct mach_header_64*)info.dli_fbase;
        }

        unsigned long byteCount = 0;
        uintptr_t* data = (uintptr_t *) getsectiondata(machHeader, "__DATA", "__customSection", &byteCount);
        NSUInteger counter = byteCount/sizeof(void*);
        for(NSUInteger idx = 0; idx < counter; ++idx)
        {
            char *string = (char*)data[idx];
            NSString *str = [NSString stringWithUTF8String:string];
            NSLog(@"%@",str);
        }

    }
    return 0;
}
```
这里有几个知识点：
* \_\_attribute__
* dladdr
* dladdr

关于__attribute__的用法这里不再展开。
>This section describes the syntax with which __attribute__ may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.
There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, typeid does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.
>\_\_attribute__可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。它的书写特征是：__attribute__前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的__attribute__参数，语法格式如下：
\_\_attribute__((attribute-list))
另外，它必须放于声明的尾部“；”之前。

再如[ 不使用 NSOBJECT 的 OBJECTIVE-C CLASS](https://links.jianshu.com/go?to=https%3A%2F%2Furanusjr.com%2Fblog%2Fpost%2F53%2Fobjective-c-class-without-nsobject%2F)

这里使用的是另外一个属性：
```
__attribute__((section("__DATA,__customSection"))) 
```
明显看出，是声明的一个变量属性。
这个变量要“被放到” section为“__DATA,__customSection”里面。这么一来就不难理解了。

dladdr
使用dladdr方法可以获得一个函数所在模块，名称以及地址。
```
if (machHeader == NULL)
{
    Dl_info info;
    dladdr((__bridge const void *)(configuration), &info);
    machHeader = (struct mach_header_64*)info.dli_fbase;
}
```
这段代码的用途仅仅是为了获取header。至于header前面的 文章也提到过了，这里不多做讲解了，拿到的header作为函数getsectiondata的参数：
```
uintptr_t* data = (uintptr_t *) getsectiondata(machHeader, "__DATA", "__customSection", &byteCount);
```
这里需要注意的是getsectiondata的定义如下：
```
extern uint8_t *getsectiondata(
    const struct mach_header_64 *mhp,
    const char *segname,
    const char *sectname,
    unsigned long *size);
```
最后我们查看一下打印的结果：
![](https://upload-images.jianshu.io/upload_images/1672498-a7f99ddc235d5c55.png?imageMogr2/auto-orient/strip|imageView2/2/w/524)

###runtime编译过程
上一篇文章我们讲到runtime库中区__objc_init_func替代了区__mod_init_func。因此我们在runtime编译好的库文件中看不到区__mod_init_func：
![](https://upload-images.jianshu.io/upload_images/1672498-1fe4b1bdc099c2bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)

那么这个替换的过程是怎么进行的呢，本文将为读者分析。

**分析**

大家知道，库的编译参数都是在target中进行设置的，如图：
![](https://upload-images.jianshu.io/upload_images/1672498-ada629094e3e58ea.png?imageMogr2/auto-orient/strip|imageView2/2/w/964)
如图，如果我们设置
EXECUTABLE_PREFIX 为libbb那么库文件的前缀就是libbb，
PRODUCT_NAME 为 objc.AB那么紧跟着的就是objc.AB了，不难得出，最终的文件名为：
![](https://upload-images.jianshu.io/upload_images/1672498-a271111e160b0922.png?imageMogr2/auto-orient/strip|imageView2/2/w/243)
接着我们看其他编译参数，主要是如图所示位置：
![](https://upload-images.jianshu.io/upload_images/1672498-d58616d340097e4e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1146)
复制下来如下：
```
set -x
/usr/bin/xcrun -sdk macosx clang++ -Wall -mmacosx-version-min=10.9 -arch x86_64 -std=c++11 "${SRCROOT}/markgc.cpp" -o "${BUILT_PRODUCTS_DIR}/markgc"
"${BUILT_PRODUCTS_DIR}/markgc" "${BUILT_PRODUCTS_DIR}/libobjc.A.dylib"
```
根据我们对clang的了解，这句命令应该不难理解。
set x
略过，应该是设置环境变量之类的操作。

```
/usr/bin/xcrun -sdk macosx clang++ -Wall -mmacosx-version-min=10.9 -arch x86_64 -std=c++11 "${SRCROOT}/markgc.cpp" -o "${BUILT_PRODUCTS_DIR}/markgc"
"${BUILT_PRODUCTS_DIR}/markgc" "${BUILT_PRODUCTS_DIR}/libobjc.A.dylib"
```
可以看出是调用的xcrun命令，关于xcrun，其实大家可以理解为xcodebuild命令的老版本.

这里几个参数大概介绍一下：
-sdk macosx
意思就是运行平台在mac上
-mmacosx-version-min=10.9
是指定mac的最低版本
-arch x86_64
指定平台是x86_64

```
"${SRCROOT}/markgc.cpp"
```
指明编译的文件

```
-o "${BUILT_PRODUCTS_DIR}/markgc"
"${BUILT_PRODUCTS_DIR}/markgc" "${BUILT_PRODUCTS_DIR}/libobjc.A.dylib"
```
指明输出目录以及文件名。

因此不难看出，这里脚本的含义就是对编译后的runtime再进行读取，并编译markgc的过程。而在编译markgc的时候再进行了对区__objc_init_func替代区__mod_init_func的操作。

###markgc.cpp
**背景**
上一篇文章中，我们分析了markgc.cpp在runtime编译过程中的作用：将mod_init_func的区名改为了__objc_init_func。但是我们没有具体分析这个文件的替换原理。今天，我们就来分析一下markgc.cpp：
![](https://upload-images.jianshu.io/upload_images/1672498-b997150e0e58514b.png?imageMogr2/auto-orient/strip|imageView2/2/w/942)
通过本文，您将知道：
* 如何设置区数据
* 如何读取区数据
* 如何设置区名

**分析**

之前的文章中我们已经说过了，section其实是在segment中的，我们再通过machview看一下runtime库的文件构成：
![](https://upload-images.jianshu.io/upload_images/1672498-03e26c099139660b.png?imageMogr2/auto-orient/strip|imageView2/2/w/800)
因此如果我们想要替换mod_init_func的section名改为__objc_init_func，思路应该是先遍历并找到mod_init_func，然后通过方法sectionname将section名字进行更改。
按照此思路，我们从头到尾开始分析一下markgc.cpp：
首先是main方法：
```
int main(int argc, const char *argv[]) {
    for (int i = 1; i < argc; ++i) {
        if (!processFile(argv[i])) return 1;
    }
    return 0;
}
```
由上一篇文章我们可知，传入的参数是库文件的文件名（连同路径）。
拿到文件后，调用了方法processFile，看名字可知这是要处理这个文件了。
```
bool processFile(const char *filename)
{
    if (debug) printf("file %s\n", filename);
//打开文件
    int fd = open(filename, O_RDWR);
    if (fd < 0) {
        printf("open %s: %s\n", filename, strerror(errno));
        return false;
    }
    
    struct stat st;
//获取文件状态
    if (fstat(fd, &st) < 0) {
        printf("fstat %s: %s\n", filename, strerror(errno));
        return false;
    }
//将文件映射进内存进行处理
    void *buffer = mmap(NULL, (size_t)st.st_size, PROT_READ|PROT_WRITE, 
                        MAP_FILE|MAP_SHARED, fd, 0);
    if (buffer == MAP_FAILED) {
        printf("mmap %s: %s\n", filename, strerror(errno));
        return false;
    }
//开始处理进入内存后的文件
    bool result = parse_fat((uint8_t *)buffer, (size_t)st.st_size);
//解除映射关系
    munmap(buffer, (size_t)st.st_size);
    close(fd);
    return result;
}
```
上面代码笔者已经进行了部分注释，大概意思就是先将编译好的runtime库映射进内存进行处理，处理完后解除映射。至于这里为什么要读入内存，笔者知道的一个原因是mmap()对该内存区域的存取即是直接对该文件内容的读写。因此这样一来就省去了读取后再重新保存文件的做法。
在以上方法中有个函数调用是用来处理该文件的：
```
    bool result = parse_fat((uint8_t *)buffer, (size_t)st.st_size);
```
的parse_fat，从文件名可以看出，是用来解析fat文件的。关于fat之前已经说过，fat文件是“胖文件”的意思，胖文件就是已经适配了各种架构的处理器（主要是i386和arm）。我们继续进入该方法进行分析：
```
bool parse_fat(uint8_t *buffer, size_t size)
{
    uint32_t magic;

    if (size < sizeof(magic)) {
        printf("file is too small\n");
        return false;
    }

    magic = *(uint32_t *)buffer;
    if (magic != FAT_MAGIC && magic != FAT_CIGAM) {
        /* Not a fat file */
        return parse_macho(buffer);
    } else {
        struct fat_header *fh;
        uint32_t fat_magic, fat_nfat_arch;
        struct fat_arch *archs;
        
        if (size < sizeof(struct fat_header)) {
            printf("file is too small\n");
            return false;
        }

        fh = (struct fat_header *)buffer;
        fat_magic = OSSwapBigToHostInt32(fh->magic);
        fat_nfat_arch = OSSwapBigToHostInt32(fh->nfat_arch);

        if (size < (sizeof(struct fat_header) + fat_nfat_arch * sizeof(struct fat_arch))) {
            printf("file is too small\n");
            return false;
        }

        archs = (struct fat_arch *)(buffer + sizeof(struct fat_header));

        /* Special case hidden CPU_TYPE_ARM64 */
        if (size >= (sizeof(struct fat_header) + (fat_nfat_arch + 1) * sizeof(struct fat_arch))) {
            if (fat_nfat_arch > 0
                && OSSwapBigToHostInt32(archs[fat_nfat_arch].cputype) == CPU_TYPE_ARM64) {
                fat_nfat_arch++;
            }
        }
        /* End special case hidden CPU_TYPE_ARM64 */

        if (debug) printf("%d fat architectures\n", 
                          fat_nfat_arch);

        for (uint32_t i = 0; i < fat_nfat_arch; i++) {
            uint32_t arch_cputype = OSSwapBigToHostInt32(archs[i].cputype);
            uint32_t arch_cpusubtype = OSSwapBigToHostInt32(archs[i].cpusubtype);
            uint32_t arch_offset = OSSwapBigToHostInt32(archs[i].offset);
            uint32_t arch_size = OSSwapBigToHostInt32(archs[i].size);

            if (debug) printf("cputype %d cpusubtype %d\n", 
                              arch_cputype, arch_cpusubtype);

            /* Check that slice data is after all fat headers and archs */
            if (arch_offset < (sizeof(struct fat_header) + fat_nfat_arch * sizeof(struct fat_arch))) {
                printf("file is badly formed\n");
                return false;
            }

            /* Check that the slice ends before the file does */
            if (arch_offset > size) {
                printf("file is badly formed\n");
                return false;
            }

            if (arch_size > size) {
                printf("file is badly formed\n");
                return false;
            }

            if (arch_offset > (size - arch_size)) {
                printf("file is badly formed\n");
                return false;
            }

            bool ok = parse_macho(buffer + arch_offset);
            if (!ok) return false;
        }
        return true;
    }
}
```
以上代码大部分都是为了去校验合法性，真正起作用的其实是方法调用：
```
bool ok = parse_macho(buffer + arch_offset);
```
可以看出，刚刚是解析胖文件，现在开始解析我们的mach-o文件了：
```
template<typename P>
bool parse_macho(uint8_t *buffer)
{
    macho_header<P>* mh = (macho_header<P>*)buffer;
    uint8_t *cmds = (uint8_t *)(mh + 1);
    for (uint32_t c = 0; c < mh->ncmds(); c++) {
        macho_load_command<P>* cmd = (macho_load_command<P>*)cmds;
        cmds += cmd->cmdsize();
        if (cmd->cmd() == LC_SEGMENT  ||  cmd->cmd() == LC_SEGMENT_64) {
            doseg(buffer, (macho_segment_command<P>*)cmd);
        }
    }

    return true;
}

```
由上一篇文章我们知道，通过结构体macho_header我们知道了命令的数目，通过结构体的ncmds的属性。我们在machview中也可以看到对应的展示：
![](https://upload-images.jianshu.io/upload_images/1672498-9181afa8245f15d5.png?imageMogr2/auto-orient/strip|imageView2/2/w/850)
 所以以上代码不难看出其实是开始遍历每个命令，并调用
```
 doseg(buffer, (macho_segment_command<P>*)cmd);
```
 方法：
```
 template <typename P>
void doseg(uint8_t *start, macho_segment_command<P> *seg)
{
    if (debug) printf("segment name: %.16s, nsects %u\n",
                      seg->segname(), seg->nsects());
    macho_section<P> *sect = (macho_section<P> *)(seg + 1);
    for (uint32_t i = 0; i < seg->nsects(); ++i) {
        dosect(start, &sect[i]);
    }
}
```
 仍然是遍历所有的sections，然后调用方法：
```
 dosect(start, &sect[i]);
```
 这里终于到了我们熟悉的替换sectionname的方法了：
```
 template <typename P>
void dosect(uint8_t *start, macho_section<P> *sect)
{
    if (debug) printf("section %.16s from segment %.16s\n",
                      sect->sectname(), sect->segname());

    // Strip S_MOD_INIT/TERM_FUNC_POINTERS. We don't want dyld to call 
    // our init funcs because it is too late, and we don't want anyone to 
    // call our term funcs ever.
    if (segnameStartsWith(sect->segname(), "__DATA")  &&  
        sectnameEquals(sect->sectname(), "__mod_init_func"))
    {
        // section type 0 is S_REGULAR
        sect->set_flags(sect->flags() & ~SECTION_TYPE);
        sect->set_sectname("__objc_init_func");
        if (debug) printf("disabled __mod_init_func section\n");
    }
    if (segnameStartsWith(sect->segname(), "__DATA")  &&  
        sectnameEquals(sect->sectname(), "__mod_term_func"))
    {
        // section type 0 is S_REGULAR
        sect->set_flags(sect->flags() & ~SECTION_TYPE);
        sect->set_sectname("__objc_term_func");
        if (debug) printf("disabled __mod_term_func section\n");
    }
}
```
**总结**
 其实思路很简单，就是遍历segments，然后遍历sections，找到section __mod_init_func并将其名字改掉。画个图总结一下吧：
![](https://upload-images.jianshu.io/upload_images/1672498-4f36bb518e4080d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/320)

##lock_init
编码后台线程和主线程优先级
```
void lock_init(void)
{
#if SUPPORT_QOS_HACK
    // 将类优先级对编码为线程优先级
    BackgroundPriority = _pthread_qos_class_encode(QOS_CLASS_BACKGROUND, 0, 0);
    MainPriority = _pthread_qos_class_encode(qos_class_main(), 0, 0);
# if DEBUG
    pthread_key_init_np(QOS_KEY, &destroyQOSKey);
# endif
#endif
}
```

##exception_init
方法是初始化了libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理。

##_dyld_objc_notify_register
注册镜像映射、加载镜像、卸载镜像映射，此方法涉及类的加载，初始化过程。该函数的实现，我们在前面dyld的章节中已经接触过了：
```
void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,
                                _dyld_objc_notify_init      init,
                                _dyld_objc_notify_unmapped  unmapped)
{
    dyld::registerObjCNotifiers(mapped, init, unmapped);
}
```


##参考
iOS开发之runtime（7）：日志打印系统分析
https://www.jianshu.com/p/2085575edfe4

iOS开发之runtime（9）：_objc_init()了解一下
https://www.jianshu.com/p/ea6ff51689b6

iOS开发之runtime（10）：从C++看static_init()
https://www.jianshu.com/p/d0dbf1289f70

iOS开发之runtime（11）：深入理解static_init()
https://www.jianshu.com/p/d3b5236e3c62

iOS开发之runtime（12）：关于__objc_init_func区
https://www.jianshu.com/p/8c6610a5f6d4

iOS开发之runtime（13）：runtime编译过程
https://www.jianshu.com/p/b54ad5d899ac

iOS开发之runtime（14）：markgc.cpp源码分析
https://www.jianshu.com/p/5f0973cf5255

按下 ⌘ + R 后发生的事情
https://blog.boolchow.com/2018/03/10/Press-Command-R/

如何精确度量 iOS App 的启动时间
https://www.jianshu.com/p/c14987eee107