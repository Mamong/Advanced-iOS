第五章 基本引用类型

[TOC]

# 5.1 Date

# 5.2 RegExp

# 5.3 原始值包装类型
为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型:Boolean、Number 和 String。这种行为可以让原始值拥有对象的行为。

引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。

## 5.3.1 Boolean
Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调 用时也会被覆盖，返回字符串"true" 或 "false"。

在布尔表达式中使用 Boolean 对象时,容易引起误会:
```
let falseObject = new Boolean(false);
let result = falseObject && true;
console.log(result); // true
let falseValue = false;
result = falseValue && true;
console.log(result); // false
```

理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。

## 5.3.2 Number
Number 类型重写了 valueOf()、toLocaleString()和 toString()方 法。valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串.

toFixed()方法返回包含指定小数点位数的数值字符串。 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为 "10.00"，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。

toExponential()，返回以科学记数法(也称为指数记数法)表 示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。

toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法 形式。这个方法接收一个参数，表示结果中数字的总位数(不包含指数)。

isInteger()方法与安全整数
ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0
可能会让人误以为数值是一个浮点值:
```
console.log(Number.isInteger(1));    // true
console.log(Number.isInteger(1.00)); // true
console.log(Number.isInteger(1.01)); // false
```
IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法。

## 5.3.3 String
1.JavaScript 字符
JavaScript 字符串由 16 位码元(code unit)组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元。

charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方 法查找指定索引位置的 16 位码元，并返回该码元对应的字符。

charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。

fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意 多个数值，并返回将所有数值对应的字符拼接起来的字符串。

Unicode 增补字符平面
对于 U+0000~U+FFFF 范围内的字符，length、charAt()、charCodeAt()和 fromCharCode() 返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用 16 位表示的，而这几个方法 也都基于 16 位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。
这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。问题很简单，即 16 位只能唯一表示 65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面(BMP)。为了 表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个 字符使用两个 16 位码元的策略称为代理对。


codePointAt()来代替 charCodeAt()，可以正确解析既包含单码元字符又包含代理对字符的字符串。

与 charCodeAt()有对应的 codePointAt()一样，fromCharCode()也有一个对应的 fromCodePoint()。 10 这个方法接收任意数量的码点，返回对应字符拼接起来的字符串。

2.normalize()方法
某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一 个代理对表示。比较操作符不在乎字符看起来是什么样的，因此这 3 个字符互不相等。

为解决这个问题，Unicode 提供了 4 种规范化形式，可以将类似上面的字符规范化为一致的格式，无论 底层字符的代码是什么。这 4 种规范化形式是:NFD(Normalization Form D)、NFC(Normalization Form C)、 NFKD(Normalization Form KD)和 NFKC(Normalization Form KC)。可以使用 normalize()方法对字 符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串:"NFD"、"NFC"、"NFKD"或"NFKC"。

3.字符串操作方法
concat()，用于将一个或多个字符串拼接成一个新字符串。

ECMAScript 提供了 3 个从字符串中提取子字符串的方法:slice()、substr()和 substring()。

这 3 个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是提取结束的位置(即该位置之前的字符会被提取出来)。对 substr()而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。

当某个参数是负值时，这 3 个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字 符串长度加上负参数值。而 substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0。substring()方法会将所有负参数值都转换为 0。

|函数|第一个参数为负|第二个参数为负|第二个参数意义|
|----|----|----|----|
|slice|加长度|加长度|结束位置|
|substring|0|0|结束位置|
|substr|加长度|0|子字符串数量|


4.字符串位置方法
有两个方法用于在字符串中定位子字符串:indexOf()和 lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置(如果没找到，则返回-1)。两者的区别在于，indexOf()方法 从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。

5.字符串包含方法
ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法:startsWith()、 endsWith()和 includes()。

6.trim()方法
ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、 后所有空格符，再返回结果。

7.repeat()方法
ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字 13 符串复制多少次，然后返回拼接所有副本后的结果。

8.padStart()和 padEnd()方法
padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至
满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格 (U+0020)。

9.字符串迭代与解构
字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。在 for-of 循环中可以通过这个迭代器按序访问每个字符

10.字符串大小写转换
大小写转换，包括 4 个方法:toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()。

11.字符串模式匹配方法
match()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字 符串，也可以是一个 RegExp 对象。

search()这个方法唯一的参数与match()方法一样:正则表达 式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。search() 始终从字符串开头向后匹配模式。

replace()方法，这个方法接收两个参数，第一个 参数可以是一个 RegExp 对象或一个字符串(这个字符串不会转换为正则表达式)，第二个参数可以是 一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记。

split()。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。(字符串分隔符不会被这个方法当成 正则表达式。)还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。


12.localeCompare()方法
最后一个方法是 localeCompare()，这个方法比较两个字符串，返回如下 3 个值中的一个。
 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。(通常是-1，具体还要看
与实际值相关的实现。)
 如果字符串与字符串参数相等，则返回 0。
 如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。(通常是 1，具体还要看与实际值相关的实现。)


13.HTML 方法

# 5.4 单例内置对象
ECMA-262 规定 Global 对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。本书前面介绍的函数， 包括 isNaN()、isFinite()、parseInt()和 parseFloat()，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。

## 5.4.1 Global
1. URL 编码方法
2. eval()方法
3. Global 对象属性
undefined，NaN，Infinity和一些对象的构造函数
4. window 对象
浏览器将 window 对象实现为 Global 对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。

## 5.4.2 Math
1. Math 对象属性
Math 对象有一些属性，主要用于保存数学中的一些特殊值。
2. min()和 max()方法
3. 舍入方法
接下来是用于把小数值舍入为整数的 4 个方法:Math.ceil()、Math.floor()、Math.round() 和 Math.fround()。
4. random()方法
Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1.
5. 其他方法
Math 对象还有很多涉及各种简单或高阶数运算的方法。