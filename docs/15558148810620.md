第七章 确保Web安全的HTTPS

[TOC]

##7.1 HTTP的缺点
通信使用明文，不加密，内容可能会被窃听
不验证通信方的身份，可能遭遇伪装
无法验证报文的完整性，可能已遭篡改

###7.1.1通信使用明文可能会被窃听
1.TCP/IP是可能被窃听的网络
2.加密处理防止被窃听
通信加密：HTTP协议中没有加密机制，可以通过和SSL（secure socket layer，安全套接字层）或TLS（transport layer security，安全层传输协议）的组合使用，加密HTTP的通信内容。用SSL建立安全通信线路后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP叫HTTPS（HTTP secure，超文本传输安全协议）或HTTP over SSL。

内容加密：将参与通信的内容本身进行加密的方式。即把HTTP报文里所含的内容（报文主体）进行加密处理。

###7.1.2不验证通信方的身份就可能遭遇伪装
HTTP协议中的请求和响应不会对通信方进行确认。
1.任何人都可以发起请求
无法确认请求发送至目标的web服务器是否按真实意图返回响应的那台服务器。有可能是已伪装的web服务器。
无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
无法确定正在通信的对方是否具备访问权限。服务器上保存的某些信息指向发给特定的用户。
无法判断请求来自何方，出自谁手。
即使无意义的请求也会照单全收。无法阻止海量请求下的Dos攻击。
2.查明对方的证书
证书由值得信任的第三方机构颁发，用以证明服务器和客户端是真实存在的。伪造证书异常困难，只要能确认通信方持有的证书，就可判断通信方的真实意图。
使用证书可以减少个人信息泄露的危险。客户端持有证书即可完成个人身份的确认，也可用于web网站的认证环节。

###7.1.3无法证明报文的完整性，可能已遭篡改
完整性是指信息的准确度。
1.接收到的内容可能有误。没办法确认发出的请求/响应和接收到的请求/响应是前后相同的。在传输过程中被攻击者拦截并篡改内容的攻击叫中间人攻击（Man-in-the-middle attack）。
2.如何防止篡改
虽然有使用HTTP协议确定报文完整性的方法，但并不便捷可靠。常用的是MD5和SHA1等散列值校验的方法，以及用来确认文件的数字签名方法。
也有PGP和MD5本身被改写的危险。
为了有效防止这些弊端，有必要使用HTTPS。SSL提供认证和加密处理及摘要功能。

##7.2 HTTP+加密+认证+完整性保护=HTTPS
###7.2.1 HTTP+加密+认证+完整性保护=HTTPS
HTTP协议通信使用明文，可能会遭窃听。HTTP没办法确认通信方，有可能并不是和原本预想的通信方在实际通信。报文可能中途被篡改。为了解决这些问题，需要在HTTP上再加入加密处理和认证等机制。我们把添加了加密和认证机制的HTTP称为HTTPS。

###7.2.2 HTTPS是身披SSL外壳的HTTP
HTTPS是HTTP通信接口部分用SSL和TLS协议代替。通常HTTP直接和TCP通信。当使用SSL时，演变为先和SSL通信，再由SSL和TCP通信了。在采用SSL后，HTTP就拥有了加密、证书和完整性保护这些功能了。SSL是独立于HTTP的协议，其他应用层协议，例如SMTP和Telnet也可以配合SSL协议使用。

###7.2.3 相互交换密钥的公开密钥加密技术
SSL采用公开密钥加密（public-key cryptography）的加密处理方式。
近代加密方法是加密算法公开，密钥保密的。
加密和解密都需要密钥。
1.共享密钥加密的困境。
加密和解密用同一个密钥的方式称为共享密钥加密（common key crypto system），也叫对称密钥加密。
需要将密钥发给对方，途中可能会被监听、泄露。另外还得安全地保管接收到的密钥。
2.使用两把密钥的公开密钥加密
公开密钥加密很好地解决了共享密钥加密的困难。
公开密钥加密使用一对非对称的密钥。一把叫私有密钥，private key。另一把加公开密钥，public key。私钥不能让其他任何人知道，公钥可以随意发布，任何人都可以获得。
使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，接收方收到被加密信息后，再使用自己的私钥进行解密。利用这种方式，不需要发送用来解密的私钥，也不必担心密钥被攻击者窃听而盗走。
另外根据密文和公开密钥，恢复信息原文是异常困难的。
3.HTTPS采用混合加密机制
公开密钥与共享密钥相比，处理速度比较慢。因此在交换密钥环节使用公开密钥加密方式，之后建立通信交换报文阶段则使用共享密钥加密方式。

###7.2.4 证明公开密钥正确性的证书
公开密钥加密方式无法证明公开密钥本身是货真价实的公开密钥。公开密钥传输途中可能会被替换。
为解决上述问题，可以使用数字证书认证机构和其相关机构颁发的公开密钥证书。
服务器运营人员向数字证书认证机构提出公开密钥申请。机构判明申请者身份后，对已申请的公开密钥做数字签名（也就是用自己的私钥去对申请者的公钥和一些相关信息一起加密，生成"数字证书"），然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份公钥证书发送给客户端，以进行公开密钥加密方式通信。
接收到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可证明两件事：一认证服务器的公开密钥的是真实有效的数字证书机构（机构真实性）。二服务器的公开密钥是值得信赖的。（证书有效性。信任机构，也就信任了它发布的证书。）
认证机关的公开密钥必须安全地转交给客户端，如何转交是一件困难的事情，因此多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。

##补充
###TLS
TLS由SSL握手协议、SSL修改密码规范协议、SSL警报协议、SSL记录协议组成。

协议分层：
SSL握手协议|SSL修改密码规范协议|SSL警报协议|HTTP
SSL记录协议
TCP
IP

SSL握手协议：相对于三次握手
SSL记录协议：记录为TLS发送接收数据的基本单位。它的自协议需要通过记录协议发出。如果多个纪录数据则可以一个TCP包一次性发出。
SSL警报协议：类似HTTP状态码，通过反馈不同的消息进行不同的策略
SSL修改密码规范协议：告诉对方，从现在起，后续的数据将使用加密算法进行加密再传输

###HTTPS请求建立连接的过程
[TLS握手协议分析与理解——某HTTPS请求流量包分析](https://www.cnblogs.com/linkenpark/p/10800557.html)
[HTTPS加密协议详解：TLS/SSL握手过程](https://www.bilibili.com/read/cv1003093/)
[HTTPS加密原理](https://www.jianshu.com/p/cf2f86bc597a)
[HTTPS 之 SSL/TLS 握手协议（Handshake Protocol）全过程解析](https://www.jianshu.com/p/07a1e362e1ba)
[数字签名和公钥，密钥加密机制](https://blog.csdn.net/dynaamo/article/details/49854115)
[SSL 握手协议详解](https://www.cnblogs.com/sunfb/p/3443221.html)

TCP三次握手建立连接。作为礼貌，Client先打招呼"Client Hello"。里面包含了Client的版本号、所支持的密码套件(支持的对称/非对称加密算法)和随机数C。

Server端表示尊重，回复"ServerHello",同时进行版本校对，给出随机数S(Server Random)，从Client算法列表中选择一个密码套件，在这里选择的"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"，并向客户端返回服务端证书。

>这里的"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"什么意思呢？密码套件选择椭圆曲线加RSA、AES、SHA256。

Client验证证书的合法性，包括可信性，是否吊销，过期时间和域名。

接下去是进行密钥交换。客户端使用公匙对新的随机数--预主密钥加密，发送给服务端。服务器用私钥解密，拿到预主密钥。

总结来说就是一共生成三个随机数，根据三个随机数创建一个对称加密的秘钥。前两个随机数可以被抓包拿到，但是第三个随机数已经使用非对称加密算法加密过，所以最终生成的秘钥是保密的。
![](https://img-blog.csdn.net/20180308103518987)


现在的问题就是，对称秘钥的安全靠第三个随机数的不可破解来保证。理论上来说，只要服务器的公钥足够长，那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。

![](https://img-blog.csdn.net/20180308103624597)
与上面client使用RSA公钥加密Premaster secret然后传递的server不同的是，由server发送一个server的DH 参数+private key，client发送一个client的DH参数，那么client和server都能分别通过两个DH参数得到Premaster secret。这样就提高了Premaster secret的安全性。[来源](https://blog.csdn.net/u013805360/article/details/79481019)

因为本机服务器选用了ECDHE算法，为了实现密钥交换算法，它会发送证书后把椭圆曲线的公钥（ServerParams）连带"Server Key Exchange"消息发送出去。

Server Key Exchange
意思是，刚才混合加密套件比较复杂，给你个算法参数，好好记住，别弄丢了。

Server Hello Done
随后服务端回复"hello done"告知打招呼完毕。打完招呼完毕后，客户端对证书进行核实。然后根据密码套件也生成椭圆曲线的公钥，用"Client Key Exchange"消息发给服务器：

Client Key Exchange
此时客户端和服务端都有了密钥交换的两个参数(Client Params、ServerParams），然后通过ECDHE算法算出了一个新的值，叫“Pre-Master”。有了预主密钥和会话密钥（C+S+Pre master），客户端发送“Change Cipher Spec”和“Finished”消息，最后将所有消息加上摘要发送给服务器验证。服务器同样发送“Change Cipher Spec”和“Finished”消息，握手结束，开始进行HTTP请求与响应。

后续通信双方使用会话密钥加密解密数据。

###为什么一定要用三个随机数，来生成"会话密钥"
dog250解释得很好：
"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

###HTTPS慢的原因
网站在加上TLS证书时，为什么会变慢？这主要有两方面造成：
1. HTTPS比HTTP在通信时会产生更多的通信过程，随之RTT时间就会增加；
2. HTTPS通信过程的非对称和对称加解密计算会产生更多的服务器性能和时间上的消耗。

###HTTPS优化
####HSTS
HTTPS网站通常的做法是对HTTP的访问在服务器端做302跳转，跳转到HTTPS。但这个302跳转存在两个问题：

1. 使用不安全的HTTP协议进行通信；
2. 增加一个Round-Trip Time。

而HSTS是HTTP Strict Transport Security的缩写，服务器端配置支持HSTS后，会在给浏览器返回的HTTP Header中携带HSTS字段，浏览器在获取到该信息后，在接下来的一段时间内，对该网站的所有HTTP访问，浏览器都将请求在内部做307跳转到HTTPS，而无需任何网络过程。

####Session Resume
Session Resume即会话复用，这提升HTTPS网站性能最基础也是最有效的方法。

在HTTPS握手阶段，对服务器性能消耗最为严重的是非对称密钥交换计算，而Session Resume通过对已经建立TLS会话的合理复用，节省非对称密钥交换计算次数，可大幅提高服务器的TLS性能。


TLS协议提供两种实现机制Session Resume，分别是Session cache和Session ticket。

Session Cache

Session Cache的原理是使用Session ID查询服务器上的session cache，如果命中，则直接使用缓存信息。但Session Cache有个明显的缺点，它不支持分布式缓存，只支持单机进程间的共享缓存。这对于多个接入节点的架构很难适用。

Session ticket

Session ticket的原理是服务器降session信息加密成ticket发送给浏览器，浏览器后续进行TLS握手时，会发送ticket，如果服务器能够解密和处理该ticket，则可以复用session。

Session ticket可以很好的解决分布式问题，但Session ticket的支持率还不是很高，而且需要考虑服务器上key的安全性方案。

####OCSP Stapling
在HTTPS通信过程时，浏览器会去验证服务器端下发的证书链是否已经被撤销。验证的方法有两种：CRL和OCSP。

CRL是证书撤销列表，CA机构会维护并定期更新CRL列表，但这个机制存在不足：

1.CRL列表只会越来越大；

2.如果浏览器更新不及时，会造成误判。

OCSP是实时证书在线验证协议，是对CRL机制的弥补，通过OCSP浏览器可以实时的向CA机构验证证书。但OCSP同样存在不足：

1. 对CA机构要求过高，要求实时全球高可用；

2. 客户端的访问隐私会在CA机构被泄露；

3. 增加浏览器的握手时延。

而OCSP Stapling是对OCSP缺陷的弥补，服务器可事先模拟浏览器对证书链进行验证，并将带有CA机构签名的OCSP响应保存到本地，然后在握手阶段，将OCSP响应和证书链一起下发给浏览器，省去浏览器的在线验证过程。

####SPDY和HTTP2.0
SPDY 是 Google 推出的优化 HTTP 传输效率的协议，采用多路复用方式，能将多个 HTTP 请求在同一个连接上一起发出去，对HTTP通信效率提升明显。HTTP2.0是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型。SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。


Nginx stable版本当前只能支持到SPDY3.1，但最新发布的1.9.5版本通过打patch的方式，可以支持HTTP2.0，这绝对是不一样的奇妙体验。不过不建议直接在线上环境部署，等到2015年年底吧，Nginx会发布Stable版本支持HTTP2.0.

####TCP优化
因为TCP是HTTPS的承载，TCP的性能提升，上层业务都可以受益。

慢启动是TCP规范中很重要的算法，其目的是为避免网络拥塞。通过客户端和服务器之间的数据交换，从一个很保守的初始拥塞窗口值，收敛到双方都认可的可用带宽。当客户端和服务器收敛到一定带宽时，如果一段时间内，双方没有收发数据包，服务器端的拥塞窗口会被重置为初始拥塞窗口值。这对于连接中的突发数据传输性能影响是很严重的。

在没有充足的理由时，服务器端需要禁用空闲后的慢启动机制。

另外，当前浏览器和服务器之间的可用带宽已经相对较大，所以我们还应该将初始的拥塞窗口值扩大，新的RFC中的建议是10，Google是16。

####TLS Record Size
服务器在建立TLS连接时，会为每个连接分配Buffer，这个Buffer叫TLS Record Size。这个Size是可调。

Size值如果过小，头部负载比重就会过大，最高可达6%。

Size值如果过大，那单个Record在TCP层会被分成多个包发送。浏览器必须等待这些全部达到后，才能解密，一旦出现丢包、拥塞、重传、甚至重新建立的情况，时延就会被相应增加。

那TLS Record Size值如何选择呢？有两个参数可参考。

首先，TLS Record Size要大于证书链和OCSP Stapling响应大小，证书链不会分成多个record；

其次，要小于初始拥塞窗口值，保证服务器在通信之初可以发送足够数据而不需要等待浏览器确认

一般来说，从根CA机构申请的证书为2-3KB左右，级数越多，证书链越大，ocsp响应为2KB左右，所以TLS Record Size是需要根据你的实际情况设置，Google的值5KB。WildDog当前的值是6KB。

####证书链完整且不冗余
浏览器在验证服务器下发的证书链时，不仅仅验证网站证书。如果是多级证书，网站证书和根证书之间所有的中间证书都需要被验证。一旦出现证书链出现不完整，浏览器就会暂停握手过程，自行到因特网进行验证，这个时间基本是不可估算的。

至于怎么查看，通过openssl命令查看，也可以通过SSL Labs帮你在线检测。

####移动设备上的ChaCha20-Poly1305
去年的时候，谷歌已经在Android的Chrome浏览器上增加支持一个新的TLS加密套件，这个加密套件就是ChaCha20-Poly1305。它的设计者是伊利诺伊大学的教授和研究员Dan BernsteinChaCha20被用来加密，Poly1305被用来消息认证，两个操作都需要运行于TLS上。

当前流行的加密套件AES-GCM在TLS 1.2支持，它是不安全RC4和AES-CBC加密套件的替代品。但是，在不支持硬件AES的设备上会引起性能问题，如大部分的智能手机、平板电脑、可穿戴设备。

ChaCha20-Poly1305正式为解决这个问题而生。以下是Google的相关测试数据，在使用Snapdragon S4 Pro处理器的Nexus 4或其他手机中，AES-GSM的加密吞吐量是41.5MB/s，而ChaCha20-Poly1305是130.9MB/s。在使用OMAP 4460的老的Galaxy Nexus手机上，AES-GSM的吞吐量是24.1MB/s，而ChaCha20-Poly1305是75.3MB/s。

当前，OpenSSL 1.0.2的分支上已经开始支持ChaCha20-Poly1305，而对ChaCha20-Poly1305支持最好的当属BoringSSL。通过重新对Nginx的SSL库编译，可以支持到ChaCha20-Poly1305，不过对于线上环境，建议看明白源码再使用。

除此之外，还有不少优化的细节，如硬件加速、False Start、禁用TLS压缩等等，这里就不扒了。

来自https://www.zhihu.com/question/28617156

###Diffie-Hellman（迪菲-赫尔曼）秘钥交换
Diffie-Hellman算法具有两个吸引力的特征：

1、仅当需要时才生成密钥，减小了将密钥存储很长一段时间而致使遭受攻击的机会。

2、除对全局参数的约定外，密钥交换不需要事先存在的基础结构。

然而，该技术也存在许多不足：

1、没有提供双方身份的任何信息。
2、它是计算密集性的，因此容易遭受阻塞性攻击，即对手请求大量的密钥。受攻击者花费了相对多的计算资源来求解无用的幂系数而不是在做真正的工作。
3、没办法防止重演攻击。
4、容易遭受中间人的攻击。

Oakley算法是对Diffie-Hellman密钥交换算法的优化，它保留了后者的优点，同时克服了其弱点。


————————————————
版权声明：本文为CSDN博主「奔跑的路」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lee244868149/java/article/details/51790397

##其他
[1.背景知识、协议的需求、设计的难点](https://eth.boomtlk.com/btsync/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3%E7%9A%84%E5%8D%9A%E5%AE%A2-%E7%A6%BB%E7%BA%BF%E7%89%88/blog/html/2014/11/https-ssl-tls-1.html)
[2. 可靠密钥交换的难点，以及身份认证的必要性](https://eth.boomtlk.com/btsync/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3%E7%9A%84%E5%8D%9A%E5%AE%A2-%E7%A6%BB%E7%BA%BF%E7%89%88/blog/html/2014/11/https-ssl-tls-2.html)
[3. 扫盲几种密钥交换（密钥协商）算法](https://eth.boomtlk.com/btsync/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3%E7%9A%84%E5%8D%9A%E5%AE%A2-%E7%A6%BB%E7%BA%BF%E7%89%88/blog/html/2016/09/https-ssl-tls-3.html)
[4.历史版本的演变及 Record 协议的细节](https://eth.boomtlk.com/btsync/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3%E7%9A%84%E5%8D%9A%E5%AE%A2-%E7%A6%BB%E7%BA%BF%E7%89%88/blog/html/2018/09/https-ssl-tls-4.html)

[图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)









