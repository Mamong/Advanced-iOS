第 7 章　方法

[TOC]

##7.1　方法的调用
###7.1.1　简单的方法调用
对象.方法名( 参数 1, 参数 2, … , 参数 n )
###7.1.2　带块的方法调用
对象. 方法名( 参数, …) do | 变量 1, 变量 2, …|
　块内容
end

do ～ end 这部分就是所谓的块。除 do ～ end 这一形式外，我们也可以用 {～} 将块改写为其他形式：
对象. 方法名( 参数, …) { | 变量 1, 变量 2, …|
　块内容
}

备注　使用 do ～ end 时，可以省略把参数列表括起来的 ()。使用 { ～ } 时，只有在没有参数的时候才可以省略 ()，有一个以上的参数时就不能省略。

在块开头的 ～ 部分中指定的变量称为块变量。在执行块的时候，块变量由方法传到块内部。不同的方法对应的块变量的个数、值也都不一样。

###7.1.3　运算符形式的方法调用
Ruby 中有些方法看起来很像运算符。四则运算等的二元运算符、-（负号）等的一元运算符、指定数组、散列的元素下标的 [] 等，实际上都是方法。

##7.2　方法的分类
###7.2.1　实例方法
###7.2.2　类方法
###7.2.3　函数式方法
没有接收者的方法，我们称之为函数式方法。

虽说是没有接收者，但并不表示该方法就真的没有可作为接收者的对象，只是在函数式方法这个特殊情况下，可以省略接收者而已。
```
print "hello!"    # 在命令行输出字符串
sleep(10)         # 在指定的时间内睡眠，终止程序
```
函数式方法的执行结果，不会根据接收者的状态而发生变化。程序在执行 print 方法以及 sleep 方法的时候，并不需要知道接收者是谁。反过来说，不需要接收者的方法就是函数式方法。

##7.3　方法的定义
def 方法名( 参数 1, 参数 2, …)
希望执行的处理
end

方法名可由英文字母、数字、下划线组成，但不能以数字开头。

参数的默认值，是指在没有指定参数的情况下调用方法时，程序默认使用的值。定义方法时，用参数名 = 值这样的写法定义默认值。

方法有多个参数时，从参数列表的右边开始依次指定默认值。例如，希望省略三个参数中的两个时，就可以指定右侧两个参数为默认值。
```
def func(a, b=1, c=3)
  ┊
end
```
###7.3.1　方法的返回值
我们可以用 return 指定方法的返回值。
return 值

可以省略 return 语句，这时方法的最后一个表达式的结果就会成为方法的返回值。

如果省略 return 的参数，程序则返回 nil。方法的目的是程序处理，所以 Ruby 允许没有返回值的方法。Ruby 中有很多返回值为 nil 的方法，第 1 章中介绍的 print 方法就是其中一。

print 方法只输出参数的内容，返回值为 nil。

###7.3.2　定义带块的方法
yield 是定义带块的方法时最重要的关键字。调用方法时通过块传进来的处理会在 yield 定义的地方执行。

如果 yield 部分有参数，程序就会将其当作块变量传到块里。块里面最后的表达式的值既是块的执行结果，同时也可以作为 yield 的返回值在块的外部使用。

###7.3.3　参数个数不确定的方法
通过用“* 变量名”的形式来定义参数个数不确定的方法，Ruby 就可以把所有参数封装为数组，供方法内部使用。
```
def foo(*args)
  args
end

p foo(1, 2, 3)    #=> [1, 2, 3]
```
至少需要指定一个参数的方法可以像下面这样定义：
```
def meth(arg, *agrs)
  [arg, args]
end

p meth(1)        #=> [1, []]
p meth(1, 2, 3)  #=> [1, [2, 3]]
```
所有不确定的参数都被作为数组赋值给变量 args。“* 变量名”这种形式的参数，只能在方法定义的参数列表中出现一次。只确定首个和最后一个参数名，并省略中间的参数时，可以像下面这样定义：
```
def a(a, *b, c)
  [a, b, c]
end

p a(1, 2, 3, 4, 5)    #=> [1, [2, 3, 4], 5]
p a(1, 2)             #=> [1, [], 2]
```

###7.3.4　关键字参数
使用关键字参数，就可以将参数名与参数值成对地传给方法内部使用。

使用关键字参数定义方法的语法如下所示：
def 方法名（参数 1: 参数 1 的值, 参数 2: 参数 2 的值, …)
　希望执行的处理
end

除了参数名外，使用“参数名 : 值”这样的形式还可以指定参数的默认值。
```
def area2(x: 0, y: 0, z: 0)
  xy = x * y
  yz = y * z
  zx = z * x
  (xy + yz + zx ) * 2
end

p area2(x: 2, y: 3, z: 4)    #=> 52
p area2(z: 4, y: 3, x: 2)    #=> 52 （改变参数的顺序）
p area2(x: 2, z: 3)          #=> 12 （省略y）
```
这个方法有参数 x、y、z，各自的默认值都为 0。调用该方法时，可以像 x: 2 这样，指定一对实际的参数名和值。在用关键字参数定义的方法中，每个参数都指定了默认值，因此可以省略任何一个。而且，由于调用方法时也会把参数名传给方法，所以参数顺序可以自由地更改。

不过，如果把未定义的参数名传给方法，程序就会报错.

为了避免调用方法时因指定了未定义的参数而报错，我们可以使用“** 变量名”的形式来 接收未定义的参数。参数 arg 会把参数列表以外的关键字参数以散列对象的形式保存。
```
def meth(x: 0, y: 0, z: 0, **args)
  [x, y, z, args]
end

p meth(z: 4, y: 3, x: 2)        #=> [2, 3, 4, {}]
p meth(x: 2, z: 3, v: 4, w: 5)  #=> [2, 0, 3, {:v=>4, :w=>5}]
```

**关键字参数与普通参数的搭配使用**
```
def func(a, b: 1, c:2)
  ┊
end
```
上述这样定义时，a 为必须指定的普通参数，b、c 为关键字参数。调用该方法时，可以像下面这样，首先指定普通参数，然后是关键字参数。
```
func(1, b: 2, c: 3)
```
**用散列传递参数**
调用用关键字参数定义的方法时，可以使用以符号作为键的散列来传递参数。这样一来，程序就会检查散列的键与定义的参数名是否一致，并将与散列的键一致的参数名传递给方法。
```
def area2(x: 0, y: 0, z: 0)
  xy = x * y
  yz = y * z
  zx = z * x
  (xy + yz + zx ) * 2
end
　
args1 = {x: 2, y: 3, z: 4}
p area2(args1)            #=> 52
　
args2 = {x: 2, z: 3}      #=> 省略y
p area2(args2)            #=> 12
```

###7.3.5　关于方法调用的一些补充
把数组分解为参数

将参数传递给方法时，我们也可以先分解数组，然后再将分解后的数组元素作为参数传递给方法。在调用方法时，如果以“* 数组”这样的形式指定参数，这时传递给方法的就不是数组本身，而是数组的各元素被按照顺序传递给方法。但需要注意的是，数组的元素个数必须要和方法定义的参数个数一样。
```
def foo(a, b, c)
  a + b + c
end
　
p foo(1, 2, 3)    #=> 6
　
args1 = [2, 3]
p foo(1, *args1)  #=> 6
　
args2 = [1, 2, 3]
p foo(*args2)     #=> 6
```

把散列作为参数传递

我们用 { ～ } 这样的形式来表示散列的字面量（literal）。将散列的字面量作为参数传递给方法时可以省略 {}。
```
def foo(arg)
  arg
end
　
p foo({"a"=>1, "b"=>2})    #=> {"a"=>1, "b"=>2}
p foo("a"=>1, "b"=>2)      #=> {"a"=>1, "b"=>2}
p foo(a: 1, b:2)           #=> {:a=>1, :b=>2}
```
当虽然有多个参数，但只将散列作为最后一个参数传递给方法时，可以使用下面的写法：
```
def bar(arg1, arg2)
  [arg1, arg2]
end
　
p bar(100, {"a"=>1, "b"=>2})    #=> [100, {"a"=>1, "b"=>2}]
p bar(100, "a"=>1, "b"=>2)      #=> [100, {"a"=>1, "b"=>2}]
p bar(100, a: 1, b: 2)          #=> [100, {:a=>1, :b=>2}]
```
第 3 种形式是把符号作为键的散列传递给方法，与使用关键字参数调用方法的形式一模一样。其实，关键字参数就是模仿这种将散列作为参数传递的写法而设计出来的。使用关键字参数定义方法，既可以对键进行限制，又可以定义参数的默认值。因此建议大家在实际编写程序的时候多尝试使用关键字参数。