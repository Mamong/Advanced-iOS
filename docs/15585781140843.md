ReactiveCocoa备览

[TOC]

##简介
###什么是ReactiveCocoa
ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。

###ReactiveCocoa的作用
在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。
比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。

其实这些事件，都可以通过RAC处理
ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中高聚合，低耦合的思想。

对于一个应用来说，绝大部分的时间都是在等待某些事件的发生或响应某些状态的变化，比如用户的触摸事件、应用进入后台、网络请求成功刷新界面等等，而维护这些状态的变化，常常会使代码变得非常复杂，难以扩展。而 ReactiveCocoa 给出了一种非常好的解决方案，它使用信号来代表这些异步事件，提供了一种统一的方式来处理所有异步的行为，包括代理方法、block 回调、target-action 机制、通知、KVO 等。

通过RAC提供的方法与系统提供的方法分别进行对比，先来感受下RAC的强大之处。
1. UIButton
![通过默认的Target-action创建点击动作](https://upload-images.jianshu.io/upload_images/1243805-1ddc42adc855d346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/994)
![RAC创建Button点击事件与添加点击手势动作](https://upload-images.jianshu.io/upload_images/1243805-14871cea4af39f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
在RAC的block代码块中，打印x的属性为当前self.testButton的相关信息。
![](https://upload-images.jianshu.io/upload_images/1243805-96be2ff0c89d19c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
2. KVO
KVO在使用时，必须在
```- (void)observeValueForKeyPath:(NSString*)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void*)context```中实现针对KVO监听属性值变化的处理，而且对于KeyPath书写容易产生手写错误。在对应类dealloc时，KVO还必须要进行remove操作，否则会程序crash。
![使用KVO监听UILable的text属性变化](https://upload-images.jianshu.io/upload_images/1243805-e903efbeb48e47e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
在使用RAC代替KVO时，不仅能大大增加代码可读性，而且RACObserve(<#TARGET#>, <#KEYPATH#>)宏定义中keyPath可以代码提示出target中的属性成员变量，降低手写代码错误的可能性。
![使用RAC代替KVO监听属性变化](https://upload-images.jianshu.io/upload_images/1243805-71ea04cac2884982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
3. delegate代理
以UITextField为例，当需要对UITextField逻辑处理时，往往需要实现其各类代理方法，大大增加了代码量。当使用RAC之后
![使用RAC代替delegate实现方法](https://upload-images.jianshu.io/upload_images/1243805-fea36f28b944bcdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
@selector方法选择器中键入要实现的代理方法，代理名称声明为对应的代理名称。block代码块中，当触发监听的代理方法时返回元组类型数据，与swift中的元组类型有所区别，此处的元组看起来更像是数组。
![](https://upload-images.jianshu.io/upload_images/1243805-f860ae18d48556ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
4. Notification通知
![RAC通知使用](https://upload-images.jianshu.io/upload_images/1243805-13a73de5a0a510e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
![RAC会将通知名以及userInfo相关信息返回至block中](https://upload-images.jianshu.io/upload_images/1243805-939177c09f99de0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
5. 定时器timer
![](https://upload-images.jianshu.io/upload_images/1243805-6f32e9887d918369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
6. 数组与字典
![RAC遍历字典、数组中的元素](https://upload-images.jianshu.io/upload_images/1243805-6dab7655145d6512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
![](https://upload-images.jianshu.io/upload_images/1243805-d9c155e4dc3b2991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

然而，这些还只是 ReactiveCocoa 的冰山一角，它真正强大的地方在于我们可以对这些不同的信号进行任意地组合和链式操作，从最原始的输入 input 开始直至得到最终的输出 output 为止：
```
[[[RACSignal
    combineLatest:@[ RACObserve(self, username), RACObserve(self, password) ]
    reduce:^(NSString *username, NSString *password) {
      return @(username.length > 0 && password.length > 0);
    }]
    distinctUntilChanged]
    subscribeNext:^(NSNumber *valid) {
        if (valid.boolValue) {
            // 用户名和密码合法，登录按钮可用
        } else {
            // 用户名或密码不合法，登录按钮不可用
        }
    }];
```

###ReactiveCocoa编程思想
先简单介绍下目前咱们已知的编程思想。
* 面向过程：处理事情以过程为核心，一步一步的实现。

* 面向对象：万物皆对象

* 链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)
  链式编程特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）
  
  代表：masonry框架。
  
* 响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。

    代表：KVO运用。
    
* 函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。

    函数式编程特点：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）

    代表：ReactiveCocoa。

ReactiveCocoa结合了几种编程风格：
函数式编程（Functional Programming）
响应式编程（Reactive Programming）

所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。

以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。

###如何导入ReactiveCocoa框架
通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。

podfile如果只描述pod 'ReactiveCocoa', '~> 4.0.2-alpha-1'，会导入不成功。

需要在podfile加上use_frameworks，重新pod install 才能导入成功。

###ReactiveCocoa的组成
在正式开始介绍它的核心组件前，我们先来看看它的类图，以便从宏观上了解它的层次结构：
![](https://upload-images.jianshu.io/upload_images/2121311-d05ccedfb07b953f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

从上面的类图中，我们可以看出，ReactiveCocoa 主要由以下四大核心组件构成：
* 信号源：RACStream 及其子类；
* 订阅者：RACSubscriber 的实现类及其子类；
* 调度器：RACScheduler 及其子类；
* 清洁工：RACDisposable 及其子类。

一些主要类介绍：
RACSiganl:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。

RACSubscriber:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。

RACDisposable:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。
使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。

RACSubject:RACSubject:信号提供者，自己可以充当信号，又能发送信号。
使用场景:通常用来代替代理，有了它，就不必要定义代理了。

RACReplaySubject:重复提供信号类，RACSubject的子类。

RACTuple:元组类,类似NSArray,用来包装值.

RACSequence:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。

RACCommand:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。
使用场景:监听按钮点击，网络请求

RACMulticastConnection:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。

使用注意:RACMulticastConnection通过RACSignal的-publish或者-multicast:方法创建.

RACScheduler:RAC中的队列，用GCD封装的。

RACUnit :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil。

RACEvent: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。

##RACStream
在 ReactiveCocoa 框架中，RACStream 是所有信号流的抽象类，所有基于流的操作都可以建立在该类之上。

其包含5个需要子类重写的方法：empty、return:、bind:、concat:、zipWith:。

* empty 方法返回一个空的流，而 return: 方法则返回包含一个指定值的流。

```
+ (__kindof RACStream<ValueType> *)empty;
+ (__kindof RACStream<ValueType> *)return:(nullable ValueType)value;
```
* bind: 方法则是创建一个新的流来表示原始流与 block 的绑定，RACStreamBindBlock 类型是包含两个参数并且返回一个流的代码块。

```
typedef RACStream * _Nullable (^RACStreamBindBlock)(ValueType _Nullable value, BOOL *stop); 

- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;
```
* concat: 方法将两个流拼接到一起作为一个新的流，这拼接的两个流的类型应当是一致的。

```
- (__kindof RACStream *)concat:(RACStream *)stream;
```
* zipWith: 方法将压缩两个同类型的流，产生一个新的流，新流的数据是两个流的相同序列号的数据压缩而来，直到有一个流结束，则新流结束。

```
- (__kindof RACStream *)zipWith:(RACStream *)stream;
```
###扩展类
在 RACStream 的扩展类中定义了一个 name 属性，该属性用于调试，相应的设置该值的方法如下：
```
- (instancetype)setNameWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1, 2);
```
但是只有设置了环境变量 RAC_DEBUG_SIGNAL_NAMES 该方法才有效，即 getenv("RAC_DEBUG_SIGNAL_NAMES") != NULL 该方法才会修改 name 属性的值。

###Operations分类
RACStream 有一个 Operations 分类，其中定义了一些常用的操作方法，这些方法不宜被重写，即使重写会有更好的性能。

####1.flattenMap
方法原型：
```
- (__kindof RACStream *)flattenMap:
                    (__kindof RACStream * _Nullable (^)(ValueType _Nullable value))block;
```
映射方法，即将接收到的信号量通过参数 block 映射为需要的值。该 block 参数的 value 参数即为原始流传递的信号量，最后经过处理后，得到一个新的 RACStream 信号流，该信号流中包含有处理的信号量，但也可能是空流。

实现源码：
```
- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block {
	Class class = self.class;

	return [[self bind:^{
		return ^(id value, BOOL *stop) {
			id stream = block(value) ?: [class empty];
			NSCAssert([stream isKindOfClass:RACStream.class], @"Value returned from -flattenMap: is not a stream: %@", stream);

			return stream;
		};
	}] setNameWithFormat:@"[%@] -flattenMap:", self.name];
}
```
通过上面的源码可知，映射方法，实则是调用 bind: 方法，创建了一个新的信号流，该信号流被订阅时，会将 block 代码块参数绑定到源信号流，那么每当源信号流产生了信号量时，就可以通过执行与其绑定的 block 代码块创建一个新的内部信号流，这个内部信号流中的信号量是经过处理的，而其将会转发给调用该方法创建的信号流的订阅者进行进一步处理。

####2.flatten
方法原型：
```
- (__kindof RACStream *)flatten;
```
如果说 flattenMap: 方法是根据源信号流中的信号量经过处理产生新的信号流的话，那么 flatten 方法则是直接将源信号流中的信号量作为返回值，即该信号量本身就是信号流类型。那么，可以知道，源信号流中传递的信号量就是信号流。

实现源码:
```
- (__kindof RACStream *)flatten {
	return [[self flattenMap:^(id value) {
		return value;
	}] setNameWithFormat:@"[%@] -flatten", self.name];
}
```
所以，flatten 方法返回的新的信号流所接收的信号量是源信号流中传递的信号量，有点类似于解压了一个信号流从而获得其中诸多信号流中的信号量。
####3.map
方法原型:
```
- (__kindof RACStream *)map:(id _Nullable (^)(ValueType _Nullable value))block;
```
map: 方法则是将信号量进行处理，然后返回一个值，该值被 return: 方法用来初始化一个只包含一个信号量的信号流。

实现源码:
```
- (__kindof RACStream *)map:(id (^)(id value))block {
	NSCParameterAssert(block != nil);

	Class class = self.class;
	
	return [[self flattenMap:^(id value) {
		return [class return:block(value)];
	}] setNameWithFormat:@"[%@] -map:", self.name];
}
```
####4.mapReplace
方法原型:
```
- (__kindof RACStream *)mapReplace:(nullable id)object;
```
该方法实际是调用了 map: 方法，并且其 block 中直接返回了 object 值，即直接用指定的值替换接收到的信号量。
####5.filter
方法原型:
```
- (__kindof RACStream<ValueType> *)filter:(BOOL (^)(ValueType _Nullable value))block;
```
通过 block 来判断符合条件的信号量，如果符合，就将信号量封装到信号流中进行返回，否则，就返回空的流。

实现源码:
```
- (__kindof RACStream *)filter:(BOOL (^)(id value))block {
    NSCParameterAssert(block != nil);

    Class class = self.class;

    return [[self flattenMap:^ id (id value) {
        if (block(value)) {
            return [class return:value];
        } else {
            return class.empty;
        }
    }] setNameWithFormat:@"[%@] -filter:", self.name];
}
```

####6.ignore
方法原型:
```
- (__kindof RACStream<ValueType> *)ignore:(nullable ValueType)value;
```
忽略指定的值，该方法实际是调用了 filter: 方法，只是在 block 参数中将信号量同指定的值进行比较。

####7.reduceEach
方法原型:
```
- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock;
```
该方法将接收到的组合信号量进行处理，得到一个单一值的信号量。

实现源码:
```
_Pragma("clang diagnostic push") \
_Pragma("clang diagnostic ignored \"-Wstrict-prototypes\"") \
typedef id _Nonnull (^RACReduceBlock)();
_Pragma("clang diagnostic pop")

- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock {
    NSCParameterAssert(reduceBlock != nil);

    __weak RACStream *stream __attribute__((unused)) = self;
    return [[self map:^(RACTuple *t) {
        NSCAssert([t isKindOfClass:RACTuple.class], 
                        @"Value from stream %@ is not a tuple: %@", stream, t);

        return [RACBlockTrampoline invokeBlock:reduceBlock withArguments:t];
    }] setNameWithFormat:@"[%@] -reduceEach:", self.name];
}
```
从上面的代码可知，源信号流所传递的信号量必须是 RACTuple 类型的，其所包含的分量个数与 reduceBlock 的参数个数需要保持一致，所以 RACReduceBlock 类型的参数个数是不确定的，当然框架中最多支持 15 个参数。
####8.skip
方法原型:
```
- (__kindof RACStream<ValueType> *)skip:(NSUInteger)skipCount;
```
跳过 skipCount 次信号量，被跳过的信号量实际返回了空的信号流。

实现源码:
```
- (__kindof RACStream *)skip:(NSUInteger)skipCount {
    Class class = self.class;

    return [[self bind:^{
        __block NSUInteger skipped = 0;

        return ^(id value, BOOL *stop) {
            if (skipped >= skipCount) return [class return:value];

            skipped++;
            return class.empty;
        };
    }] setNameWithFormat:@"[%@] -skip: %lu", self.name, (unsigned long)skipCount];
}
```
####9.take
方法原型:
```
- (__kindof RACStream<ValueType> *)take:(NSUInteger)count;
```
只接收第 count 次信号量，如果 count 为 0，那么接收第一个信号量时返回空的信号流。当接收到第 count 次传递的信号量后，则不再接收信号量。

####10.takeUntilBlock
方法原型:
```
- (__kindof RACStream<ValueType> *)takeUntilBlock:(BOOL (^)(ValueType _Nullable x))predicate;
```
一直接收信号量，直到信号量满足 predicate 的条件为止，如果，predicate 不可能返回 YES ，那么返回的信号流同源信号流是等同的。

实现源码:
```
- (__kindof RACStream *)takeUntilBlock:(BOOL (^)(id x))predicate {
    NSCParameterAssert(predicate != nil);

    Class class = self.class;

    return [[self bind:^{
        return ^ id (id value, BOOL *stop) {
            if (predicate(value)) return nil;

            return [class return:value];
        };
    }] setNameWithFormat:@"[%@] -takeUntilBlock:", self.name];
}
```
####11.takeWhileBlock
方法原型:
```
- (__kindof RACStream<ValueType> *)takeWhileBlock:(BOOL (^)(ValueType _Nullable x))predicate;
```
一直接收信号量，直到信号量不满足 predicate 的条件为止，该方法实际是调用了 takeUntilBlock: 方法，只是判断条件取反而以。

####12.skipUntilBlock
方法原型:
```
- (__kindof RACStream<ValueType> *)skipUntilBlock:(BOOL (^)(ValueType _Nullable x))predicate;
```
跳过信号量，直到满足 predicate 的条件为止。

实现源码:
```
    - (__kindof RACStream *)skipUntilBlock:(BOOL (^)(id x))predicate {
    NSCParameterAssert(predicate != nil);

    Class class = self.class;

    return [[self bind:^{
        __block BOOL skipping = YES;

        return ^ id (id value, BOOL *stop) {
            if (skipping) {
                if (predicate(value)) {
                    skipping = NO;
                } else {
                    return class.empty;
                }
            }

            return [class return:value];
        };
    }] setNameWithFormat:@"[%@] -skipUntilBlock:", self.name];
}
```
####13.skipWhileBlock
方法原型:
```
- (__kindof RACStream<ValueType> *)skipWhileBlock:(BOOL (^)(ValueType _Nullable x))predicate;
```
跳过信号量，直到不满足 predicate 的条件为止，该方法实际是调用了 skipUtilBlock: 方法，只是其参数取反了而已。
####14.distinctUntilChanged
方法原型:
```
- (__kindof RACStream<ValueType> *)distinctUntilChanged;
```
当接收到的信号量同上一个信号量比较，发生了改变时，才将信号量返回。

实现源码:
```
- (__kindof RACStream *)distinctUntilChanged {
    Class class = self.class;

    return [[self bind:^{
        __block id lastValue = nil;
        __block BOOL initial = YES;

        return ^(id x, BOOL *stop) {
            if (!initial && (lastValue == x || [x isEqual:lastValue])) return [class empty];

            initial = NO;
            lastValue = x;
            return [class return:x];
        };
    }] setNameWithFormat:@"[%@] -distinctUntilChanged", self.name];
}
```
####15.startWith
方法原型:
```
- (__kindof RACStream<ValueType> *)startWith:(nullable ValueType)value;
```
将指定的值作为一个信号量封装到一个信号流中并将源信号流拼接在其后，生成一个新的信号流。

实现源码:
```
- (__kindof RACStream *)startWith:(id)value {
    return [[[self.class return:value]
        concat:self]
        setNameWithFormat:@"[%@] -startWith: %@", self.name, RACDescription(value)];
}
```
该方法会产生一个新的信号流，而后订阅该流的信号。
####16.join:block
方法原型:
```
+ (__kindof RACStream *)join:(id<NSFastEnumeration>)streams block:(RACStream * (^)(id, id))block;
```
通过 block 参数对一系列的信号流进行组合，组合的过程是将第一个信号流的信号量使用 RACTuplePack 进行封装，并且得到一个新的信号流，然后将这个新的信号流同第二个信号流通过 block 进行处理得到新的信号流，该信号流再与第三个信号流进行处理，以此类推，最终得到一个拥有层层封装的信号量的信号流，而后再对这个信号流的信号量进行解封操作。

实现源码:
```
+ (__kindof RACStream *)join:(id<NSFastEnumeration>)streams block:(RACStream * (^)(id, id))block {
    RACStream *current = nil;

    // Creates streams of successively larger tuples by combining the input
    // streams one-by-one.
    for (RACStream *stream in streams) {
        // For the first stream, just wrap its values in a RACTuple. That way,
        // if only one stream is given, the result is still a stream of tuples.
        if (current == nil) {
            current = [stream map:^(id x) {
                return RACTuplePack(x);
            }];

            continue;
        }

        current = block(current, stream);
    }

    if (current == nil) return [self empty];

    return [current map:^(RACTuple *xs) {
        // Right now, each value is contained in its own tuple, sorta like:
        //
        // (((1), 2), 3)
        //
        // We need to unwrap all the layers and create a tuple out of the result.
        NSMutableArray *values = [[NSMutableArray alloc] init];

        while (xs != nil) {
            [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];
            xs = (xs.count > 1 ? xs.first : nil);
        }

        return [RACTuple tupleWithObjectsFromArray:values];
    }];
}
```
####17.zip
方法原型:
```
+ (__kindof RACStream<ValueType> *)zip:(id<NSFastEnumeration>)streams;
```
压缩多个信号流的信号量，这个方法实际是调用的上面的方法，只是其 block 这种处理两个流的方法为 zipWith: 方法。

实现源码:
```
+ (__kindof RACStream *)zip:(id<NSFastEnumeration>)streams {
    return [[self join:streams block:^(RACStream *left, RACStream *right) {
        return [left zipWith:right];
    }] setNameWithFormat:@"+zip: %@", streams];
}
```
####18.zip:reduce:
方法原型:
```
+ (__kindof RACStream<ValueType> *)zip:(id<NSFastEnumeration>)streams
                                      reduce:(RACGenericReduceBlock)reduceBlock;
```
这个方法实际是 zip: 和 reduceEach: 方法的组合，先将流组合在一起，然后将封装的信号量进行解压处理。

实现源码:
```
+ (__kindof RACStream *)zip:(id<NSFastEnumeration>)streams 
                     reduce:(RACGenericReduceBlock)reduceBlock {
    NSCParameterAssert(reduceBlock != nil);

    RACStream *result = [self zip:streams];

    // Although we assert this condition above, older versions of this method
    // supported this argument being nil. Avoid crashing Release builds of
    // apps that depended on that.
    if (reduceBlock != nil) result = [result reduceEach:reduceBlock];

    return [result setNameWithFormat:@"+zip: %@ reduce:", streams];
}
```

####19.scanWithStart:reduceWithIndex:
方法原型:
```
- (__kindof RACStream *)scanWithStart:(nullable id)startingValue 
                          reduceWithIndex:(id _Nullable (^)(id _Nullable running,
                                     ValueType _Nullable next, NSUInteger index))reduceBlock;
```
该方法的作用是将接收到的信号量通过 block 进行合并，起始值为 startingValue 值，而后将其与第一个信号量进行组合处理，得到的结果同第二个信号量进行组合处理，以此类推。

实现源码:
```
- (__kindof RACStream *)scanWithStart:(id)startingValue
                          reduceWithIndex:(id (^)(id, id, NSUInteger))reduceBlock {
    NSCParameterAssert(reduceBlock != nil);

    Class class = self.class;

    return [[self bind:^{
        __block id running = startingValue;
        __block NSUInteger index = 0;

        return ^(id value, BOOL *stop) {
            running = reduceBlock(running, value, index++);
            return [class return:running];
        };
    }] setNameWithFormat:@"[%@] -scanWithStart: %@ reduceWithIndex:", 
                                            self.name, RACDescription(startingValue)];
}
```
从上面的代码可知，每一次对新接收的信号量进行合并后，合并结果都会传递给订阅者以供进一步处理。
####20.scanWithStart:reduce:
方法原型:
```
- (__kindof RACStream *)scanWithStart:(nullable id)startingValue 
                                     reduce:(id _Nullable (^)(id _Nullable running, 
                                               ValueType _Nullable next))reduceBlock;
```
这个方法实际是调用了上面的方法，只是在 reduceBlock 参数中，不再提供接收到的信号量序列号（从 0 开始计数）。

####21.combinePreviousWithStart:reduce:
方法原型:
```
 (__kindof RACStream *)combinePreviousWithStart:(nullable ValueType)start reduce:(id _Nullable (^)(ValueType _Nullable previous,
                                                     ValueType _Nullable current))reduceBlock;
```
这个方法类似于上面的方法，但是其区别在于，接收的信号量只会同上一个信号量进行合并处理，而其结果不会参与下面的合并处理，同样的，将 start 值看作上一个信号量同实际接收到的第一个信号量进行处理，而后接收到的第二个信号量同第一个信号量进行处理。

实现源码:
```
- (__kindof RACStream *)combinePreviousWithStart:(id)start 
                                            reduce:(id (^)(id previous, id next))reduceBlock {
    NSCParameterAssert(reduceBlock != NULL);
    return [[[self
        scanWithStart:RACTuplePack(start)
        reduce:^(RACTuple *previousTuple, id next) {
            id value = reduceBlock(previousTuple[0], next);
            return RACTuplePack(next, value);
        }]
        map:^(RACTuple *tuple) {
            return tuple[1];
        }]
        setNameWithFormat:@"[%@] -combinePreviousWithStart: %@ reduce:", 
                                            self.name, RACDescription(start)];
}
```
从代码可以看出，其是调用了 scanWithStart:reduce: 方法，只是在 reduceBlock 中返回的值是 next 值与 value 的封装，这样每一次调用 reduceBlock 时，都可以获得 next 值，而方法最后返回的信号流也可以获取到 value 值作为信号量。

##RACSignal
RACSignal:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据，它是一种 push-driven 的流。

默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。

如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。

RACSignal 可以向订阅者发送三种不同类型的事件：
* next ：RACSignal 通过 next 事件向订阅者传送新的值，并且这个值可以为 nil ；
* error ：RACSignal 通过 error 事件向订阅者表明信号在正常结束前发生了错误；
* completed ：RACSignal 通过 completed 事件向订阅者表明信号已经正常结束，不会再有后续的值传送给订阅者。

注意，ReactiveCocoa中的值流只包含正常的值，即通过 next 事件传送的值，并不包括 error 和 completed 事件，它们需要被特殊处理。通常情况下，一个信号的生命周期是由任意个 next 事件和一个 error 事件或一个 completed 事件组成的。


###RACSignal实现原理
使用例子：
```
// 1.创建信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {
   // 注：block在此仅仅是个参数，未被调用，
   //当有订阅者订阅信号时会调用block。
   // 3.发送信号
    [subscriber sendNext:@1];
   // 发送error信号  
    NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:1001 userInfo:@{}];
    [subscriber sendError:error];

    // 如果不再发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。
    //4.销毁信号
    return [RACDisposable disposableWithBlock:^{
    NSLog(@"signal已销毁");
    }];
}];
// 2.1订阅信号,才会激活信号.
[signal subscribeNext:^(id x) {
    // block调用时刻：每当有信号发出数据，就会调用block.
    NSLog(@"接收到数据:%@",x);
}];
    
// 2.2订阅error信号
[signal subscribeError:^(NSError * _Nullable error) {
    // block调用时刻：有error信号发出时，就会调用block.
    NSLog(@"接收到数据:%@",error);
}];
```
使用步骤：
**1.创建信号**
```
+(RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe;
```
内部原理：

1.1 方法解析：方法名为createSignal：其返回值类型为RACSignal类的实例变量。参数为一个名字为didSubscribe的block。

1.2 方法参数didSubscribe解析：```+(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {}```的返回值是RACDisposable类型的实例变量，参数为id类型且遵守且遵守RACSubscriber协议的subscriber。

1.3 创建信号，首先把didSubscribe这个block保存到信号中，但不会触发。此时didSubscribe仅仅作为方法的参数，并没有被触发，所以信号也仅仅是一个冷信号，block内部不会执行。

>有人会问RACDisposable是什么东西，其实从字面就可以理解，销毁，它封装了当订阅行为消失时一些应该做的操作，当然像只是打印消息的操作其实是没必要的，所以这里可以返回nil。那什么时候订阅行为消失呢，当订阅者调用了sendError:或者sendCompleted方法时表示订阅行为就消失了，相应的dispose就会执行了，做一些清理操作。

源码解析：
```
+(RACSignal *)createSignal:(RACDisposable *(^)(id<RACSubscriber> subscriber))didSubscribe {
    //创建了一个RACDynamicSignal类的信号
    RACDynamicSignal *signal = [[self alloc] init];
    //将代码块保存到信号里面（但此时仅仅是保存，没有调用）
    signal->_didSubscribe = [didSubscribe copy];
    return [signal setNameWithFormat:@"+createSignal:"];
}
```
**2.订阅信号**
激活信号，冷信号变成热信号。
```
-(RACDisposable *)subscribeNext:(void (^ )(id x))nextBlock；
```
内部原理：
2.1 当信号被订阅，也就是调用signal的subscribeNext:nextBlock.
2.2 nextBlock内部创建了订阅者subscriber，并且把nextBlock保存到subscriber中。

源码解析：
```
-(RACDisposable *)subscribeNext:(void (^)(id x))nextBlock {
    NSCParameterAssert(nextBlock != NULL);
    //内部创建了RACSubscriber（订阅者）类的实例对象o，并且将nextBlock保存到o中，在返回值出执行o,实际也是执行了nextBlock。
    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];
    return [self subscribe:o]; //内部执行了nextBlock，具体见下文
}

+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed {
 RACSubscriber *subscriber = [[self alloc] init];
//将block保存到subscriber中
 subscriber->_next = [next copy];
 subscriber->_error = [error copy];
 subscriber->_completed = [completed copy];

 return subscriber;
}

//执行
- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
 NSCParameterAssert(subscriber != nil);

 RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
 subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];
//判断有无self.didSubscribe,有则执行该self.didSubscribe，意味着将订阅者subscriber发送过去
 if (self.didSubscribe != NULL) {
  RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
   RACDisposable *innerDisposable = self.didSubscribe(subscriber);
   [disposable addDisposable:innerDisposable];
  }];

  [disposable addDisposable:schedulingDisposable];
 }

 return disposable;
}
```
RACCompoundDisposable(RACDisposable的子类)应该是大家的另一个疑问，它有一个方法addDisposable:可以添加另一个RACDisposable，它的最终形态是一个树形结构，第一个RACCompoundDisposable存了若干个RACDisposable或者RACCompoundDisposable，相应的RACCompoundDisposable又存了若干个RACDisposable或者RACCompoundDisposable...每个元素里边存的都是一些block形式存在的清理操作，这样当执行树的根节点的dispose时，整棵树就会按顺序执行清理操作了。

**3.发送信号**
订阅信号时，将subscriber传递给didSubscribe的参数subscriber

利用[subscriber sendNext:@1]方法发送信号。

```
//  RACSubscriber.h
// These callbacks should only be accessed while synchronized on self.
@property (nonatomic, copy) void (^next)(id value);
//名为next的block是返回值为void，参数为id类型的value，在sendNext:内部，将next复制给nextBlock，执行该方法后，subscribeNext:的block参数才会被调用。
```
源码解析：
```
- (void)sendNext:(id)value {
 @synchronized (self) {
  void (^nextBlock)(id) = [self.next copy];
  if (nextBlock == nil) return;
  //执行nextBlock，发送value
  nextBlock(value);
 }
}
```

RACSignal原理流程图：
![](https://upload-images.jianshu.io/upload_images/2828065-ecfc71026280a7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/704)

RACSignal总结：

三步骤（先创建信号，然后订阅信号，最后发送信号，执行didSubscribe内部的方法）顺序是不能变的。

RACSignal底层实现：

1.创建信号，首先把didSubscribe保存到信号中，还不会触发。
2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock
2.1 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。
2.2 subscribeNext内部会调用signal的didSubscribe
3.signal的didSubscribe中调用[subscriber sendNext:@1];
3.1 sendNext底层其实就是执行subscriber的nextBlock

整个一个订阅流程就这样结束了，当然你会发现在你的代码中subscriber始终都没暴露出来，这也是造成你疑惑的原因，那么我问你，你需要的是subscriber呢，还是subscriber发给你的信息呢？因为我们需要的只是信息，所以完全没必要让我们知道subscriber的存在。所谓的订阅者也就是subscriber其实就是起了一个中间人的作用，获取信号(或者叫信号源更好理解)里的信息，然后发送到需要的地方。

nextBlock是作为客户端接收信息的回调，其实是真正的订阅者。subscriber只是作为内部发送信息的载体。而RACDisposable也只是作为内部清理的载体，它也没有被暴露。

###创建实例方法
RACSignal的设计模式，就是标准的类簇模式，不同的Signal都是继承于RACSignal的子类，但是都封装起来不用开发者关注，和NSArray、UIButton的设计模式相同。

RACSignal是 RACStream 的子类，它提供了创建信息流实例的类方法。

####createSignal:
```
+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {
    return [RACDynamicSignal createSignal:didSubscribe];
}
```
该方法最为常用，实际是调用了 RACSignal 的子类 RACDynamicSignal 的方法创建了一个信息流实例对象，输入参数是一个代码块，从参数名称 didSubscibe 可以理解其是在该信号流被订阅时调用的，调用时，会将遵循了协议 <RACSubscriber> 的 subscriber 订阅者作为参数传入，而返回 RACDisposable 实例用于不再订阅该信号流时的清理工作。

####error:
```
+ (RACSignal *)error:(NSError *)error {
    return [RACErrorSignal error:error];
}
```
该类创建一个持有指定错误 error 信息的 RACErrorSignal 实例，当订阅者订阅该信号流时，则立即发送该错误信号量，并且订阅者随之结束对信号流的订阅。

####never
```
+ (RACSignal *)never {
	return [[self createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {
		return nil;
	}] setNameWithFormat:@"+never"];
}
```
never 创建了一个永远不会产生信号量的流，它是 RACDynamicSignal 实例对象。

####startLazilyWithScheduler:block:
```
+ (RACSignal *)startLazilyWithScheduler:(RACScheduler *)scheduler
                                 block:(void (^)(id<RACSubscriber> subscriber))block {
    NSCParameterAssert(scheduler != nil);
    NSCParameterAssert(block != NULL);

    RACMulticastConnection *connection = [[RACSignal
        createSignal:^ id (id<RACSubscriber> subscriber) {
            block(subscriber);
            return nil;
        }]
        multicast:[RACReplaySubject subject]];

    return [[[RACSignal
        createSignal:^ id (id<RACSubscriber> subscriber) {
            [connection.signal subscribe:subscriber];
            [connection connect];
            return nil;
        }]
        subscribeOn:scheduler]
        setNameWithFormat:@"+startLazilyWithScheduler: %@ block:", scheduler];
}
```
为了便于说明，将上述代码进行如下拆分：
```
+ (RACSignal *)startLazilyWithScheduler:(RACScheduler *)scheduler 
                            block:(void (^)(id<RACSubscriber> subscriber))block {
    NSCParameterAssert(scheduler != nil);
    NSCParameterAssert(block != NULL);

    RACSignal *signal_1 = [RACSignal
                           createSignal:^ id (id<RACSubscriber> subscriber) {
                               block(subscriber);
                               return nil;
                           }];

    RACSubject *signal_2 = [RACReplaySubject subject];
    RACMulticastConnection *connection = [signal_1 multicast:signal_2];

    RACSignal *signal_3 = [RACSignal
                           createSignal:^ id (id<RACSubscriber> subscriber) {
                               [connection.signal subscribe:subscriber];
                               [connection connect];
                               return nil;
                           }];

    RACSignal *signal_4 = [signal_3 subscribeOn:scheduler];

    return [signal_4 setNameWithFormat:@"+startLazilyWithScheduler: %@ block:", scheduler];
}
```
可知，在使用该方法时，最终得到的信号流是 signal_4 ，那么参见 subscribeOn: 方法可知，每当订阅者订阅信号流 signal_4 时，都会使得 signal_3 的 subscribe 方法调用。
```
- (RACSignal *)subscribeOn:(RACScheduler *)scheduler {
    return [[RACSignal createSignal:^(id<RACSubscriber> subscriber) {
        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];

        RACDisposable *schedulingDisposable = [scheduler schedule:^{
            RACDisposable *subscriptionDisposable = [self subscribe:subscriber];

            [disposable addDisposable:subscriptionDisposable];
        }];

        [disposable addDisposable:schedulingDisposable];
        return disposable;
    }] setNameWithFormat:@"[%@] -subscribeOn: %@", self.name, scheduler];
}
```
那就意味着下面的代码被执行：
```
[connection.signal subscribe:subscriber];
[connection connect];
```
connection.signal 就是 signal_2 ，其是 RACReplaySubject 类型，既可以是信号流又可以是订阅者，其会将接收到的所有信号量保存，每当被订阅时，其会将保存的信号量依次发给这个新的订阅者，所以这是个可以回放信号量的信号流。

接着就是 connect 方法的调用，参见下面的代码：
```
- (RACDisposable *)connect {
    BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &_hasConnected);

    if (shouldConnect) {
        self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
    }

    return self.serialDisposable;
}
```
这个 self.sourceSignal 就是 signal_1 ，而对其订阅会使得其所持有的 didSubscribe 代码块执行，并且从 connect 方法可以知道其只执行一次，那便表示最初的 block 代码只会执行一次。

综上所述，startLazilyWithScheduler:block: 方法的调用会获取一个信号流，该信号流会重播 signal_2 信号流的信号量，而能接收多少信号量，关键在于 block 中产生了多少信号量，如下面的例子：
```
self.signal = [RACSignal startLazilyWithScheduler:RACScheduler.immediateScheduler 
                                block:^(id<RACSubscriber>  _Nonnull subscriber) {

          //其实这个 subscriber 就是 signal_2
        [subscriber sendNext:@"replay-0"];
        [subscriber sendNext:@"replay-1"];
        [subscriber sendCompleted];
    }];

[self.signal subscribeNext:^(id  _Nullable x) {
        NSLog(@"x = %@",x);
    }];    
```
打印结果：
```
2018-08-02 19:24:33.948200+0800 testP[3785:206370] x = replay-0
2018-08-02 19:24:33.948405+0800 testP[3785:206370] x = replay-1
```
####startEagerlyWithScheduler:block:
```
+ (RACSignal *)startEagerlyWithScheduler:(RACScheduler *)scheduler block:(void (^)(id<RACSubscriber> subscriber))block {
	NSCParameterAssert(scheduler != nil);
	NSCParameterAssert(block != NULL);

	RACSignal *signal = [self startLazilyWithScheduler:scheduler block:block];
	// Subscribe to force the lazy signal to call its block.
	[[signal publish] connect];
	return [signal setNameWithFormat:@"+startEagerlyWithScheduler: %@ block:", scheduler];
}

- (RACMulticastConnection *)publish {
    RACSubject *subject = [[RACSubject subject] setNameWithFormat:@"[%@] -publish", self.name];
    RACMulticastConnection *connection = [self multicast:subject];
    return connection;
}
```
这个方法同上一个方法类似，区别在于该方法创建的信号流会直接触发 block 的执行，当然该 block 也是只执行一次，每当对返回的信号流进行订阅时，就会重播 block 中产生的信号量。

值得注意的是，RACSubject 会将所有的订阅者保存（上一个方法也是一样），并且每当产生一个信号量时，该信号量会被发送给所有的订阅者，所以当订阅者不再需要时，应将其清理，避免其接收额外的信号量。

如下例子，如果不进行清理，随着按钮的点击，信号量将重复打印。
```
self.eagerSignal = [RACSignal startEagerlyWithScheduler:RACScheduler.immediateScheduler 
                                            block:^(id<RACSubscriber>  _Nonnull subscriber) {
        [subscriber sendNext:@"replay-0"];
        [subscriber sendNext:@"replay-1"];
        [NSTimer scheduledTimerWithTimeInterval:6 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [subscriber sendNext:@"replay-3"];

        }];
    }];

//每一次点击，都将多出一个订阅者
- (IBAction)click:(id)sender {
    [self.eagerSignal subscribeNext:^(id  _Nullable x) {
        NSLog(@"x = %@",x);
    }];
}

//产生新的订阅者前，先将原订阅者清理
- (IBAction)click:(id)sender {
[self.disposable dispose];
    self.disposable = [self.eagerSignal subscribeNext:^(id  _Nullable x) {
        NSLog(@"x = %@",x);
    }];
}
```
###重写方法
####empty
该方法返回一个 RACEmptySignal 共享实例对象，该信号流不同于 never 方法返回的信号流，前者被订阅时会立即产生结束信号量，而后者不会产生信号量。

####return:
该方法返回一个 RACReturnSignal 信号流，该信号流被订阅时会立即产生一个包含一个指定值的信号量，而后产生结束信号量。

####bind:
学习 RACStream 类可知，其几乎所有的方法最终都会调用 bind: 方法，所以理解该方法的工作对于理解其他方法至关重要。

bind(绑定):绑定一个信号，可以做中间层处理，返回值是信号。当value改变时，就会触发bing的block，执行完毕后，才会调用订阅的信号。
```
typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);
```
该类型包含两个参数和一个信号流返回值。

参见 bind: 方法的代码，为便于分析，进行了调整。
```
- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    NSCParameterAssert(block != NULL);

    RACSignal *signal_1 = [RACSignal createSignal:^(id<RACSubscriber> subscriber) {
        RACSignalBindBlock bindingBlock = block();

        __block volatile int32_t signalCount = 1;   // indicates self

        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

        void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) {
            if (OSAtomicDecrement32Barrier(&signalCount) == 0) {
                [subscriber sendCompleted];
                [compoundDisposable dispose];
            } else {
                [compoundDisposable removeDisposable:finishedDisposable];
            }
        };

        void (^addSignal)(RACSignal *) = ^(RACSignal *signal) {
            OSAtomicIncrement32Barrier(&signalCount);

            RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];
            [compoundDisposable addDisposable:selfDisposable];

            RACDisposable *disposable = [signal subscribeNext:^(id x) {
                [subscriber sendNext:x];
            } error:^(NSError *error) {
                [compoundDisposable dispose];
                [subscriber sendError:error];
            } completed:^{
                @autoreleasepool {
                    completeSignal(selfDisposable);
                }
            }];

            selfDisposable.disposable = disposable;
        };

        @autoreleasepool {
            RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];
            [compoundDisposable addDisposable:selfDisposable];

            RACDisposable *bindingDisposable = [self subscribeNext:^(id x) {
                // Manually check disposal to handle synchronous errors.
                if (compoundDisposable.disposed) return;

                BOOL stop = NO;
                id signal = bindingBlock(x, &stop);

                @autoreleasepool {
                    if (signal != nil) addSignal(signal);
                    if (signal == nil || stop) {
                        [selfDisposable dispose];
                        completeSignal(selfDisposable);
                    }
                }
            } error:^(NSError *error) {
                [compoundDisposable dispose];
                [subscriber sendError:error];
            } completed:^{
                @autoreleasepool {
                    completeSignal(selfDisposable);
                }
            }];

            selfDisposable.disposable = bindingDisposable;
        }

        return compoundDisposable;
    }];

    return [signal_1 setNameWithFormat:@"[%@] -bind:", self.name];
}
```
该方法涉及 3 个信号流，调用该 bind: 方法的源信号流 signal_0，该方法返回的新信号流 signal_1，以及 block 代码块返回值的调用所返回的信号流 signal。

从执行过程来解析，当返回的 signal_1 信号流被订阅时，bind: 的参数 block 将被调用，那么便意味着 signal_0 源信号流被订阅，接着便是 signal_0 产生信号流，nextBlock 被调用，从而 bindingBlock 被调用，返回 signal 信号流，如下代码片段：
```
BOOL stop = NO;
id signal = bindingBlock(x, &stop);

@autoreleasepool {
    if (signal != nil) addSignal(signal);
    if (signal == nil || stop) {
        [selfDisposable dispose];
        completeSignal(selfDisposable);
    }
}
```
可见，如果 signal 存在，那么便会调用下面的代码：
```
RACDisposable *disposable = [signal subscribeNext:^(id x) {
                [subscriber sendNext:x];
            } error:^(NSError *error) {
                [compoundDisposable dispose];
                [subscriber sendError:error];
            } completed:^{
                @autoreleasepool {
                    completeSignal(selfDisposable);
                }
            }];
```
可见，其对 signal 进行了订阅，并且会将接收到的信号量传递给 bind: 方法返回的信号流 signal_1 的订阅者，结合父类的 map: 方法来理解，可知上面的 signal 被订阅时，立即就接收到了信号量，从而传递给订阅者了。
```
- (__kindof RACStream *)map:(id (^)(id value))block {
    NSCParameterAssert(block != nil);

    Class class = self.class;

    return [[self flattenMap:^(id value) {
        return [class return:block(value)];
    }] setNameWithFormat:@"[%@] -map:", self.name];
}

- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block {
    Class class = self.class;

    return [[self bind:^{
        return ^(id value, BOOL *stop) {
            id stream = block(value) ?: [class empty];
            NSCAssert([stream isKindOfClass:RACStream.class], @"Value returned from -flattenMap: is not a stream: %@", stream);

            return stream;
        };
    }] setNameWithFormat:@"[%@] -flattenMap:", self.name];
}
```
综上所述，可以对 bind: 这样理解，其将参数 block 的返回值返回的 signal 信号量绑定到调用该方法的 signal_0 源信号流，前者的信号量总是来自后者，而其又会将信号量转发给订阅了 bind: 方法返回的 signal_1 信号流的订阅者。

####concat:
拼接信号流，将提供的参数信号流拼接在源信号流的后面，当源信号流结束传递信号量后便开始接收参数信号流的信号量，这里源信号流停止接收必须是正常的停止，不能是因为错误引起的。
```
- (RACSignal *)concat:(RACSignal *)signal {
    return [[RACSignal createSignal:^(id<RACSubscriber> subscriber) {
        RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];

        RACDisposable *sourceDisposable = [self subscribeNext:^(id x) {
            [subscriber sendNext:x];
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            RACDisposable *concattedDisposable = [signal subscribe:subscriber];
            [compoundDisposable addDisposable:concattedDisposable];
        }];

        [compoundDisposable addDisposable:sourceDisposable];
        return compoundDisposable;
    }] setNameWithFormat:@"[%@] -concat: %@", self.name, signal];
}
```
####zipWith:
将源信号流中的一个信号量同参数信号流中的一个信号量封装为一个信号量通过该方法返回的新的信号流进行传递。组合的信号量必须是来自双方新的信号量，依序对应，只有两个信号流都有信号量时，才会产生一个新的信号量，如果任意一个信号流结束传递，那么该信号流也随之关闭。
```
- (RACSignal *)zipWith:(RACSignal *)signal {
    NSCParameterAssert(signal != nil);

    return [[RACSignal createSignal:^(id<RACSubscriber> subscriber) {
        __block BOOL selfCompleted = NO;
        NSMutableArray *selfValues = [NSMutableArray array];

        __block BOOL otherCompleted = NO;
        NSMutableArray *otherValues = [NSMutableArray array];

        void (^sendCompletedIfNecessary)(void) = ^{
            @synchronized (selfValues) {
                BOOL selfEmpty = (selfCompleted && selfValues.count == 0);
                BOOL otherEmpty = (otherCompleted && otherValues.count == 0);
                if (selfEmpty || otherEmpty) [subscriber sendCompleted];
            }
        };

        void (^sendNext)(void) = ^{
            @synchronized (selfValues) {
                if (selfValues.count == 0) return;
                if (otherValues.count == 0) return;

                RACTuple *tuple = RACTuplePack(selfValues[0], otherValues[0]);
                [selfValues removeObjectAtIndex:0];
                [otherValues removeObjectAtIndex:0];

                [subscriber sendNext:tuple];
                sendCompletedIfNecessary();
            }
        };

        RACDisposable *selfDisposable = [self subscribeNext:^(id x) {
            @synchronized (selfValues) {
                [selfValues addObject:x ?: RACTupleNil.tupleNil];
                sendNext();
            }
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            @synchronized (selfValues) {
                selfCompleted = YES;
                sendCompletedIfNecessary();
            }
        }];

        RACDisposable *otherDisposable = [signal subscribeNext:^(id x) {
            @synchronized (selfValues) {
                [otherValues addObject:x ?: RACTupleNil.tupleNil];
                sendNext();
            }
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            @synchronized (selfValues) {
                otherCompleted = YES;
                sendCompletedIfNecessary();
            }
        }];

        return [RACDisposable disposableWithBlock:^{
            [selfDisposable dispose];
            [otherDisposable dispose];
        }];
    }] setNameWithFormat:@"[%@] -zipWith: %@", self.name, signal];
}
```
从源码中可知，当该方法返回的信号流被订阅时，源信号流和参数信号流都会被订阅，并且他们传递的信号量都会被保存，当能够组合为一个新的信号量传递给创建的信号流时，被保存的两个信号量便会从数组中删除，而当任意一个信号流结束时，订阅者便随之结束监听信号流。

###订阅方法
####subscribe:
信号流中的订阅方法十分重要，她决定着接收到信号量的订阅者所要执行的操作。通常情况下，我们只需要使用信号流提供的订阅方法，指定接收到某种信号量后所需要执行的代码块即可。因为，在框架中会自动创建一个 RACSubscriber 实例对象作为订阅者，该对象持有我们指定的操作代码块。而后，信号流持有的 didSubscribe 代码块会被执行，该订阅者对象会作为该代码块的参数进行传递。
```
- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
    NSCAssert(NO, @"This method must be overridden by subclasses");
    return nil;
}
```
这个订阅方法是内部方法，RACSignal 的所有子类必须重写她，因为其他的订阅方法都会调用该方法。一般要指定接收到普通信号量后的操作、结束信号量的操作以及错误信号量的操作，几需要提供三个代码块，常用的方法如下：
```
- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock {
    NSCParameterAssert(nextBlock != NULL);

    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];
    return [self subscribe:o];
}

- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock completed:(void (^)(void))completedBlock {
    NSCParameterAssert(nextBlock != NULL);
    NSCParameterAssert(completedBlock != NULL);

    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:completedBlock];
    return [self subscribe:o];
}

- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock {
    NSCParameterAssert(nextBlock != NULL);
    NSCParameterAssert(errorBlock != NULL);
    NSCParameterAssert(completedBlock != NULL);

    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];
    return [self subscribe:o];
}
```
当然，三个参数的组合有7种，所以有7个方法与之对应。

我们常说信号流结束，其实质是订阅该信号流的订阅者实例被清理了，并不是意味着信号流不能够再传递信号量了，如果该信号流被显式持有，那么可以再次订阅该信号流来达到信号量的监听。当然，不管是信号流还是信号量，都是抽象的概念，其实质是作为响应式编程中目标操作和触发条件的纽带。

###RACDynamicSignal
子类 RACDynamicSignal 的工作很重要，其提供了一个创建实例的方法，如下：
```
+ (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe {
    RACDynamicSignal *signal = [[self alloc] init];
    signal->_didSubscribe = [didSubscribe copy];
    return [signal setNameWithFormat:@"+createSignal:"];
}
```
这个方法将传递的代码块参数进行复制保留，以待合适的时机进行执行，而时机就在其重写的 subscribe: 方法中。
```
- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
    NSCParameterAssert(subscriber != nil);

    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber
                                 signal:self disposable:disposable];

    if (self.didSubscribe != NULL) {
        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
            RACDisposable *innerDisposable = self.didSubscribe(subscriber);
            [disposable addDisposable:innerDisposable];
        }];

        [disposable addDisposable:schedulingDisposable];
    }

    return disposable;
}
```
该方法是父类抽象方法的具体实现，每当有订阅者订阅信号流时，便会调用该方法，其所执行的主要任务就是执行创建当前信号流时所传递的 didSubscribe 代码块，另外，便是将代码块返回的 innerDisposable 实例添加到 disposable 中，而 disposable 则被订阅者 subscriber 所持有，一旦信号流产生结束或者错误信号，那么便可以通过其所持有的 disposable 进行清理工作。

从上面的代码可知，RACSubscriber 类型的订阅者 subscriber 会被进一步封装为 RACPassthroughSubscriber 实例对象，当然，两者都遵循 <RACSubscriber> 协议。

###RACEmptySignal
空信号，用来实现 RACSignal 的 +empty 方法。

###RACErrorSignal
错误信号，用来实现 RACSignal 的 +error: 方法。

该类创建一个持有指定错误 error 信息的 RACErrorSignal 实例，当订阅者订阅该信号流时，则立即发送该错误信号量，并且订阅者随之结束对信号流的订阅。
```
- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
    NSCParameterAssert(subscriber != nil);

    return [RACScheduler.subscriptionScheduler schedule:^{
        [subscriber sendError:self.error];
    }];
}
```
从这个重写方法可知，订阅者订阅该信号流时，只会接收到一次信号量，并且订阅时并不会执行类似 didSubscribe 的自定义操作（创建时就没有传递该参数），如果要再次获取该错误信息，则需要重新订阅该信号流。

###RACReturnSignal
一元信号，用来实现 RACSignal 的 +return: 方法。

###RACChannelTerminal
通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。

##RACSubscriber
###RACSubscriber协议
现在，我们已经知道信号源是什么了，为了获取信号源中的值，我们需要对信号源进行订阅。在 ReactiveCocoa 中，订阅者是一个抽象的概念，所有实现了 RACSubscriber 协议的类都可以作为信号源的订阅者。

* - (void)sendNext:(id)value; 将value值发送给订阅者，value可以为nil。从订阅者角度看就是从 RACSignal接收next事件。
* - (void)sendError:(NSError *)error; 发送错误信息给订阅者，错误信息可以为nil。注意，这个方法会终止信号的订阅，以后不会再发送信号的任何信息。从订阅者角度看就是从 RACSignal接收error事件。
* - (void)sendCompleted; 发送完成信息给订阅者。注意，这个方法也会终止信号的订阅，以后不会再发送信号的任何信息。从订阅者角度看就是从 RACSignal接收completed事件。
* - (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable; 订阅者添加一个代表订阅信息的清理对象。注意，一个订阅者可以订阅多个信号，相应的，它也可以拥有多个清理对象。一旦任何错误信息或者完成信息终止了任何一个信号的订阅，就必须终止所有信号的订阅。

订阅者对信号源的一次订阅过程可以抽象为：通过 RACSignal 的 -subscribe: 方法传入一个订阅者，并最终返回一个 RACDisposable 对象的过程：
![](https://upload-images.jianshu.io/upload_images/2121311-c43e34505660bbcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

###RACSubscriber内部类
RACSubscriber是 ReactiveCocoa 框架中的一个内部类。其遵循 RACSubscriber协议，所以是作为一个订阅者订阅信号流。
```
+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed;
```
该实例化方法，完成一个订阅者的初始化工作。
```
+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed {
    RACSubscriber *subscriber = [[self alloc] init];

    subscriber->_next = [next copy];
    subscriber->_error = [error copy];
    subscriber->_completed = [completed copy];

    return subscriber;
}
```
初始化RACSubscriber对象，并将next、error、completed保存到实例变量中，以备后续使用。

查看init方法的实现：
```
- (instancetype)init {
	self = [super init];

	@unsafeify(self);

	RACDisposable *selfDisposable = [RACDisposable disposableWithBlock:^{
		@strongify(self);

		@synchronized (self) {
			self.next = nil;
			self.error = nil;
			self.completed = nil;
		}
	}];

	_disposable = [RACCompoundDisposable compoundDisposable];
	[_disposable addDisposable:selfDisposable];

	return self;
}
```
重写init方法，完成实例变量_disposable的初始化，并将实例变量next、error、completed的清理添加到_disposable的清理工作中。

```
- (void)dealloc {
    [self.disposable dispose];
}
```
重写dealloc，调用清理对象disposable的清理方法，完成整个清理工作。

```
- (void)sendNext:(id)value {
    @synchronized (self) {
        void (^nextBlock)(id) = [self.next copy];
        if (nextBlock == nil) return;

        nextBlock(value);
    }
}
```
实现协议的sendNext方法，该方法同步调用nextBlock块，执行block中的任务。

```
- (void)sendError:(NSError *)e {
    @synchronized (self) {
        void (^errorBlock)(NSError *) = [self.error copy];
        [self.disposable dispose];

        if (errorBlock == nil) return;
        errorBlock(e);
    }
}
```
完成协议sendError方法， 该方法同步调用errorBlock块，执行block中的任务。

```
- (void)sendCompleted {
    @synchronized (self) {
        void (^completedBlock)(void) = [self.completed copy];
        [self.disposable dispose];

        if (completedBlock == nil) return;
        completedBlock();
    }
}
```
完成协议sendCompleted方法， 该方法同步调用completedBlock块，执行block中的任务。

```
- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)otherDisposable {
    if (otherDisposable.disposed) return;

    RACCompoundDisposable *selfDisposable = self.disposable;
    [selfDisposable addDisposable:otherDisposable];

    @unsafeify(otherDisposable);

    // If this subscription terminates, purge its disposable to avoid unbounded
    // memory growth.
    [otherDisposable addDisposable:[RACDisposable disposableWithBlock:^{
        @strongify(otherDisposable);
        [selfDisposable removeDisposable:otherDisposable];
    }]];
}
```
该方法会将otherDisposable添加到selfDisposable中，这样子如果该订阅者终止了信号的订阅，也会将otherDisposable清理掉；同时otherDisposable也添加了一个清理对象RACDisposable,这样子如果外部调用了otherDisposable的清理工作，便会将otherDisposable从selfDisposable中移除，防止多余的内存占用。

###RACPassthroughSubscriber 
RACPassthroughSubscriber 是 ReactiveCocoa 框架中的一个内部类，其遵循RACSubscriber协议，所以可以作为一个订阅者订阅信号流。它是 RACSubscriber类的一个装饰器，封装了一个真正的订阅者RACSubscriber对象，它负责转发所有事件给这个真正的订阅者，而当此次订阅被取消时，它就会停止转发。RACPassthroughSubscriber实现了RACSubscriber协议的所有方法，但是内部都是调用RACSubscriber对象的实现。
```
- (instancetype)initWithSubscriber:(id<RACSubscriber>)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable;
```
* subscriber 是真正的订阅者，不能为空
* signal 是传递信号量的信号流
* disposable 若是已经清理，那么该类将不再转发信号量

##信号的操作(Operations分类)

##信号扩展（RACSignalSupport分类）
RACSignalSupport 是 ReactiveCocoa 框架中为 CocoaTouch 框架中的一些类声明的扩展类，其旨在为这些类添加信号流的特性。

###处理视图的重用
MKAnnotationView (RACSignalSupport)
UICollectionReusableView (RACSignalSupport)
UITableViewCell (RACSignalSupport)
UITableViewHeaderFooterView (RACSignalSupport)

当上面类的实例对象调用 prepareForReuse 方法时，扩展的属性 rac_prepareForReuseSignal 作为信号流便会传递一个 RACUnit 信号量。
```
@property (nonatomic, strong, readonly) RACSignal<RACUnit *> *rac_prepareForReuseSignal;
```
通常，使用该属性来取消订阅者的订阅，因为当控件被重用时，可能会再次对该信号流进行订阅，如果不取消前一次进行的订阅，那么可能造成重复的订阅或错误的订阅。

使用方式如下：
```
[[[self.cancelButton rac_signalForControlEvents:UIControlEventTouchUpInside] takeUntil:self.rac_prepareForReuseSignal] subscribeNext:^(UIButton *x) { // do other things }]; 
```
当 self.rac_prepareForReuseSignal 发出信号量时，即视图被重用，那么该按钮不再响应原定的操作。当然，重用时，会为该按钮绑定新的任务。

RACUnit 是 ReactiveCocoa 框架为了表示空信号量而声明的类，使用时应调用其类方法 defaultUnit 获取全局对象。

###UIActionSheet (RACSignalSupport)
该分类提供了一个方法返回一个信号流，该信号流传递的信号量是选择点击 UIActionSheet 中的按钮索引，由此可以推断出点击的是哪个按钮，而进行相应的任务。
```
@property (nonatomic, strong, readonly) RACDelegateProxy *rac_delegateProxy;

- (RACSignal<NSNumber *> *)rac_buttonClickedSignal;
```
当调用 rac_buttonClickedSignal 方法时，rac_delegateProxy 属性会成为 UIActionSheet 实例对象的代理，而其原本的代理会赋值给 rac_delegateProxy 的属性 rac_proxiedDelegate ，所有 rac_delegateProxy 无法处理的消息都会转给 rac_proxiedDelegate 处理。

所以如果是在调用了 rac_buttonClickedSignal 方法之后，对当前对象的 delegate 进行赋值，那么 rac_buttonClickedSignal 将不会传递按钮索引。

###UIAlertView (RACSignalSupport)
```
@property (nonatomic, strong, readonly) RACDelegateProxy *rac_delegateProxy; - (RACSignal<NSNumber *> *)rac_buttonClickedSignal; - (RACSignal<NSNumber *> *)rac_willDismissSignal;
```
该分类同 UIActionSheet (RACSignalSupport) 类似，rac_buttonClickedSignal 会传递点击的按钮的索引，而 rac_willDismissSignal 会传递使视图消失的按钮的索引。

###UIControl (RACSignalSupport)
使用 rac_signalForControlEvents 方法，可以获取一个信号流，当控件指定的事件触发时，该信号流便会将与该事件相关连的控件传递给订阅者。
```
- (RACSignal<__kindof UIControl *> *)rac_signalForControlEvents:(UIControlEvents)controlEvents;
```

###UIControl (RACSignalSupportPrivate)
在 RACSignalSupportPrivate 分类中，提供了一个根据事件读取控件属性值的信号流，并且还可以通过发送信号量改变指定属性的值。
```
- (RACChannelTerminal *)rac_channelForControlEvents:(UIControlEvents)controlEvents key:(NSString *)key nilValue:(nullable id)nilValue;
```
当指定的事件触发后，该控件指定的属性 key 的值便会通过该方法返回的信号流 RACChannelTerminal 实例对象进行传递，而主动调用该流的 sendNext: 方法时，可以设置 key 所对应的属性值。如果提供的参数值为 nil ，则会设置属性为 nilValue 的值，而 nilValue 本身也可以是 nil 。

利用该方法进而扩展了下面的分类：
1.UIDatePicker (RACSignalSupport)
下面的方法，返回一个 RACChannelTerminal 实例，这样便可以获得 UIDatePicker 的属性 date 的变化值，另外，对其值的修改也十分方便。
```
- (RACChannelTerminal *)rac_newDateChannelWithNilValue:(NSDate *)nilValue { return [self rac_channelForControlEvents:UIControlEventValueChanged key:@keypath(self.date) nilValue:nilValue]; }
```
2.UISegmentedControl (RACSignalSupport)
该分类同 UIDatePicker (RACSignalSupport) 分类类似，返回的信号流传递的是选中部分的索引，主动传递信号量时，是对 UISegmentedControl 控件选中部分的设置。
```
- (RACChannelTerminal *)rac_newSelectedSegmentIndexChannelWithNilValue:(NSNumber *)nilValue { return [self rac_channelForControlEvents:UIControlEventValueChanged key:@keypath(self.selectedSegmentIndex) nilValue:nilValue]; }
```
3.UISlider (RACSignalSupport)
```
- (RACChannelTerminal *)rac_newValueChannelWithNilValue:(NSNumber *)nilValue { return [self rac_channelForControlEvents:UIControlEventValueChanged key:@keypath(self.value) nilValue:nilValue]; }
```
4.UIStepper (RACSignalSupport)
```
- (RACChannelTerminal*)rac_newValueChannelWithNilValue:(NSNumber *)nilValue { 
    return [self rac_channelForControlEvents:UIControlEventValueChanged key:@keypath(self.value) nilValue:nilValue]; 
    } 
```
5.UISwitch (RACSignalSupport)
```
- (RACChannelTerminal*)rac_newOnChannel 
{ 
    return [self rac_channelForControlEvents:UIControlEventValueChanged key:@keypath(self.on) nilValue:@NO]; 
}
```
###UIGestureRecognizer (RACSignalSupport)
该方法返回一个信号流，当当前手势被触发后，信号流便会将该手势传递给订阅者。
```
- (RACSignal<__kindof UIGestureRecognizer *> *)rac_gestureSignal;
```

###UIImagePickerController (RACSignalSupport)
```
@property (nonatomic, strong, readonly) RACDelegateProxy *rac_delegateProxy;

- (RACSignal<NSDictionary *> *)rac_imageSelectedSignal;
```
调用 rac_imageSelectedSignal 方法，获取一个信号流，其会传递被选中的图片信息。

###UITextField (RACSignalSupport)
该分类中 rac_textSignal 方法返回的信号流，每当控件的任意事件被触发后，都会将控件的文本发送给订阅者。

方法 rac_newTextChannel 返回的信号流，不仅会传递控件的文本，还可以设置控件的文本。
```
- (RACSignal<NSString *> *)rac_textSignal;

- (RACChannelTerminal<NSString *> *)rac_newTextChannel;
```
###UITextView (RACSignalSupport)
当订阅 rac_textSignal 方法返回的信号流时，当前控件的文本会发送给订阅者，而后，每当文本发生变动时，都会向订阅者发送变动的文本。
```
@property (nonatomic, strong, readonly) RACDelegateProxy *rac_delegateProxy;

- (RACSignal<NSString *> *)rac_textSignal;
```

##RACSubject

###RACSubject是什么
我们知道只要创建一个信号，在有一个订阅者去订阅它我们就可以发送消息了。但是有没有一个对象既可以发送消息又可以订阅消息呢？ 这时候RACSubject 就出现了，因为它继承了RACSignal信号类又遵守RACSubscribe协议，这样就既能发送，又能订阅信号了。它的使用场景可以做为代理来使用或者用来绑定ViewModel和View。此外，RACSubject是热信号。

RACSubject 同样重写了订阅方法 - (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber ，在该方法中，订阅者将会被保存，并且不同于 RACSignal 的订阅，这里并不会，当然也没有什么 didSubscribe 代码会被触发执行。

创建方法：+ (instancetype)subject;
在这个类中，关键的方法如下：
```
- (void)enumerateSubscribersUsingBlock:(void (^)(id<RACSubscriber> subscriber))block {
    NSArray *subscribers;
    @synchronized (self.subscribers) {
        subscribers = [self.subscribers copy];
    }

    for (id<RACSubscriber> subscriber in subscribers) {
        block(subscriber);
    }
}

#pragma mark RACSubscriber

- (void)sendNext:(id)value {
    [self enumerateSubscribersUsingBlock:^(id<RACSubscriber> subscriber) {
        [subscriber sendNext:value];
    }];
}
```
sendNext: 是协议RACSubscriber中的方法，可见其只是调用了 enumerateSubscribersUsingBlock: 方法，在该方法中，会遍历保存的所有的订阅者，然后将指定的信号量传递出去。类似的，在发送错误或结束信号量时，同样会转发给每个订阅者。
###RACSubject的使用


###RACSubject的原理

###RACBehaviorSubject
RACBehaviorSubject 是 RACSubject 的子类，同父类一样，其也会保存所有的订阅者，每一次传递的信号量都会传递给所有的订阅者，不同的是，当订阅者订阅该信号流时，其会将最近一次发送的信号量发送给订阅者，如果还没发送过信号量，就发送默认值，该默认值是在创建该信号流时指定的。
```
+ (instancetype)behaviorSubjectWithDefaultValue:(id)value {
    RACBehaviorSubject *subject = [self subject];
    subject.currentValue = value;
    return subject;
}
```
###RACGroupedSignal
RACGroupedSignal 是 RACSubject 的子类，其拥有一个 key 属性用来标记相同组的信号流。
```
+ (instancetype)signalWithKey:(id<NSCopying>)key {
    RACGroupedSignal *subject = [self subject];
    subject.key = key;
    return subject;
}
```
###RACReplaySubject
RACReplaySubject 是 RACSubject 的子类，这个信号流同父类一样保存了所有的订阅者，并且还保存了接收到的所有信号量，至于保存的数量，可以在初始化时指定，如果使用 init 方法，那么默认为 RACReplaySubjectUnlimitedCapacity 即不限定数量。
```
+ (instancetype)replaySubjectWithCapacity:(NSUInteger)capacity {
	return [(RACReplaySubject *)[self alloc] initWithCapacity:capacity];
}

- (instancetype)init {
	return [self initWithCapacity:RACReplaySubjectUnlimitedCapacity];
}

- (instancetype)initWithCapacity:(NSUInteger)capacity {
	self = [super init];
	
	_capacity = capacity;
	_valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);
	
	return self;
}
```
我们发现内部创建了一个_valuesReceived数组，顾名思义是用来存放收到的值。

每当订阅该信号流时，该信号流都会将保存的信号量发送给订阅者，即使该信号流接收到的错误或结束信号量。如果该信号流已经结束，那么每一次订阅者订阅，都只是接收固定的信号量，而后结束，所以该信号流也称作重播信号流。
```
- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
    RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

    RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
        @synchronized (self) {
            for (id value in self.valuesReceived) {
                if (compoundDisposable.disposed) return;

                [subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];
            }

            if (compoundDisposable.disposed) return;

            if (self.hasCompleted) {
                [subscriber sendCompleted];
            } else if (self.hasError) {
                [subscriber sendError:self.error];
            } else {
                RACDisposable *subscriptionDisposable = [super subscribe:subscriber];
                [compoundDisposable addDisposable:subscriptionDisposable];
            }
        }
    }];

    [compoundDisposable addDisposable:schedulingDisposable];

    return compoundDisposable;
}
```

该类重写了发送方法，如下，当存储的信号量有限制时，会不断删除最早接收到的信号量。
```
- (void)sendNext:(id)value {
    @synchronized (self) {
        [self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];
        [super sendNext:value];

        if (self.capacity != RACReplaySubjectUnlimitedCapacity && self.valuesReceived.count > self.capacity) {
            [self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)];
        }
    }
}
```
所以，对于RACReplaySubject，即使是先发送后订阅的情况，也能收到前面的数据。

##RACCommand
RACCommand 是一个在 ReactiveCocoa 中比较复杂的类，大多数使用 ReactiveCocoa 的人，尤其是初学者并不会经常使用它。

在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。

和 RACSignal 等元素不同，RACCommand 并不表示数据流，它只是一个继承自 NSObject 的类，但是它却可以用来创建和订阅用于响应某些事件的信号。

在用于与 UIKit 组件进行交互或者执行包含副作用的操作时，RACCommand 能够帮助我们更快的处理并且响应任务，减少编码以及工程的复杂度。

RACCommand代表着与交互后即将执行的一段流程。通常这个交互是UI层级的，比如你点击个Button。RACCommand可以方便的将Button与enable状态进行绑定，也就是当enable为NO的时候，这个RACCommand将不会执行。RACCommand还有一个常见的策略：allowsConcurrentExecution，默认为NO，也就是是当你这个command正在执行的话，你多次点击Button是没有用的。

###RACCommand 的初始化与执行
RACCommand有三个方法，如下，理解了他们便能理解 RACCommand 的作用。
```
- (instancetype)initWithSignalBlock:(RACSignal<ValueType> * (^)(InputType _Nullable input))signalBlock;
- (instancetype)initWithEnabled:(nullable RACSignal<NSNumber *> *)enabledSignal signalBlock:(RACSignal<ValueType> * (^)(InputType _Nullable input))signalBlock;

- (RACSignal<ValueType> *)execute:(nullable InputType)input;
```
其中前面两个是初始化方法，最后一个是执行方法。初始化方法一最终调用初始化方法二。

在 -initWithSignalBlock: 方法的方法签名上，你可以看到在每次 RACCommand 初始化时都会传入一个类型为 RACSignal<ValueType> * (^)(InputType _Nullable input) 的 signalBlock。输入为 InputType 返回值为 RACSignal<ValueType> *，而 InputType 也就是在调用 -execute: 方法时传入的对象。

这也就是 RACCommand 将外部变量（或『副作用』）传入 ReactiveCocoa 内部的方法，你可以理解为 RACCommand 将外部的变量 InputType 转换成了使用 RACSignal 包裹的 ValueType 对象。

由于 RACCommand 在初始化方法中初始化了七个高阶信号，它的实现非常复杂：
```
- (instancetype)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal<id> * (^)(id input))signalBlock {
	self = [super init];

	_addedExecutionSignalsSubject = [RACSubject new];
_allowsConcurrentExecutionSubject = [RACSubject new];
	_signalBlock = [signalBlock copy];

	_executionSignals = ...;
	_errors = ...;
	RACSignal *immediateExecuting = ...;
	_executing = ...;
	RACSignal *moreExecutionsAllowed = ...;
	_immediateEnabled =...;
	_enabled = ...;

	return self;
}
```
#### 表示当前有操作执行的信号
immediateExecuting 是一个用于表示当前是否有任务执行的信号。
```
RACSignal *immediateExecuting = [[[[self.addedExecutionSignalsSubject
    flattenMap:^(RACSignal *signal) {
        return [[[signal
            catchTo:[RACSignal empty]]
            then:^{
                return [RACSignal return:@-1];
            }]
            startWith:@1];
    }]
    scanWithStart:@0 reduce:^(NSNumber *running, NSNumber *next) {
        return @(running.integerValue + next.integerValue);
    }]
    map:^(NSNumber *count) {
        return @(count.integerValue > 0);
    }]
    startWith:@NO];
```

#### 表示是否允许更多操作执行的信号


##命令扩展RACCommandSupport
在 ReactiveCocoa 框架中，RACCommand 类可以将信号流作为信号量进行接收，从而可以封装一系列处理不同任务的信号流。为了扩展该类的用法，框架为下面几个类声明了 RACCommandSupport 分类。
* UIBarButtonItem
* UIButton
* UIRefreshControl

这三个类所扩展的分类中都声明了一个属性，并实现了设置和获取方法。
```
@property (nonatomic, strong, nullable) RACCommand<__kindof UIRefreshControl *, id> *rac_command;
```
UIBarButtonItem (RACCommandSupport) 和 UIButton (RACCommandSupport) 的实现方式类似，在调用下面的设置方法时，都会将控件的可用性绑定到命令的可用性上。
```
- (void)setRac_command:(RACCommand *)command {
	···
	disposable = [command.enabled setKeyPath:@keypath(self.enabled) onObject:self];
	···
}
```
除此之外，该设置方法还会将控件的事件响应方法改变为命令的执行方法。
```
- (void)rac_commandPerformAction:(id)sender {
	[self.rac_command execute:sender];
}
```
所以，可以将按钮点击任务封装在 RACCommand 命令中，如下例子：
```
- (void)test 
{
    RACCommand *command = [[RACCommand alloc]initWithSignalBlock:^RACSignal * _Nonnull(UIButton *  _Nullable input) {
        input.tag++;
        RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {
            [subscriber sendNext:[NSString stringWithFormat:@"signal1 send a next signal and input is %@",input]];
            return nil;
        }];
        
        RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {
            [subscriber sendNext:[NSString stringWithFormat:@"signal2 send a next signal and input is %@",input]];
            return nil;
        }];
        
        return input.tag%2 == 1 ? signal1 : signal2;
    }];
    
    command.allowsConcurrentExecution = YES;
    
    self.testBtn.rac_command = command;
    
    [command.executionSignals.switchToLatest subscribeNext:^(id  _Nullable x) {
        NSLog(@"%@",x);
    }];
}
```
如此，便可以通过一个值，如这里的 input.tag ，来执行不同的任务。

运行结果：
```
2018-11-02 15:44:52.776475+0800 testP[4507:556667] signal1 send a next signal and input is <UIButton: 0x7fee1900afe0; frame = (0 0; 100 100); opaque = NO; tag = 1; layer = <CALayer: 0x600000f39100>>
2018-11-02 15:44:53.338504+0800 testP[4507:556667] signal2 send a next signal and input is <UIButton: 0x7fee1900afe0; frame = (0 0; 100 100); opaque = NO; tag = 2; layer = <CALayer: 0x600000f39100>>
```

UIRefreshControl (RACCommandSupport) 分类中设置该属性的实现方式与上面两个分类有所不同，为便于理解，将代码拆分如下：
```
- (void)setRac_command:(RACCommand *)command {
    objc_setAssociatedObject(self, UIRefreshControlRACCommandKey, command, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    [objc_getAssociatedObject(self, UIRefreshControlDisposableKey) dispose];
    
    if (command == nil) return;
    
    RACDisposable *enabledDisposable = [command.enabled setKeyPath:@keypath(self.enabled) onObject:self];
    
    RACSignal *signal1 = [self rac_signalForControlEvents:UIControlEventValueChanged];
    RACSignal *signal2 = [signal1 map:^(UIRefreshControl *x) {
        
        RACSignal *signalInner1 = [command execute:x];
        RACSignal *signalInner2 = [signalInner1 catchTo:[RACSignal empty]];
        RACSignal *signalInner3 = [signalInner2 then:^{
                                      return [RACSignal return:x];
                                  }];
        return signalInner3;
    }];
                          
    RACSignal *signal3 = [signal2 concat];
    RACSignal *signal4 = [signal3 deliverOnMainThread];
    
    RACDisposable *executionDisposable = [signal4 subscribeNext:^(UIRefreshControl *x) {
        [x endRefreshing];
    }];
    
    RACDisposable *commandDisposable = [RACCompoundDisposable compoundDisposableWithDisposables:@[ enabledDisposable, executionDisposable ]];
    objc_setAssociatedObject(self, UIRefreshControlDisposableKey, commandDisposable, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
```
该方法的实现步骤如下：
1. 使用 UIRefreshControlRACCommandKey 将提供的参数 command 绑定到当前控件，完成属性赋值。
2. 使用 UIRefreshControlDisposableKey 处理上个命令的相关释放操作。
3. 判断 command 参数，如果为 nil ，则直接返回，否则继续执行。
4. 将控件的 enabled 属性与 command 的 enabled 属性相绑定，即如控件不可用，那么命令不可执行。
5. 为控件绑定 UIControlEventValueChanged 事件，得到 signal1 信号流，当事件被触发后，该信号流将当前控件作为信号量进行传递。
6. 将接收到的控件信号量进行映射，映射为一个信号流类型的信号量，在信号流 signal2 中传递，在映射之前会先执行命令。
 1）当 signal1 中传递一个信号量时，命令 command 将其当作参数执行命令方法，
 	返回 signalInner1 信号流。
 
 2）signalInner2 信号流传递的信号量同信号流 signalInner1 一样，
 	只是并不会传递错误信号量。
 
 3）当 signalInner2 信号流结束后，即 signalInner1 发送了结束信号量，
 	signalInner3 信号流便会传递最初 signal1 传递的控件信号量。
 
 4）返回最后的映射值 signalInner3 信号流。

7. 接着，signal2 会拼接自身传递的信号量（即信号流 signalInner3），从而得到新的信号流 signal3 。

8. 保证 signal3 的信号量在主线程进行传递，得到 signal4 。

9. 订阅 signal4 信号量，接收到控件信号量时，便停止该控件的刷新。

10. 设置释放操作。

##RACSequence
RACSequence 继承了 RACStream 父类，所以它本身是具有信号流的特性的，这同它的兄弟类 RACSignal 相似，而不同的是，其所传递的信号量由其本身持有，即它持有一系列的值作为信号量传递给被执行的任务。并且，该类实现了 NSFastEnumeration 协议，具有类似于 Cocoa 中集合的特性。

RACSequence 如类簇一般，其包含的 head 和 tail 属性是必须要子类实现其获取方法的。
* head 属性，表示一系列值中的第一个值
* tail 属性，同样是一个 RACSequence 类型的实例，其包含除去第一个值的所有其他值。
* array 属性，获取一个数组，包含该队列包含的所有值
* objectEnumerator 属性，获取一个计数器，方便遍历队列中的所有值
* eagerSequence 属性，根据当前队列获取一个热信号队列，如果当前队列已经是热信号队列，则直接返回自己
* lazySequence 属性，根据当前队列获取一个冷信号队列，如果当前队列已经是冷信号队列，则直接返回自己

RACSequence 类中声明了创建实例的类方法，而它们实际都返回了子类对象。

* 返回一个队列，其所包含的值是动态产生的

```
+ (RACSequence *)sequenceWithHeadBlock:(id (^)(void))headBlock tailBlock:(RACSequence<id> *(^)(void))tailBlock {
	return [[RACDynamicSequence sequenceWithHeadBlock:headBlock tailBlock:tailBlock] setNameWithFormat:@"+sequenceWithHeadBlock:tailBlock:"];
}
```
* 返回一个队列，该队列不包含任何值

```
+ (RACSequence *)empty {
	return RACEmptySequence.empty;
}
```
* 返回一个队列，该队列仅包含所提供的值

```
+ (RACSequence *)return:(id)value {
	return [RACUnarySequence return:value];
}
```
empty 和 return: 方法实际是对父类 RACStream 中方法的重写，当然，重写的不止这两个类方法，还有很多其他实例方法，如 bind:、concat:、zipWith: 等。除了重写方法，该类还重新声明了父类中的一些方法，如 map:、filter:、flatten、ignore:、reduceEach:、startWith: 等，以便方法中的参数或返回值类型更加准确。

除了重写方法，该类还新增了几个方法，来处理其所包含的值。

下面两个方法用来依次计算合并队列中的值，start 为初始计算结果，value 是队列中的值。这两个方法的区别在于用于计算的代码块 reduce 代码块的参数是相反的。
```
- (id)foldLeftWithStart:(id)start reduce:(id (^)(id, id))reduce {
	NSCParameterAssert(reduce != NULL);

	if (self.head == nil) return start;
	
	for (id value in self) {
		start = reduce(start, value);
	}
	
	return start;
}

- (id)foldRightWithStart:(id)start reduce:(id (^)(id, RACSequence *))reduce {
	NSCParameterAssert(reduce != NULL);

	if (self.head == nil) return start;
	
	RACSequence *rest = [RACSequence sequenceWithHeadBlock:^{
		if (self.tail) {
			return [self.tail foldRightWithStart:start reduce:reduce];
		} else {
			return start;
		}
	} tailBlock:nil];
	
	return reduce(self.head, rest);
}
```
如果，队列中包含的值是 [1,2,3]，那么调用两个方法的结果分别是 reduce(reduce(reduce(start, 1), 2), 3) 和 reduce(1, reduce(2, reduce(3, start))) 。
* any: 方法判断队列中是否有值满足检验条件
* all: 方法判断队列中的值是否都满足检验条件
* objectPassingTest: 方法返回队列中第一个满足检验条件的值，如果没有就返回 nil

另外，注意 objectEnumerator 属性的类型是继承了 NSEnumerator 的子类 RACSequenceEnumerator ，它实现了 nextObject 方法。
```
- (id)nextObject {
	id object = nil;
	
	@synchronized (self) {
		object = self.sequence.head;
		self.sequence = self.sequence.tail;
	}
	
	return object;
}
```
###RACArraySequence 
RACArraySequence 是 RACSequence 的子类，可以使用其提供的类方法，根据数组参数以及偏移量获取一个队列信号流。
```
+ (RACSequence *)sequenceWithArray:(NSArray *)array offset:(NSUInteger)offset {
	NSCParameterAssert(offset <= array.count);

	if (offset == array.count) return self.empty;

	RACArraySequence *seq = [[self alloc] init];
	seq->_backingArray = [array copy];
	seq->_offset = offset;
	return seq;
}
```
在该类中，信号量都保存在 backingArray 属性中，当然，信号量是从偏移量 offset 开始的。

此外，其重写的 head 和 tail 方法也十分简单。
```
- (id)head {
	return self.backingArray[self.offset];
}

- (RACSequence *)tail {
	RACSequence *sequence = [self.class sequenceWithArray:self.backingArray offset:self.offset + 1];
	sequence.name = self.name;
	return sequence;
}
```
###RACEagerSequence
RACEagerSequence 是 RACArraySequence 的子类，其只是将一些父类方法进行了重写，并没有声明新的方法。
如其重写的 lazySequence 方法，返回了一个父类类型的实例对象。
```
- (RACSequence *)lazySequence {
	return [RACArraySequence sequenceWithArray:self.array offset:0];
}
```
###RACDynamicSequence 
RACDynamicSequence 是 RACSequence 的子类，其所表示的队列中的信号量是动态生成的。

该类提供了一个类方法用来创建实例，方法有三个参数，dependencyBlock、headBlock 和 tailBlock 。
```
+ (RACSequence *)sequenceWithLazyDependency:(id (^)(void))dependencyBlock headBlock:(id (^)(id dependency))headBlock tailBlock:(RACSequence *(^)(id dependency))tailBlock {
	NSCParameterAssert(dependencyBlock != nil);
	NSCParameterAssert(headBlock != nil);

	RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];
	seq.headBlock = [headBlock copy];
	seq.tailBlock = [tailBlock copy];
	seq.dependencyBlock = [dependencyBlock copy];
	seq.hasDependency = YES;
	return seq;
}
```
当第一次调用 head 方法时，headBlock 代码会被执行，其结果会被保存到 _head 中，并且本身被置空，即其只会被执行一次。

当第一次调用 tail 方法时，tailBlock 代码会被执行，其结果会被保存到 _tail 中，并且本身被置空，即其只会被执行一次。

当 headBlock 或 tailBlock 被执行时，dependencyBlock 的结果可能会作为参数传递给它们，是否传递则取决于 hasDependency 属性值是否为 YES 。

###RACEmptySequence 
RACEmptySequence 是 RACSequence 的子类，其返回一个空的队列信号流，并且使用 empty 方法返回的实例是共享的，也即是一个单例对象。
```
+ (instancetype)empty {
	static id singleton;
	static dispatch_once_t pred;

	dispatch_once(&pred, ^{
		singleton = [[self alloc] init];
	});

	return singleton;
}
```
重写的 head 和 tail 方法，都直接返回 nil 。

###RACIndexSetSequence 
RACIndexSetSequence 是 RACSequence 的子类，表示由索引集合转化来的队列信号流。
```
+ (RACSequence *)sequenceWithIndexSet:(NSIndexSet *)indexSet;
```
类似 RACArraySequence 中的 backingArray 属性，该类也是用一个 indexes 属性保存传递进来的索引序列。

重写的 head 和 tail 方法，如下：
```
- (id)head {
	return @(self.indexes[0]);
}

- (RACSequence *)tail {
	if (self.count <= 1) return [RACSequence empty];

	return [self.class sequenceWithIndexSetSequence:self offset:1];
}
```
对于 tail 方法，可知，是使用了其本身以及一个 offset 偏移量 1 来创建一个新的 RACIndexSetSequence 实例对象。

###RACSignalSequence
RACSignalSequence 是 RACSequence 的子类，该类表示的队列中的信号量是由另外一个信号流传递的。

```
+ (RACSequence *)sequenceWithSignal:(RACSignal *)signal {
	RACSignalSequence *seq = [[self alloc] init];

	RACReplaySubject *subject = [RACReplaySubject subject];
	[signal subscribeNext:^(id value) {
		[subject sendNext:value];
	} error:^(NSError *error) {
		[subject sendError:error];
	} completed:^{
		[subject sendCompleted];
	}];

	seq->_subject = subject;
	return seq;
}
```
从该类方法可知，属性 subject 是一个重播信号流，其会重播参数 signal 信号流所传递的信号量。从下面的方法也可以看出，该队列中所包含的一系列值是保存在信号流 subject 中的。
```
- (NSArray *)array {
	return self.subject.toArray;
}
```

用样的，重写的 head 和 tail 方法也就是获取 subject 中的第一个信号量以及后面的信号量。
```
- (id)head {
	id value = [self.subject firstOrDefault:self];

	if (value == self) {
		return nil;
	} else {
		return value ?: NSNull.null;
	}
}

- (RACSequence *)tail {
	RACSequence *sequence = [self.class sequenceWithSignal:[self.subject skip:1]];
	sequence.name = self.name;
	return sequence;
}
```
###RACStringSequence 
RACStringSequence 是 RACSequence 的子类，其包含的一系列值其实是一个字符串。
```
+ (RACSequence *)sequenceWithString:(NSString *)string offset:(NSUInteger)offset {
	NSCParameterAssert(offset <= string.length);

	if (offset == string.length) return self.empty;

	RACStringSequence *seq = [[self alloc] init];
	seq->_string = [string copy];
	seq->_offset = offset;
	return seq;
}
```

第一个信号量 head 的具体值由 string 和 offset 共同确定，剩余值组成另一个序列 tail 。
```
- (id)head {
	return [self.string substringWithRange:NSMakeRange(self.offset, 1)];
}

- (RACSequence *)tail {
	RACSequence *sequence = [self.class sequenceWithString:self.string offset:self.offset + 1];
	sequence.name = self.name;
	return sequence;
}
```

###RACTupleSequence 
RACTupleSequence 是 RACSequence 的子类，其类似于 RACArraySequence ，但是其是专为 RACTuple 设计的。

```
+ (RACSequence *)sequenceWithTupleBackingArray:(NSArray *)backingArray offset:(NSUInteger)offset {
	NSCParameterAssert(offset <= backingArray.count);

	if (offset == backingArray.count) return self.empty;

	RACTupleSequence *seq = [[self alloc] init];
	seq->_tupleBackingArray = backingArray;
	seq->_offset = offset;
	return seq;
}
```
创建实例的类方法，同 RACArraySequence 除了属性名称不同外，其他基本一致。

而 head 和 tail 方法也十分相同，只是，head 方法中会将 RACTupleNil 类型的实例转换为 NSNull 对象。换言之，RACArraySequence 队列中不会包含空值，而 RACTupleSequence 中是可以的。
```
- (id)head {
	id object = self.tupleBackingArray[self.offset];
	return (object == RACTupleNil.tupleNil ? NSNull.null : object);
}

- (RACSequence *)tail {
	RACSequence *sequence = [self.class sequenceWithTupleBackingArray:self.tupleBackingArray offset:self.offset + 1];
	sequence.name = self.name;
	return sequence;
}
```
###RACUnarySequence 
RACUnarySequence 是 RACSequence 的子类，只是其只有一个信号量。
```
+ (RACUnarySequence *)return:(id)value {
	RACUnarySequence *sequence = [[self alloc] init];
	sequence.head = value;
	return [sequence setNameWithFormat:@"+return: %@", RACDescription(value)];
}
```
head 保存着这个唯一的信号量，而 tail 则直接返回 nil 。

##RACSequenceAdditions分类
在 ReactiveCocoa 框架中，为了方便获取由集合对象创建的 RACSequence 实例对象，而扩展了名为 RACSequenceAdditions 的分类。

扩展了分类的相关类如下：
* NSArray
* NSDictionary
* NSEnumerator
* NSIndexSet
* NSOrderSet
* NSSet
* NSString

这些类的扩展类大致相同，但也有区别。

它们都有一个属性 rac_sequence ，通过该属性可以获取一个 RACSequence 类型的实例对象，但是在不同分类中，该属性获取方法的实现方式是不同的。

* NSArray (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	return [RACArraySequence sequenceWithArray:self offset:0];
}
```
* NSDictionary (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	NSDictionary *immutableDict = [self copy];

	return [immutableDict.allKeys.rac_sequence map:^(id key) {
		id value = immutableDict[key];
		return RACTuplePack(key, value);
	}];
}

- (RACSequence *)rac_keySequence {
	return self.allKeys.rac_sequence;
}

- (RACSequence *)rac_valueSequence {
	return self.allValues.rac_sequence;
}
```
这个分类中，还有分别获取键、值集合的队列信号流的属性 rac_keySequence 和 rac_valueSequence 。
* NSEnumerator (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	return [RACSequence sequenceWithHeadBlock:^{
		return [self nextObject];
	} tailBlock:^{
		return self.rac_sequence;
	}];
}
```
* NSIndexSet (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	return [RACIndexSetSequence sequenceWithIndexSet:self];
}
```
* NSOrderedSet (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	return self.array.rac_sequence;
}
```
* NSSet (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	return self.allObjects.rac_sequence;
}
```
* NSString (RACSequenceAdditions)

```
- (RACSequence *)rac_sequence {
	return [RACStringSequence sequenceWithString:self offset:0];
}
```

##RACDisposable
正如我们前面所说的，在订阅者订阅信号源的过程中，可能会产生副作用或者消耗一定的资源，所以当我们在取消订阅或者完成订阅时，我们就需要做一些资源回收和垃圾清理的工作。

RACDisposable 在 ReactiveCocoa 中就充当着清洁工的角色，它封装了取消和清理一次订阅所必需的工作。它有一个核心的方法 -dispose ，调用这个方法就会执行相应的清理工作，这有点类似于 NSObject 的 -dealloc 方法。RACDisposable 总共有四个子类，它的继承结构图如下
![](https://upload-images.jianshu.io/upload_images/2121311-5e2ed3b40894ab7c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/916)

该类的方法十分简单，一个用来创建实例，封装要做的操作，一个执行操作。
```
+ (instancetype)disposableWithBlock:(void (^)(void))block;

- (void)dispose;
```
在该类中，有一个实例变量 _disposeBlock ，其是默认指向 self 的指针，在初始化后，其指向待执行的代码块。

```
- (void)dispose {
	void (^disposeBlock)(void) = NULL;

	while (YES) {
		void *blockPtr = _disposeBlock;
		if (OSAtomicCompareAndSwapPtrBarrier(blockPtr, NULL, &_disposeBlock)) {
			if (blockPtr != (__bridge void *)self) {
				disposeBlock = CFBridgingRelease(blockPtr);
			}

			break;
		}
	}

	if (disposeBlock != nil) disposeBlock();
}
```
在 dispose 方法中，会调用 OSAtomicCompareAndSwapPtrBarrier() 函数，该函数会判断 blockPtr 所指向的地址是否与 &_disposeBlock 内存地址中存储的指针地址相同，若相同，则将 NULL 保存到 &_disposeBlock 内存地址中。
即当 blockPtr == *(&_disposeBlock) 为 YES 时，并且 blockPtr 并不是指向 self 时，则其所指向的代码块便会被执行，执行完毕后，代码块即可被释放。

###RACSerialDisposable
RACSerialDisposable 是 RACDisposable 的子类，该类提供的类方法和实例方法都是针对属性 disposable 的，实际上该类所持有的任务都是存储在 disposable 属性中的。

RACSerialDisposable作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来。

```
@property (atomic, strong, nullable) RACDisposable *disposable;

+ (instancetype)serialDisposableWithDisposable:(nullable RACDisposable *)disposable;

//使用新任务替换原任务，如果任务已经执行完毕，那么新任务 newDisposable 立刻执行，
//并且保持属性 disposable 为 nil
- (nullable RACDisposable *)swapInDisposable:(nullable RACDisposable *)newDisposable;
```

并且，该类重写了 initWithBlock: 方法，将任务封装在了属性 disposable 中。
```
- (instancetype)initWithBlock:(void (^)(void))block {
	self = [self init];
	if (self == nil) return nil;

	self.disposable = [RACDisposable disposableWithBlock:block];

	return self;
}
```

###RACKVOTrampoline
RACKVOTrampoline 是 RACDisposable 的子类，该类将监听目标属性变化的任务进行了封装，当 dispose 方法调用时，便结束该监听任务。
```
typedef void (^RACKVOBlock)(id target, id observer, NSDictionary *change);

- (instancetype)initWithTarget:(__weak NSObject *)target observer:(__weak NSObject *)observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(RACKVOBlock)block;
```

###RACCompoundDisposable
RACCompoundDisposable 是 RACDisposable 的子类，其可以包含多个 RACDisposable 实例，用来保存多个待处理的任务。

跟 RACSerialDisposable 一样，* RACCompoundDisposable 也是作为 disposable 的容器使用。不同的是，它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象，有点类似于可变数组 NSMutableArray 。而当一个 RACCompoundDisposable 对象被 disposed 时，它会调用其所包含的所有 disposable 对象的 -dispose 方法，有点类似于 autoreleasepool 的作用。

为了更快的访问待处理的任务，在该类中声明了一个 _inlineDisposables 指针，其指向一个包含有 RACCompoundDisposableInlineCount 个 RACDisposable 实例的数组，该值默认为 2 ，当添加的任务超过该值时，便会创建额外的数组进行保存。
```
#if RACCompoundDisposableInlineCount
RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];
#endif
	
CFMutableArrayRef _disposables;
```

该类提供了两个创建实例的类方法：
```
+ (instancetype)compoundDisposable;

+ (instancetype)compoundDisposableWithDisposables:(nullable NSArray *)disposables;
```

该类提供了两个创建实例的类方法：
```
+ (instancetype)compoundDisposable;

+ (instancetype)compoundDisposableWithDisposables:(nullable NSArray *)disposables;
```

得到实例对象后，可以调用下面的方法添加任务，如果当前组合任务已经被执行了，那么待添加的任务也会立刻执行。
```
- (void)addDisposable:(nullable RACDisposable *)disposable;
```

无论组合的任务处于什么状态，都可以调用下面的方法移除指定的任务，如果任务不存在，那么则直接返回。
```
- (void)removeDisposable:(nullable RACDisposable *)disposable;
```

该类还重写了 dispose 方法，调用时，该类实例会调用自身所包含的所有任务的 dispose 方法。

这些方法的执行都是线程安全的，因为该类声明了一个变量锁，保证其线程安全性。
```
pthread_mutex_t _mutex;

const int result __attribute__((unused)) = pthread_mutex_init(&_mutex, NULL);
```

所有要求线程安全的代码都包含在锁中：
```
pthread_mutex_lock(&_mutex);
{
	//代码
}
pthread_mutex_unlock(&_mutex);
```

###RACScopedDisposable
RACScopedDisposable 是 RACDisposable 的子类，其同父类的区别在于其被释放时，在 dealloc 方法中会调用 dispose 方法。

从该类的实例创建方法可知，该类通常是将 RACDisposable 的实例进行封装。
```
+ (instancetype)scopedDisposableWithDisposable:(RACDisposable *)disposable {
	return [self disposableWithBlock:^{
		[disposable dispose];
	}];
}
```

RACDisposable 实例对象可以直接调用 asScopedDisposable 实例方法获取一个该类的实例对象。

##RACDelegateProxy
RACDelegateProxy 是 ReactiveCocoa 框架内部使用的类，它作为一个中间层，封装了一个代理实例。
```
- (instancetype)initWithProtocol:(Protocol *)protocol;
```
在使用上面的方法创建一个中间代理对象时，需要提供代理遵循的协议，相应的调用下面的方法时，所提供的方法应当属于该协议。
```
- (RACSignal *)signalForSelector:(SEL)selector {
	return [self rac_signalForSelector:selector fromProtocol:_protocol];
}
```
>参见 NSObject 的 RACSelectorSignal 分类。

需要明白的是，该 RACDelegateProxy 类并不会实现协议中的任何方法，真正实现相应方法的代理保存在下面的属性中。
```
@property (nonatomic, unsafe_unretained) id rac_proxiedDelegate;
```
该类重写了 NSObject 中的一些方法，当 signalForSelector: 方法并不能处理相关任务时，可以将任务转发给代理对象。
```
- (void)forwardInvocation:(NSInvocation *)invocation {
	[invocation invokeWithTarget:self.rac_proxiedDelegate];
}
```

##RACKVOProxy
RACKVOProxy 类有点类似 RACDelegateProxy 类，但是该类共享一个实例，作为一个代理保存着真正的监听者。
```
+ (instancetype)sharedProxy;

- (void)addObserver:(__weak NSObject *)observer forContext:(void *)context;

- (void)removeObserver:(NSObject *)observer forContext:(void *)context;
```
该类中，声明了一个 NSMapTable 实例用来保存所有的监听者，所以在使用上面的方法时，参数 context 一定要是唯一的。
```
@property (strong, nonatomic, readonly) NSMapTable *trampolines;
```
当该类作为监听者监听到相应的属性发生变化时，便会响应下面的方法，从而将消息传递给真正的监听者。
```
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
	NSValue *valueContext = [NSValue valueWithPointer:context];
	__block NSObject *trueObserver;

	dispatch_sync(self.queue, ^{
		trueObserver = [self.trampolines objectForKey:valueContext];
	});

	if (trueObserver != nil) {
		[trueObserver observeValueForKeyPath:keyPath ofObject:object change:change context:context];
	}
}
```

##RACSubscriptingAssignmentTrampoline
RACSubscriptingAssignmentTrampoline 类可以为指定对象的指定属性绑定一个信号流，每当信号流传递信号量时，便为该属性赋值。

该类提供了一个初始化方法，含有两个参数，一个是指定的对象，一个是当传递的信号量是 nil 时，属性会设置的值。
```
- (nullable instancetype)initWithTarget:(nullable id)target nilValue:(nullable id)nilValue;
```

但是，不必直接使用这个类，框架中提供了一个宏，十分方便。
```
#define RAC(TARGET, ...) \
    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__)) \
        (RAC_(TARGET, __VA_ARGS__, nil)) \
        (RAC_(TARGET, __VA_ARGS__))


#define RAC_(TARGET, KEYPATH, NILVALUE) \
    [[RACSubscriptingAssignmentTrampoline alloc] initWithTarget:(TARGET) nilValue:(NILVALUE)][@keypath(TARGET, KEYPATH)]
```

使用 RAC(TARGET, …) 宏，该宏可以提供2个或3个参数，使用方法如下例子：
```
RAC(self, objectProperty) = objectSignal;
RAC(self, stringProperty, @"foobar") = stringSignal;
RAC(self, integerProperty, @42) = integerSignal;
```

##RACBlockTrampoline
RACBlockTrampoline 类是 ReactiveCocoa 框架中内部使用的类，用于调用动态的回调代码块。
```
+ (id)invokeBlock:(id)block withArguments:(RACTuple *)arguments {
	NSCParameterAssert(block != NULL);

	RACBlockTrampoline *trampoline = [[self alloc] initWithBlock:block];
	return [trampoline invokeWithArguments:arguments];
}
```
要正常使用该方法，block 不能为空，并且其所包含的参数必须和 arguments 的分量个数保持一致，且参数是必须的，当然最多支持 15 个参数。
```
- (id)invokeWithArguments:(RACTuple *)arguments {
	SEL selector = [self selectorForArgumentCount:arguments.count];
	NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:selector]];
	invocation.selector = selector;
	invocation.target = self;

	for (NSUInteger i = 0; i < arguments.count; i++) {
		id arg = arguments[i];
		NSInteger argIndex = (NSInteger)(i + 2);
		[invocation setArgument:&arg atIndex:argIndex];
	}

	[invocation invoke];
	
	__unsafe_unretained id returnVal;
	[invocation getReturnValue:&returnVal];
	return returnVal;
}
```
这个方法很简单，首先调用下面的方法，根据 arguments 所包含的分量个数确定 block 中的参数个数，从而确定后面需要调用的方法。
```
- (SEL)selectorForArgumentCount:(NSUInteger)count {
	NSCParameterAssert(count > 0);

	switch (count) {
		case 0: return NULL;
		case 1: return @selector(performWith:);
		case 2: return @selector(performWith::);
		···	 //省略
		case 15: return @selector(performWith:::::::::::::::);
	}
	NSCAssert(NO, @"The argument count is too damn high! Only blocks of up to 15 arguments are currently supported.");
	return NULL		
}
```
根据返回的 SEL 变量创建一个 NSInvocation 实例，而后绑定参数，最后调用 invoke 方法。

如果要在框架外使用该类，需要导入 RACBlockTrampoline.h 头文件。
```
#import "RACBlockTrampoline.h"

- (void)test {
    id (^block)(id obj) = ^ id (id obj) {
        NSLog(@"block is executed : %@ .",obj);
        return obj;
    };
    
    id obj = [RACBlockTrampoline invokeBlock:block withArguments:RACTuplePack(@100)];
}
```

##多播连接RACMulticastConnection
一般订阅 RACSignal 信号流时，都要执行一次创建该流时提供的 didSubscribe 代码块参数。但是，有些情况 didSubscribe 只宜执行一次，如同组播一样，后续订阅者只是加入监听信号流的组中。

RACMulticastConnection 是 NSObject 的子类，可以实现上述的情况，其实际是将一个 RACSubject 实例连接到源信号流，订阅者不在对源信号流订阅而是订阅该 RACSubject 实例。
```
@property (nonatomic, strong, readonly) RACSignal<ValueType> *signal;

- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject
```
属性 signal 就是初始化方法所传递的 subject 参数，该属性虽然是 RACSubject 实例，但是在其与源信号流连接之前，所有的的订阅者不会也不应该接收到信号量。

**connect**
```
- (RACDisposable *)connect {
    BOOL shouldConnect = OSAtomicCompareAndSwap32Barrier(0, 1, &_hasConnected);

    if (shouldConnect) {
        self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
    }

    return self.serialDisposable;
}
```
在订阅 signal 信号流之前，应先调用 connect 方法，从上可知，_hasConnected 变量保证了源信号流只会被 _signal 订阅一次，即 didSubscribe 也仅仅执行一次，而 _signal 作为 _sourceSignal 的订阅者会将每一个信号量转发给所有订阅其自身的订阅者，从而实现组播的模式。

**autoconnect**
```
- (RACSignal *)autoconnect {
    __block volatile int32_t subscriberCount = 0;

    return [[RACSignal
        createSignal:^(id<RACSubscriber> subscriber) {
            OSAtomicIncrement32Barrier(&subscriberCount);

            RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];
            RACDisposable *connectionDisposable = [self connect];

            return [RACDisposable disposableWithBlock:^{
                [subscriptionDisposable dispose];

                if (OSAtomicDecrement32Barrier(&subscriberCount) == 0) {
                    [connectionDisposable dispose];
                }
            }];
        }]
        setNameWithFormat:@"[%@] -autoconnect", self.signal.name];
}
```
autoconnect 方法返回了一个新的 RACSignal 实例，该实例被订阅时，会自动成为 _signal 的订阅者，同时 connect 方法会被调用，完成源信号流 _sourceSignal 和 _signal 信号流的连接。

当然，不应自己初始化该类实例，而是应该使用 RACSignal 的 publish 或 multicast: 方法。

##RACChannel相关
###RACChannel
RACChannel 持有两个信号流，这两个信号流的订阅者所接收到的信号量并不是来自自己所订阅的信号流，而是另一个信号流。类似于相连的两个终端，每个终端所产生的数据都是要传递到另一个终端的。
```
@property (nonatomic, strong, readonly) RACChannelTerminal<ValueType> *leadingTerminal;

@property (nonatomic, strong, readonly) RACChannelTerminal<ValueType> *followingTerminal;
```
###RACChannelTerminal
RACChannelTerminal 是 RACSignal 的子类，并且遵循 <RACSubscriber> 协议，其持有两个属性，分别表示源信号流和另一个终端的源信号流。
```
@property (nonatomic, strong, readonly) RACSignal<ValueType> *values;

@property (nonatomic, strong, readonly) id<RACSubscriber> otherTerminal;

- (instancetype)init {
	self = [super init];

	// We don't want any starting value from the leadingSubject, but we do want
	// error and completion to be replayed.
	RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:0] setNameWithFormat:@"leadingSubject"];
	RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:1] setNameWithFormat:@"followingSubject"];

	// Propagate errors and completion to everything.
	[[leadingSubject ignoreValues] subscribe:followingSubject];
	[[followingSubject ignoreValues] subscribe:leadingSubject];

	_leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:@"leadingTerminal"];
	_followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:@"followingTerminal"];

	return self;
}
```
从 RACChannel 的初始化方法，可知，这两个属性都是 RACReplaySubject 类型。
```
#pragma mark RACSignal

- (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
	return [self.values subscribe:subscriber];
}

#pragma mark <RACSubscriber>

- (void)sendNext:(id)value {
	[self.otherTerminal sendNext:value];
}
```
当订阅某一个终端流时，都会将该终端持有的源信号流进行重播，而其重播的信号量并不是由其自身决定的，因为，从 sendNext: 方法可以知道，发送的信号量实际是被另一终端的订阅者接收了，换言之，订阅者接收到的重播信号量，都是另一终端发送的信号量。

###RACKVOChannel
RACKVOChannel 是 RACChannel 的子类，其提供了将指定对象的指定属性与信号流相互绑定的方法。
```
- (instancetype)initWithTarget:(__weak NSObject *)target keyPath:(NSString *)keyPath nilValue:(nullable ValueType)nilValue;
```
该方法中代码片段，如下：
```
RACDisposable *observationDisposable = [strongTarget rac_observeKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:nil block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) {
	if (!causedByDealloc && affectedOnlyLastComponent && self.currentThreadData.ignoreNextUpdate) {
		[self destroyCurrentThreadData];
		return;
	}

	[self.leadingTerminal sendNext:value];
}];
```
可见，当该指定属性发生变动时，便由 self.leadingTerminal 信号流传递一个信号量，当然，这个信号量会被 self.followingTerminal 信号流接收到。
```
[[self.leadingTerminal
	finally:^{
		[observationDisposable dispose];
	}]
	subscribeNext:^(id x) {

		NSObject *object = (keyPathComponentsCount > 1 ? [self.target valueForKeyPath:keyPathByDeletingLastKeyPathComponent] : self.target);
		if (object == nil) return;

		[self createCurrentThreadData];
		self.currentThreadData.ignoreNextUpdate = YES;

		[object setValue:x ?: nilValue forKey:lastKeyPathComponent];
	} error:^(NSError *error) {
		NSCAssert(NO, @"Received error in %@: %@", self, error);
		NSLog(@"Received error in %@: %@", self, error);
}];
```
当 self.leadingTerminal 信号流接收到信号量时，便会去修改相应的属性值，而 self.leadingTerminal 信号流接收到的信号量则是由 self.followingTerminal 信号流传递的。

但是，通常不必使用该子类，而是直接使用框架中提供的宏。
```
#define RACChannelTo(TARGET, ...) \
    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__)) \
        (RACChannelTo_(TARGET, __VA_ARGS__, nil)) \
        (RACChannelTo_(TARGET, __VA_ARGS__))

#define RACChannelTo_(TARGET, KEYPATH, NILVALUE) \
    [[RACKVOChannel alloc] initWithTarget:(TARGET) keyPath:@keypath(TARGET, KEYPATH) nilValue:(NILVALUE)][@keypath(RACKVOChannel.new, followingTerminal)]
```
RACChannelTo() 在等号左侧或右侧代表不同的含义，使用方法如下：
```
RACChannelTerminal *integerChannel = RACChannelTo(self, integerProperty, @42);
[integerChannel sendNext:@5];

[integerChannel subscribeNext:^(id value) {
	NSLog(@"value: %@", value);
}];
```
RACChannelTo() 在等号右侧，那么，返回一个信号流，实际就是 RACKVOChannel 实例对象的 followingTerminal 属性。订阅该信号流便可以监听属性值的变化，而使用该信号流传递信号量，便会改变属性的值。

```
RACChannelTo(view, objectProperty) = RACChannelTo(model, objectProperty);
RACChannelTo(view, integerProperty, @2) = RACChannelTo(model, integerProperty, @10);
```
RACChannelTo() 在等号左侧，那么右侧需要有相应的 RACChannelTerminal 实例对象与之对应，表示两者的相互绑定。
上面两行代码，就是控件属性同模型变量相互绑定的实例。

##调度器RACScheduler
有了信号源和订阅者，我们还需要由调度器来统一调度订阅者订阅信号源的过程中所涉及到的任务，这样才能保证所有的任务都能够合理有序地执行。

RACScheduler 在 ReactiveCocoa 中就是扮演着调度器的角色，本质上，它就是用 GCD 的串行队列来实现的，并且支持取消操作。是的，在 ReactiveCocoa 中，并没有使用到 NSOperationQueue 和 NSRunloop 等技术，RACScheduler 也只是对 GCD 的简单封装而已。

该类用来控制任务的执行，但其是一个抽象类，真正执行操作的是其子类。
执行任务的权限，其实与队列权限相对应。
```
typedef enum : long {
	RACSchedulerPriorityHigh = DISPATCH_QUEUE_PRIORITY_HIGH,
	RACSchedulerPriorityDefault = DISPATCH_QUEUE_PRIORITY_DEFAULT,
	RACSchedulerPriorityLow = DISPATCH_QUEUE_PRIORITY_LOW,
	RACSchedulerPriorityBackground = DISPATCH_QUEUE_PRIORITY_BACKGROUND,
} RACSchedulerPriority;
```

这里还定义了一个类型 RACSchedulerRecursiveBlock ，是一个含有一个参数，并且没有返回值的代码块，其包含的参数同样是一个代码块，并且该代码块没有参数和返回值。
```
typedef void (^RACSchedulerRecursiveBlock)(void (^reschedule)(void));
```

该类提供了几个类方法以获取实例对象，而其中几个实际返回的是子类的实例对象，并且该对象是全局共享的。
```
//返回一个 RACImmediateScheduler 全局实例对象，
//其会立刻执行提供的代码块任务
+ (RACScheduler *)immediateScheduler;

//返回一个 RACTargetQueueScheduler 全局实例对象，
//并且任务的执行队列被指定为主队列
+ (RACScheduler *)mainThreadScheduler;

//返回一个 RACSubscriptionScheduler 全局实例对象，
//其有一个 RACScheduler 类型的属性 backgroundScheduler ，
//如果 currentScheduler 为 nil 时，使用该属性对象执行任务
+ (instancetype)subscriptionScheduler;
```

下面三个方法可归结为第一个方法，最终都返回一个 RACTargetQueueScheduler 实例对象，所有的任务都会加入到全局队列中。
```
+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority name:(nullable NSString *)name;

+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority;

+ (RACScheduler *)scheduler;
```

下面的方法用来获取当前保存的 RACScheduler 实例对象，可知，当保存值为空时，其会判断是否返回指定主队列的实例对象。
```
+ (RACScheduler *)currentScheduler {
	RACScheduler *scheduler = NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey];
	if (scheduler != nil) return scheduler;
	if ([self.class isOnMainThread]) return RACScheduler.mainThreadScheduler;

	return nil;
}
```

该类还定义了几个抽象函数，其具体操作由子类实现。
```
//提供的代码块任务会添加到相应的队列中
- (nullable RACDisposable *)schedule:(void (^)(void))block;

//在指定的时间或之后执行提供的任务，该任务不会影响其他任务
- (nullable RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block;

//延迟指定时间执行所提供的任务，该方法实际会调用上面的方法
- (nullable RACDisposable *)afterDelay:(NSTimeInterval)delay schedule:(void (^)(void))block;

//在指定时间或之后执行提供的任务，并定时重复执行
- (nullable RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block;
```

下面这个方法可以将递归任务自动转换为循环任务，所以其可以反复的调用自己。
```
- (nullable RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock;
```

下面这个方法会执行提供的任务，并且会将当前实例对象暂存为当前线程的 scheduler ，而任务执行结束后，scheduler 会修改回原值或移除。
```
- (void)performAsCurrentScheduler:(void (^)(void))block {
	NSCParameterAssert(block != NULL);

	RACScheduler *previousScheduler = RACScheduler.currentScheduler;
	NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] = self;

	@autoreleasepool {
		block();
	}

	if (previousScheduler != nil) {
		NSThread.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] = previousScheduler;
	} else {
		[NSThread.currentThread.threadDictionary removeObjectForKey:RACSchedulerCurrentSchedulerKey];
	}
}
```

###RACImmediateScheduler
RACImmediateScheduler 是 RACScheduler 的子类，其重写了父类的方法，对于提供的任务会立刻执行。
```
- (RACDisposable *)schedule:(void (^)(void))block {
	NSCParameterAssert(block != NULL);

	block();
	return nil;
}
```
###RACQueueScheduler
RACQueueScheduler 是 RACScheduler 的子类，其重写了父类的方法，会将提供的任务加入指定的队列异步执行。
```
- (RACDisposable *)schedule:(void (^)(void))block {
	NSCParameterAssert(block != NULL);

	RACDisposable *disposable = [[RACDisposable alloc] init];

	dispatch_async(self.queue, ^{
		if (disposable.disposed) return;
		[self performAsCurrentScheduler:block];
	});

	return disposable;
}
```
###RACTargetQueueScheduler
RACTargetQueueScheduler 是 RACQueueScheduler 的子类，该类重写了父类的方法。
```
- (instancetype)initWithName:(NSString *)name targetQueue:(dispatch_queue_t)targetQueue {
	NSCParameterAssert(targetQueue != NULL);

	if (name == nil) {
		name = [NSString stringWithFormat:@"org.reactivecocoa.ReactiveObjC.RACTargetQueueScheduler(%s)", dispatch_queue_get_label(targetQueue)];
	}

	dispatch_queue_t queue = dispatch_queue_create(name.UTF8String, DISPATCH_QUEUE_SERIAL);
	if (queue == NULL) return nil;

	dispatch_set_target_queue(queue, targetQueue);

	return [super initWithName:name queue:queue];
}
```
在该初始化方法中，其主要是创建了一个串行队列，并且为该串行队列设置了目标队列。
###RACSubscriptionScheduler
RACSubscriptionScheduler 是 RACScheduler 的子类，其重写了父类的方法，会将提供的任务加入指定的队列异步执行，当然，也可能是直接执行任务。
```
- (RACDisposable *)schedule:(void (^)(void))block {
	NSCParameterAssert(block != NULL);

	if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];

	block();
	return nil;
}
```
该类有一个属性 backgroundScheduler ，当全局变量 currentScheduler 为空时，该属性便会被使用。
```
_backgroundScheduler = [RACScheduler scheduler];
```
backgroundScheduler 实质上是一个 RACTargetQueueScheduler 实例对象。

##RACSupport分类
为了更好的支持 ReactiveCocoa 框架，故扩展了名为 RACSupport 的分类，以便于向 CocoaTouch 框架中的类添加了支持 ReactiveCocoa 框架的相关方法。

###NSData (RACSupport)
该分类中提供了一个方法用来读取 URL 位置的数据，并且将数据或错误信息传递给信号流。这个信号流就是该方法返回的信号流，且是 RACReplaySubject 类型的实例对象，订阅该信号流后，便可以接收到数据信号量或错误信号量。
```
+ (RACSignal<NSData *> *)rac_readContentsOfURL:(nullable NSURL *)URL options:(NSDataReadingOptions)options scheduler:(RACScheduler *)scheduler;
```
###NSFileHandle (RACSupport)
该分类中提供了一个方法用来在后台读取有效的数据，并将读取的数据发送给返回的信号流，当读取的数据长度为 0 或小于 0 时，结束信号流。
```
- (RACSignal<NSData *> *)rac_readInBackground;
```
###NSNotificationCenter (RACSupport)
该分类提供了一个方法用来封装通知的注册，这样接收到的通知便会转发给返回的信号流的订阅者。
```
- (RACSignal<NSNotification *> *)rac_addObserverForName:(nullable NSString *)notificationName object:(nullable id)object;
```
###NSString (RACSupport)
这个方法类似于 NSData (RACSupport) 中的方法，读取 URL 所在位置的文件，最后将字符串发送给返回的信号流。
```
+ (RACSignal<NSString *> *)rac_readContentsOfURL:(NSURL *)URL usedEncoding:(NSStringEncoding *)encoding scheduler:(RACScheduler *)scheduler;
```

###NSURLConnection (RACSupport)
该方法将异步请求进行了封装，每当订阅返回的信号流时，便会发起请求，然后向信号流中发送返回的数据或错误信息。
```
+ (RACSignal<RACTwoTuple<NSURLResponse *, NSData *> *> *)rac_sendAsynchronousRequest:(NSURLRequest *)request;
```
###NSUserDefaults (RACSupport)
该方法返回一个 RACChannelTerminal 实例对象，订阅该对象，那么当 NSUserDefaults 中指定的 key 所对应的值发生变动时，便可以接收到变化后的值。并且，通过调用 sendNext: 方法，还可以修改 NSUserDefaults 中 key 所对应的值。
```
- (RACChannelTerminal *)rac_channelTerminalForKey:(NSString *)key;
```
实际上，该方法利用了 RACChannel 类中的 leadingTerminal 和 followingTerminal 属性，该类的使用方法参见 RACChannel 。

##NSString分类
###RACKeyPathUtilities
ReactiveCocoa 中声明了一个 NSString 的分类，名为 RACKeyPathUtilities 。其主要是为了方便对键值路径的操作。

```
- (NSArray *)rac_keyPathComponents;
```
拆分路径，返回属性名称的集合

```
- (NSString *)rac_keyPathByDeletingLastKeyPathComponent;
```
移除路径的最后一个部分

```
- (NSString *)rac_keyPathByDeletingFirstKeyPathComponent;
```
移除路径的第一个部分

这些操作都是根据路径中的 ‘ . ’ 符合进行操作的。

##NSInvocation分类
###RACTypeParsing
在 ReactiveCocoa 框架中，为 NSInvocation 类扩展了一个 RACTypeParsing 分类。该分类提供了快速设置、获取方法参数的方法，并且提供了一个类型为 RACTuple 的属性。
**设置参数**
```
- (void)rac_setArgument:(id)object atIndex:(NSUInteger)index;
```
该方法会设置指定索引的参数，其主要是先从方法签名中获取参数的类型，而后根据其类型的不同定义不同的变量，最后将变量的地址传递给参数索引。主要是使用 PULL_AND_SET 宏，定义如下：
```
#define PULL_AND_SET(type, selector) \
	do { \
		type val = [object selector]; \
		[self setArgument:&val atIndex:(NSInteger)index]; \
	} while (0)
```
**获取参数**
```
- (id)rac_argumentAtIndex:(NSUInteger)index;
```
该方法可以获取指定索引处的参数，并且最终返回的是 Objective C 对象。在确定指定参数的类型后，使用宏 WRAP_AND_RETURN 进行包装。
```
#define WRAP_AND_RETURN(type) \
	do { \
		type val = 0; \
		[self getArgument:&val atIndex:(NSInteger)index]; \
		return @(val); \
	} while (0)
```
**获取返回值**
```
- (id)rac_returnValue;
```
获取的返回值也是经过 WRAP_AND_RETURN 宏处理的，最后返回的也是一个 OC 对象。
```
#define WRAP_AND_RETURN(type) \
	do { \
		type val = 0; \
		[self getReturnValue:&val]; \
		return @(val); \
	} while (0)
```
**参数集合**
```
@property (nonatomic, copy) RACTuple *rac_argumentsTuple;
```
通过获取或设置该属性，来读取参数或设置参数。

```
- (RACTuple *)rac_argumentsTuple {
	NSUInteger numberOfArguments = self.methodSignature.numberOfArguments;
	NSMutableArray *argumentsArray = [NSMutableArray arrayWithCapacity:numberOfArguments - 2];
	for (NSUInteger index = 2; index < numberOfArguments; index++) {
		[argumentsArray addObject:[self rac_argumentAtIndex:index] ?: RACTupleNil.tupleNil];
	}

	return [RACTuple tupleWithObjectsFromArray:argumentsArray];
}
```
读取方法中的所有参数，然后将所有参数封装到一个 RACTuple 实例变量中。若参数为 nil ，则使用 RACTupleNil 表示。

```
- (void)setRac_argumentsTuple:(RACTuple *)arguments {
	NSCAssert(arguments.count == self.methodSignature.numberOfArguments - 2, @"Number of supplied arguments (%lu), does not match the number expected by the signature (%lu)", (unsigned long)arguments.count, (unsigned long)self.methodSignature.numberOfArguments - 2);

	NSUInteger index = 2;
	for (id arg in arguments) {
		[self rac_setArgument:(arg == RACTupleNil.tupleNil ? nil : arg) atIndex:index];
		index++;
	}
}
```
将 RACTuple 中的变量赋值给方法中的参数，对于 RACTupleNil 则赋值 nil 。

##NSObject分类
为了提供更多特性，ReactiveCocoa 框架为 NSObject 类扩展了多个分类。所以，所有 NSObject 的子类都可以调用这些分类中的方法。
###RACDeallocating
RACDeallocating 分类中提供了一个 rac_willDeallocSignal 方法，该方法可以返回一个信号流，当该类的实例被释放时，这个信号流会立即传递一个结束信号量。所以，可以订阅这个信号流，从而在实例对象销毁时，执行一些操作。
```
@property (atomic, readonly, strong) RACCompoundDisposable *rac_deallocDisposable;

- (RACSignal *)rac_willDeallocSignal;
```
该特性实现的主要方法如下：
```
static void swizzleDeallocIfNeeded(Class classToSwizzle) {
	@synchronized (swizzledClasses()) {
		NSString *className = NSStringFromClass(classToSwizzle);
		if ([swizzledClasses() containsObject:className]) return;

		SEL deallocSelector = sel_registerName("dealloc");

		__block void (*originalDealloc)(__unsafe_unretained id, SEL) = NULL;

		id newDealloc = ^(__unsafe_unretained id self) {
			RACCompoundDisposable *compoundDisposable = objc_getAssociatedObject(self, RACObjectCompoundDisposable);
			[compoundDisposable dispose];

			if (originalDealloc == NULL) {
				struct objc_super superInfo = {
					.receiver = self,
					.super_class = class_getSuperclass(classToSwizzle)
				};

				void (*msgSend)(struct objc_super *, SEL) = (__typeof__(msgSend))objc_msgSendSuper;
				msgSend(&superInfo, deallocSelector);
			} else {
				originalDealloc(self, deallocSelector);
			}
		};
		
		IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);
		
		if (!class_addMethod(classToSwizzle, deallocSelector, newDeallocIMP, "v@:")) {

			Method deallocMethod = class_getInstanceMethod(classToSwizzle, deallocSelector);

			originalDealloc = (__typeof__(originalDealloc))method_getImplementation(deallocMethod);
			
			originalDealloc = (__typeof__(originalDealloc))method_setImplementation(deallocMethod, newDeallocIMP);
		}

		[swizzledClasses() addObject:className];
	}
}
```
原理是利用 OC 语言的运行时特性，为指定的类定义 dealloc 方法。当然，若 dealloc 方法已经实现了，则要将原方法保存替换，而后执行。

1. swizzledClasses() 返回一个集合，如果该集合已经包含了指定的 classToSwizzle 类，那么说明 dealloc 方法已经经过相应的调整，直接返回。
2. 接着定义一个 originalDealloc 变量用来保存可能存在的 dealloc 实现方法。
3. 定义一个 newDealloc 代码块，即是后面要设置的 dealloc 实现方法，该方法会先调用 compoundDisposable 的 dispose 方法，实际会传递一个结束信号量。然后，如果存在原 dealloc 方法，就执行，否则执行父类的 dealloc 方法。
4. 使用 imp_implementationWithBlock 函数和参数 newDealloc 代码块创建一个实现方法的变量 newDeallocIMP 。
5. 使用 class_addMethod 函数为指定的 classToSwizzle 类添加 dealloc 实现方法，如果添加失败，那么说明已经存在该实现方法，则先对其进行保存，而后用 method_setImplementation 函数重写设置。

另外，也可以将相关的操作放在rac_deallocDisposable 属性中。

###RACDescription
在 RACDescription 分类中，主要是声明了一个 RACDescription 函数，该函数会根据参数的类型来返回相应的描述。
```
NSString *RACDescription(id object) {
	if (getenv("RAC_DEBUG_SIGNAL_NAMES") != NULL) {
		if ([object respondsToSelector:@selector(rac_description)]) {
			return [object rac_description];
		} else {
			return [[NSString alloc] initWithFormat:@"<%@: %p>", [object class], object];
		}
	} else {
		return @"(description skipped)";
	}
}
```
不过，该方法只适用于调试模式。

###RACKVOWrapper
RACKVOWrapper 中提供了一个方法，该方法对 KVO 模式进行了封装。并且，当监听的属性声明的是 weak 特征时，同样也会调用 block 代码块。并且，监听者和被监听者任意一个被销毁时，监听也会自动移除，而不用手动移除监听。
```
- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath 
 									options:(NSKeyValueObservingOptions)options 
 									observer:(__weak NSObject *)weakObserver 
 									block:(void (^)(id, NSDictionary *, BOOL, BOOL))block 
{
	//block 和 keyPath 不能为空
	NSCParameterAssert(block != nil);
	NSCParameterAssert(keyPath.rac_keyPathComponents.count > 0);

	keyPath = [keyPath copy];

	NSObject *strongObserver = weakObserver;

	NSArray *keyPathComponents = keyPath.rac_keyPathComponents;
	
	//keyPath 是否只包含一个部分
	BOOL keyPathHasOneComponent = (keyPathComponents.count == 1);
	
	//keyPath 的第一个部分
	NSString *keyPathHead = keyPathComponents[0];
	
	//keyPath 的剩余部分
	NSString *keyPathTail = keyPath.rac_keyPathByDeletingFirstKeyPathComponent;

	//清理对象
	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];

	//第一个路径值的清理对象
	RACSerialDisposable *firstComponentSerialDisposable = [RACSerialDisposable serialDisposableWithDisposable:[RACCompoundDisposable compoundDisposable]];
	
	//获取清理对象
	RACCompoundDisposable * (^firstComponentDisposable)(void) = ^{
		return (RACCompoundDisposable *)firstComponentSerialDisposable.disposable;
	};

	[disposable addDisposable:firstComponentSerialDisposable];

	//是否因该添加销毁监听，默认不添加
	BOOL shouldAddDeallocObserver = NO;

	//获取当前类的指定属性 property
	objc_property_t property = class_getProperty(object_getClass(self), keyPathHead.UTF8String);
	
	if (property != NULL) {
	
		//获取属性 property 的特性
		rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);
		if (attributes != NULL) {
			@onExit {
				free(attributes);
			};

			BOOL isObject = attributes->objectClass != nil || strstr(attributes->type, @encode(id)) == attributes->type;
			BOOL isProtocol = attributes->objectClass == NSClassFromString(@"Protocol");
			BOOL isBlock = strcmp(attributes->type, @encode(void(^)())) == 0;
			BOOL isWeak = attributes->weak;

			//属性是类，并且为弱引用，不是代码块，不是协议，才可以添加销毁监听
			shouldAddDeallocObserver = isObject && isWeak && !isBlock && !isProtocol;
		}
	}

	//为指定值添加销毁监听的代码块
	void (^addDeallocObserverToPropertyValue)(NSObject *) = ^(NSObject *value) {
	
		//先进行判断，是否可以添加销毁监听
		if (!shouldAddDeallocObserver) return;

		//如果监听者是监听路径上的一个值，那么直接返回，因为监听者本身被销毁并不在监听范围内
		if (value == weakObserver) return;

		NSDictionary *change = @{
			NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),
			NSKeyValueChangeNewKey: NSNull.null,
		};

		//获取指定值的清理对象
		RACCompoundDisposable *valueDisposable = value.rac_deallocDisposable;
		
		//将 block 回调封装为一个清理任务
		RACDisposable *deallocDisposable = [RACDisposable disposableWithBlock:^{
			block(nil, change, YES, keyPathHasOneComponent);
		}];

		//将清理任务添加到指定值的清理对象中
		[valueDisposable addDisposable:deallocDisposable];
		
		//向第一个路径值的清理对象中添加一个任务，该任务是移除 deallocDisposable 清理任务
		[firstComponentDisposable() addDisposable:[RACDisposable disposableWithBlock:^{
			[valueDisposable removeDisposable:deallocDisposable];
		}]];
	};

	//为第一个路径值后面的路径添加 block 回调任务
	void (^addObserverToValue)(NSObject *) = ^(NSObject *value) {
		RACDisposable *observerDisposable = [value rac_observeKeyPath:keyPathTail 
												                     options:(options & ~NSKeyValueObservingOptionInitial)
												                    observer:weakObserver 
												                       block:block];
		[firstComponentDisposable() addDisposable:observerDisposable];
	};

	//监听第一个路径值的变化，但是不包括值的初始化情况
	NSKeyValueObservingOptions trampolineOptions = (options | NSKeyValueObservingOptionPrior) & ~NSKeyValueObservingOptionInitial;
	RACKVOTrampoline *trampoline = [[RACKVOTrampoline alloc] initWithTarget:self 
												                           observer:strongObserver 
												                           keyPath:keyPathHead 
												                           options:trampolineOptions 
												                           block:^(id trampolineTarget, id trampolineObserver, NSDictionary *change) {
		
		//当接收到前一个通知时，清理第一个路径值的相关任务
		if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) {
			[firstComponentDisposable() dispose];
			
			//如果设置的监听有 NSKeyValueObservingOptionPrior ，则执行 block
			if ((options & NSKeyValueObservingOptionPrior) != 0) {
				block([trampolineTarget valueForKeyPath:keyPath], change, NO, keyPathHasOneComponent);
			}

			return;
		}

		//获取变化的值
		NSObject *value = [trampolineTarget valueForKey:keyPathHead];

		//如果值变为 nil ，那么直接调用 block 即可
		if (value == nil) {
			block(nil, change, NO, keyPathHasOneComponent);
			return;
		}

		//将原任务清理，添加新的任务
		RACDisposable *oldFirstComponentDisposable = [firstComponentSerialDisposable swapInDisposable:[RACCompoundDisposable compoundDisposable]];
		[oldFirstComponentDisposable dispose];

		//为指定值添加销毁监听
		addDeallocObserverToPropertyValue(value);

		//如果没有其他路径值，直接调用 block 代码
		if (keyPathHasOneComponent) {
			block(value, change, NO, keyPathHasOneComponent);
			return;
		}

		//为剩余的路径值添加监听
		addObserverToValue(value);
		
		//调用 block 代码
		block([value valueForKeyPath:keyPathTail], change, NO, keyPathHasOneComponent);
	}];

	//添加停止监听的清理任务
	[disposable addDisposable:trampoline];

	//获取路径的第一个值
	NSObject *value = [self valueForKey:keyPathHead];
	if (value != nil) {
	
		//添加销毁监听
		addDeallocObserverToPropertyValue(value);

		if (!keyPathHasOneComponent) {
		
			//添加剩余路径的监听
			addObserverToValue(value);
		}
	}

	//监听选项包含初始化选项时，调用 block 代码并传递初始化值
	if ((options & NSKeyValueObservingOptionInitial) != 0) {
		id initialValue = [self valueForKeyPath:keyPath];
		NSDictionary *initialChange = @{
			NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),
			NSKeyValueChangeNewKey: initialValue ?: NSNull.null,
		};
		block(initialValue, initialChange, NO, keyPathHasOneComponent);
	}

	//将监听清理任务加入监听者和当前对象的销毁清理任务中
	RACCompoundDisposable *observerDisposable = strongObserver.rac_deallocDisposable;
	RACCompoundDisposable *selfDisposable = self.rac_deallocDisposable;
	[observerDisposable addDisposable:disposable];
	[selfDisposable addDisposable:disposable];

	//返回一个清理对象，其包含停止监听的任务
	return [RACDisposable disposableWithBlock:^{
		[disposable dispose];
		[observerDisposable removeDisposable:disposable];
		[selfDisposable removeDisposable:disposable];
	}];
}
```
从上面的代码分析，可以看出，对于传递的 keyPath 中的每个路径值，都会进行监听（监听者 observer 除外），不过其向 block 中传递的参数都是全路径所对应的值。

###RACLifting
RACLifting 分类中定义了三个方法用来实现当前类中方法的调用，只是方法的参数是通过信号流传递的。
```
- (RACSignal *)rac_liftSelector:(SEL)selector withSignals:(RACSignal *)firstSignal, ... NS_REQUIRES_NIL_TERMINATION;

- (RACSignal *)rac_liftSelector:(SEL)selector withSignalsFromArray:(NSArray<RACSignal *> *)signals;
```
这两个方法调用当前类的 selector 方法，而参数同 signal 相对应。当每个信号流都传递了信号量时，方法会被调用，而之后，每当任意一个信号流传递了信号量后，都会去执行一次 selecor 方法。只是，这两个方法，最终都是调用了下面的这个方法。
```
- (RACSignal *)rac_liftSelector:(SEL)selector withSignalOfArguments:(RACSignal *)arguments {
	NSCParameterAssert(selector != NULL);
	NSCParameterAssert(arguments != nil);
	
	@unsafeify(self);
	
	NSMethodSignature *methodSignature = [self methodSignatureForSelector:selector];
	NSCAssert(methodSignature != nil, @"%@ does not respond to %@", self, NSStringFromSelector(selector));
	
	return [[[[arguments
		takeUntil:self.rac_willDeallocSignal]
		map:^(RACTuple *arguments) {
			@strongify(self);
			
			NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];
			invocation.selector = selector;
			invocation.rac_argumentsTuple = arguments;
			[invocation invokeWithTarget:self];
			
			return invocation.rac_returnValue;
		}]
		replayLast]
		setNameWithFormat:@"%@ -rac_liftSelector: %s withSignalsOfArguments: %@", RACDescription(self), sel_getName(selector), arguments];
}
```
这三个方法的返回值是一个信号流，该信号流传递的是方法被调用的返回值，如果没有返回值，那么传递 RACUnit.defaultUnit 信号量。

###RACPropertySubscribing
RACPropertySubscribing 分类实际是对 RACKVOWrapper 分类的进一步封装，其中的方法，实际都是调用了 RACKVOWrapper 中的方法。
```
- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer;

- (RACSignal<RACTwoTuple<id, NSDictionary *> *> *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)observer;
```
上面两个方法都是对当前对象指定路径下属性的变化监听，返回的信号流传递了变化的值或变化的信息。

###RACSelectorSignal
RACSelectorSignal 分类提供了两个方法，用来监听指定方法的调用，返回的信号流传递的信号量是调用方法时使用的参数。

不同于 RACLifting 分类，其是参数传递引发方法的调用，而 RACSelectorSignal 分类的方法是方法的调用，导致参数在信号流中的传递。
```
- (RACSignal<RACTuple *> *)rac_signalForSelector:(SEL)selector;

- (RACSignal<RACTuple *> *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol;
```
####内部方法
上面两个方法都调用了内部创建的函数：
```
static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol)
```
在理解这个函数之前，先说明其它相关的函数。

```
static SEL RACAliasForSelector(SEL originalSelector);
```
RACAliasForSelector 函数为指定的选择器添加一个前缀 rac_alias_ 后返回这个新的选择器。

```
static NSMutableSet *swizzledClasses();
```
swizzledClasses 函数返回一个集合，该集合保存所有已经进行交换了的类。

```
static BOOL RACForwardInvocation(id self, NSInvocation *invocation) {
	SEL aliasSelector = RACAliasForSelector(invocation.selector);
	RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);

	Class class = object_getClass(invocation.target);
	BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];
	if (respondsToAlias) {
		invocation.selector = aliasSelector;
		[invocation invoke];
	}

	if (subject == nil) return respondsToAlias;

	[subject sendNext:invocation.rac_argumentsTuple];
	return YES;
}
```
1. 根据参数 invocation 获取别名选择器 aliasSelector
2. 根据选择器 aliasSelector 获取信号流 subject
3. 根据参数 invocation 获取消息接收类 class
4. 确认 class 类中是否能够处理 aliasSelector 消息，如果能，就处理。
5. 如果 subject 为空，直接返回 respondsToAlias
6. 如果 subject 存在，则发送相关参数，最后返回 YES

```
static void RACSwizzleForwardInvocation(Class class) {
	SEL forwardInvocationSEL = @selector(forwardInvocation:);
	Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);

	void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;
	if (forwardInvocationMethod != NULL) {
		originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);
	}

	id newForwardInvocation = ^(id self, NSInvocation *invocation) {
		BOOL matched = RACForwardInvocation(self, invocation);
		if (matched) return;

		if (originalForwardInvocation == NULL) {
			[self doesNotRecognizeSelector:invocation.selector];
		} else {
			originalForwardInvocation(self, forwardInvocationSEL, invocation);
		}
	};

	class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), "v@:@");
}
```
为指定的 class 类创建新的 forwardInvocation: 实现方法，该方法当实际要调用的方法不存在时调用。
1. 如果当前类已经实现了 forwardInvocation: 方法，那么就将该实现保存下来。
2. 在新的实现方法中，首先会去尝试调用原来要调用的方法的别名方法，如果成功，则在信号流中传递方法中使用的参数，否则，就调用原 forwardInvocation: 实现方法，如果没实现，就发送一个未识别方法错误。

```
static void RACSwizzleRespondsToSelector(Class class) {
	SEL respondsToSelectorSEL = @selector(respondsToSelector:);

	Method respondsToSelectorMethod = class_getInstanceMethod(class, respondsToSelectorSEL);
	BOOL (*originalRespondsToSelector)(id, SEL, SEL) = (__typeof__(originalRespondsToSelector))method_getImplementation(respondsToSelectorMethod);

	id newRespondsToSelector = ^ BOOL (id self, SEL selector) {
		Method method = rac_getImmediateInstanceMethod(class, selector);

		if (method != NULL && method_getImplementation(method) == _objc_msgForward) {
			SEL aliasSelector = RACAliasForSelector(selector);
			if (objc_getAssociatedObject(self, aliasSelector) != nil) return YES;
		}

		return originalRespondsToSelector(self, respondsToSelectorSEL, selector);
	};

	class_replaceMethod(class, respondsToSelectorSEL, imp_implementationWithBlock(newRespondsToSelector), method_getTypeEncoding(respondsToSelectorMethod));
}
```
该方法会为指定的 class 类重新指定 respondsToSelector: 的实现方法，用来确定该类是否能够响应指定的消息。
1. 先将原 respondsToSelector: 的实现方法保存下来
2. 定义新的实现方法，先遍历指定类的所有方法查找指定的方法，如果能找到该方法，并且其实现方法为 _objc_msgForward，那么则判断与指定方法相关的别名方法是否关联了信号流，如果有，就返回 YES 。而遍历结束后，没有找到指定的方法，就执行原 respondsToSelector: 的实现方法。

```
static void RACSwizzleGetClass(Class class, Class statedClass) {
	SEL selector = @selector(class);
	Method method = class_getInstanceMethod(class, selector);
	IMP newIMP = imp_implementationWithBlock(^(id self) {
		return statedClass;
	});
	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));
}
```
该方法将修改指定的 class 类的 class 方法，使其返回 statedClass 类的类型。

```
static void RACSwizzleMethodSignatureForSelector(Class class) {
	IMP newIMP = imp_implementationWithBlock(^(id self, SEL selector) {

		Class actualClass = object_getClass(self);
		Method method = class_getInstanceMethod(actualClass, selector);
		if (method == NULL) {
			struct objc_super target = {
				.super_class = class_getSuperclass(class),
				.receiver = self,
			};
			NSMethodSignature * (*messageSend)(struct objc_super *, SEL, SEL) = (__typeof__(messageSend))objc_msgSendSuper;
			return messageSend(&target, @selector(methodSignatureForSelector:), selector);
		}

		char const *encoding = method_getTypeEncoding(method);
		return [NSMethodSignature signatureWithObjCTypes:encoding];
	});

	SEL selector = @selector(methodSignatureForSelector:);
	Method methodSignatureForSelectorMethod = class_getInstanceMethod(class, selector);
	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(methodSignatureForSelectorMethod));
}
```
该方法为指定的 class 类重新定义 methodSignatureForSelector: 的实现方法，在新的实现方法中，会先查找指定类的指定方法，如果方法存在，那么就根据该方法的类型编码创建一个方法签名并返回，如果不存在，则调用父类的 methodSignatureForSelector: 方法。

```
static Class RACSwizzleClass(NSObject *self) {
	Class statedClass = self.class;
	Class baseClass = object_getClass(self);

	Class knownDynamicSubclass = objc_getAssociatedObject(self, RACSubclassAssociationKey);
	if (knownDynamicSubclass != Nil) return knownDynamicSubclass;

	NSString *className = NSStringFromClass(baseClass);

	if (statedClass != baseClass) {
		@synchronized (swizzledClasses()) {
			if (![swizzledClasses() containsObject:className]) {
				RACSwizzleForwardInvocation(baseClass);
				RACSwizzleRespondsToSelector(baseClass);
				RACSwizzleGetClass(baseClass, statedClass);
				RACSwizzleGetClass(object_getClass(baseClass), statedClass);
				RACSwizzleMethodSignatureForSelector(baseClass);
				[swizzledClasses() addObject:className];
			}
		}

		return baseClass;
	}

	const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;
	Class subclass = objc_getClass(subclassName);

	if (subclass == nil) {
		subclass = objc_allocateClassPair(baseClass, subclassName, 0);
		if (subclass == nil) return nil;

		RACSwizzleForwardInvocation(subclass);
		RACSwizzleRespondsToSelector(subclass);

		RACSwizzleGetClass(subclass, statedClass);
		RACSwizzleGetClass(object_getClass(subclass), statedClass);

		RACSwizzleMethodSignatureForSelector(subclass);

		objc_registerClassPair(subclass);
	}

	object_setClass(self, subclass);
	objc_setAssociatedObject(self, RACSubclassAssociationKey, subclass, OBJC_ASSOCIATION_ASSIGN);
	return subclass;
}
```
RACSwizzleClass 函数会为指定的实例对象绑定一个动态类，这个类一般是由框架创建的子类。这个绑定的类的相关消息转发方法都是被处理的过的，参见上面的方法说明以及消息转发机制。

```
static void RACCheckTypeEncoding(const char *typeEncoding);
```
该函数可以用来检查方法类型编码是否合法。

```
static const char *RACSignatureForUndefinedSelector(SEL selector) {
	const char *name = sel_getName(selector);
	NSMutableString *signature = [NSMutableString stringWithString:@"v@:"];

	while ((name = strchr(name, ':')) != NULL) {
		[signature appendString:@"@"];
		name++;
	}

	return signature.UTF8String;
}
```
该方法返回指定选择器的方法类型编码，并且默认参数都是 OC 对象。

RACSelectorSignal 分类中的两个方法实际都是调用的 NSObjectRACSignalForSelector 函数，其提供了三个参数：self，selector，protocol。
1. 获取选择器 selector 的别名选择器。
2. 如果已经绑定了相应的信号流，那么就直接返回该信号流。
3. 为当前的实例对象 self 绑定一个类 class ，这个类的相关方法都经过了处理。
4. 创建一个信号流绑定到当前的对象，如果该对象销毁，那么信号流结束传递信号量。
5. 从绑定的 class 类中查找指定的 selector 选择器方法，如果没有找到相应的方法：

    1）如果参数 protocol 为空，那么便从 selector 中获取方法类型编码，否则就从协议中查找到指定方法并获取他的类型编码。

    2）检查编码是否合法。

    3）指定接收到 selector 消息时，进行转发。如果指定失败，就直接返回一个错误信号流。

6. 如果指定的 selector 方法查询到了，并且不是转发给其他的方法 _objc_msgForward ，那么：

    1）获取方法的编码并检验其合法性。

    2）向 class 类中添加别名方法，并且其实现方法指向查询到的方法实现。

    3）指定 class 接收到 selector 消息后，便进行转发。

7. 最后返回创建的 subject 信号流。

参考下面的源码：
```
static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol) {
	SEL aliasSelector = RACAliasForSelector(selector);

	@synchronized (self) {
		RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
		if (subject != nil) return subject;

		Class class = RACSwizzleClass(self);
		NSCAssert(class != nil, @"Could not swizzle class of %@", self);

		subject = [[RACSubject subject] setNameWithFormat:@"%@ -rac_signalForSelector: %s", RACDescription(self), sel_getName(selector)];
		objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

		[self.rac_deallocDisposable addDisposable:[RACDisposable disposableWithBlock:^{
			[subject sendCompleted];
		}]];

		Method targetMethod = class_getInstanceMethod(class, selector);
		if (targetMethod == NULL) {
			const char *typeEncoding;
			if (protocol == NULL) {
				typeEncoding = RACSignatureForUndefinedSelector(selector);
			} else {
				// Look for the selector as an optional instance method.
				struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);

				if (methodDescription.name == NULL) {
					// Then fall back to looking for a required instance
					// method.
					methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
					NSCAssert(methodDescription.name != NULL, @"Selector %@ does not exist in <%s>", NSStringFromSelector(selector), protocol_getName(protocol));
				}

				typeEncoding = methodDescription.types;
			}

			RACCheckTypeEncoding(typeEncoding);

			// Define the selector to call -forwardInvocation:.
			if (!class_addMethod(class, selector, _objc_msgForward, typeEncoding)) {
				NSDictionary *userInfo = @{
					NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedString(@"A race condition occurred implementing %@ on class %@", nil), NSStringFromSelector(selector), class],
					NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@"Invoke -rac_signalForSelector: again to override the implementation.", nil)
				};

				return [RACSignal error:[NSError errorWithDomain:RACSelectorSignalErrorDomain code:RACSelectorSignalErrorMethodSwizzlingRace userInfo:userInfo]];
			}
		} else if (method_getImplementation(targetMethod) != _objc_msgForward) {
			// Make a method alias for the existing method implementation.
			const char *typeEncoding = method_getTypeEncoding(targetMethod);

			RACCheckTypeEncoding(typeEncoding);

			BOOL addedAlias __attribute__((unused)) = class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
			NSCAssert(addedAlias, @"Original implementation for %@ is already copied to %@ on %@", NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), class);

			// Redefine the selector to call -forwardInvocation:.
			class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
		}

		return subject;
	}
}
```

##值类型
 RAC提供了少量杂项类来方便的表示流中的值：
* RACTuple:是一个常量大小的集合类型，可以包含nil(使用RACTupleNil表示)。这个常常用来表示多种流组合后的值。
* RACUnit:是一个单例的空值。通常它表示流中某些时候不存在有意义的数据.
* RACEvent:用一个单一的值来表示任何信号事件，主要被RACSignal的-materialize方法使用。

###RACTuple和RACTupleNil
RACTuple是RAC中的元组类。

在 CocoaReactive 中，有些信号流传递的信号量是由其他多个信号流传递的信号量组合而成的，而这多个信号量则是封装在一个 RACTuple 实例中进行传递的，所以理解该类，有助于我们理解信号量的使用。

其实该类的使用十分简单，通常只要了解两个宏即可，一个是将变量封装成实例的 RACTuplePack(…) ，另一个则是将封装的变量解析成相应变量的 RACTupleUnpack(…)，其使用如下例子：
```
RACTupleUnpack(NSString *string, NSNumber *num) = RACTuplePack(@"foo", @5);

//上面宏的使用同下面直接使用实例效果一样
RACTuple *t = [RACTuple tupleWithObjects:@"foo", @5, nil];
NSString *string = t[0];
NSNumber *num = t[1];
```
RACTuple 的本质是对一个 NSArray 类型的属性的封装，该内部属性为 backingArray 。

在该类中的 count、first、second、third、fourth、fifth、last 等属性都是对 backingArray 的相应数量或对应的变量的访问，但是不同的是，请求的变量序号大于其实际拥有的变量数量时，直接返回 nil 而不会报错。

RACTuple 类中提供了类方法用于创建实例对象，如下：
```
//这两个方法有点类似，区别是前者不会将参数 array 中的 NSNull 实例对象转化为 RACTupleNil 实例对象，而后者可以通过参数 convert 进行控制
+ (instancetype)tupleWithObjectsFromArray:(NSArray *)array;
+ (instancetype)tupleWithObjectsFromArray:(NSArray *)array convertNullsToNils:(BOOL)convert;

//指定要封装的变量，nil 表示结束位置，所以要对 nil 进行封装，应使用 RACTupleNil 替代
+ (instancetype)tupleWithObjects:(id)object, ... NS_REQUIRES_NIL_TERMINATION;

//获取 backingArray 中指定索引的变量，如果其为 RACTupleNil 或索引超出范围， 则返回 nil
- (nullable id)objectAtIndex:(NSUInteger)index;

//返回一个新的数组，其包含所有的变量，并且会将 RACTupleNil 实例转换为 NSNull 实例
- (NSArray *)allObjects;

//添加一个新的变量，其返回的是一个新的 RACTuple 实例对象，并且参数 obj 可以是 nil ，其实际会被转换为 RACTupleNil 继续保存
- (__kindof RACTuple *)tupleByAddingObject:(nullable id)obj;
```
另外，RACTuple 有几个特殊的子类，这些子类指定了其封装的变量个数，其初始化中的变量都是 RACTupleNil。
* RACOneTuple
* RACTwoTuple
* RACThreeTuple
* RACFourTuple
* RACFiveTuple

RACTupleNil 是 NSObject 的子类，它用来表示 RACTuple 中保存的 nil ，在使用时，调用它的 tupleNil 方法，获取一个全局变量。
```
+ (RACTupleNil *)tupleNil {
    static dispatch_once_t onceToken;
    static RACTupleNil *tupleNil = nil;
    dispatch_once(&onceToken, ^{
        tupleNil = [[self alloc] init];
    });

    return tupleNil;
}
```

###RACUnit
是一个单例的空值。通常它表示流中某些时候不存在有意义的数据。在RACSignalSupport分类的视图重用中会用到该对象。

###RACEvent
RACEvent 是 ReactiveCocoa 框架中用来表示信号流所发送的事件信息的类，同三种信号量相对应，该类可以分为三种。
```
typedef NS_ENUM(NSUInteger, RACEventType) {
    RACEventTypeCompleted,
    RACEventTypeError,
    RACEventTypeNext
};
```
该类提供了三个类方法，可以很方便的创建上面三种类型的事件。
```
+ (RACEvent<ValueType> *)completedEvent;

+ (RACEvent<ValueType> *)eventWithError:(nullable NSError *)error;

+ (RACEvent<ValueType> *)eventWithValue:(nullable ValueType)value;
```
>completedEvent 方法会返回一个共享的实例对象，并且这三个方法都调用了同一个方法 initWithEventType:object: 。

提供了一个属性表示事件类型:
```
@property (nonatomic, assign, readonly) RACEventType eventType;
```
提供了一个属性表示事件是否结束，即该事件类型是否是 RACEventTypeError 或 RACEventTypeCompleted：
```
@property (nonatomic, getter = isFinished, assign, readonly) BOOL finished;
```
提供了一个属性表示同事件类型为 RACEventTypeError 的事件相关联的错误信息：
```
@property (nonatomic, strong, readonly, nullable) NSError *error;
```
提供了一个属性表示同事件类型为 RACEventTypeNext 的事件相关联的值：
```
@property (nonatomic, strong, readonly, nullable) ValueType value;
```
error 和 value 实际都是由内部属性 object 保存的。

##值转换RACValueTransformer
RACValueTransformer 是 NSValueTransformer 的子类，提供了一个方法，用来创建一个值转换器。
```
+ (instancetype)transformerWithBlock:(id (^)(id value))block 
{
    NSCParameterAssert(block != NULL); 
    RACValueTransformer *transformer = [[self alloc] init]; 
    transformer.transformBlock = block; 
    return transformer; 
}
```
其转换值的方法实际是创建时传递的 block 块参数，并且不支持反向转换。
```
- (id)transformedValue:(id)value {
    return self.transformBlock(value);
}
```

##RACRuntimeExtensions
https://blog.csdn.net/u011374318/article/details/84103704

##测试相关（略）


##ReactiveCocoa常见宏

RAC(TARGET, [KEYPATH, [NIL_VALUE]]):用于给某个对象的某个属性绑定。
```
// 只要文本框文字改变，就会修改label的文字
    RAC(self.labelView,text) = _textField.rac_textSignal;
```

RACObserve(self, name):监听某个对象的某个属性,返回的是信号。
```
[RACObserve(self.view, center) subscribeNext:^(id x) {

        NSLog(@"%@",x);
    }];
```

@weakify(Obj)和@strongify(Obj),一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。

RACTuplePack：把数据包装成RACTuple（元组类）
```
// 把参数中的数据包装成元组
    RACTuple *tuple = RACTuplePack(@10,@20);
```

RACTupleUnpack：把RACTuple（元组类）解包成对应的数据。
```
// 把参数中的数据包装成元组
    RACTuple *tuple = RACTuplePack(@"xmg",@20);

    // 解包元组，会把元组的值，按顺序给参数里面的变量赋值
    // name = @"xmg" age = @20
    RACTupleUnpack(NSString *name,NSNumber *age) = tuple; 
```

##参考
>https://www.cnblogs.com/oc-bowen/p/5895638.html
>
>ReactiveCocoa解读-订阅信号 https://www.jianshu.com/p/f9e264f21dc7