# 第二章 进程管理
2.1 进程与线程
2.1.1进程的概念和特征
动态、并发、独立、异步、结构

2.1.2进程的状态和转移
创建、阻塞、就绪、运行、结束

2.1.3进程控制
创建：
1.分配唯一的进程标识号，申请一个空白的PCB
2.分配资源，为程序、数据、用户栈分配内存
3.初始化PCB
4.就绪队列能接纳新进程，就插入到就绪队列

终止：
1.根据进程标识符找到PCB，读取进程状态
2.处于执行状态就终止，释放处理机资源
3.如果有子进程，应全部终止
4.将进程所拥有的全部资源，归还给父进程或系统
5.将PCB从所在队列中删除

阻塞、唤醒
切换

2.1.4进程的组织
2.1.5进程的通信
1.共享内存（匿名、具名）
必须在同一个主机，两端都可以随机访问。管理复杂，安全性低。
2.消息传递（管道、FIFO、消息队列、信号）
管道要求是有关系的两个进程，管道只能是读或者写。popen要求提供另一端进程文件名，pipe要求是父子进程。
命名管道可以跨主机，但是在不同平台兼容性问题。
信号：适合数据量小，并且要求对方做出回应的临时通信需求
消息队列：任何进程都能读写，同时支持多个进程，只在内存中实现，兼容性良好
3.同步（信号量、锁、互斥量）
4.远程过程调用（RPC）

2.1.6线程和多线程模型
线程
线程和进程的比较：
1.调度：线程是独立调度的基本单位，进程是拥有资源的基本单位。
2.拥有资源
3.并发性：都可以并发
4.系统开销：进程撤销和创建都需要系统分配资源，切换时也要进行执行上下文的保存和恢复。线程切换只需保存和设置少量寄存器。线程间的通信也很简单。
5.地址空间和其他资源
6.通信方面：进程间通信IPC需要进程同步和互斥手段辅助，以保证数据一致性。线程间可以直接读写数据段来通信

3线程的属性
4线程的实现方式：用户级线程、内核级线程
5多线程模型：多对一、一对一、多对多



2.2 处理机调度
2.2.1调度概念
1.调度的基本概念
2.调度的层次
1）作业调度（高级调度），发生在内存和外存间，只调入调出一次
2）内存调度（中级调度），发生在内存和外存间，会频繁进行
3）进程调度（低级调度），从就绪队列选择一个，给它分配处理机，频繁进行

3三级调度联系
4调度的时机、切换、过程

2.2.3进程调度方式
1.非剥夺调度，非抢占式
2.剥夺调度，抢占式

2.2.4调度的基本准则
2.2.5调度算法
1.先来先服务FCFS，作业、进程调度
2.短作业优先SJF，作业调度
3.优先级调度算法，作业、进程调度
4.高响应比优先调度算法
5.时间片轮转调度算法
6.多级反馈队列调度算法：多个优先级队列，优先级越高，每个进程运行的时间片越小。进程进入内存后，先放到最高优先级队列的末尾。不能执行完之后，放到下一级队列的末尾。仅当前一级队列为空时，才执行下一级队列。

2.3 进程同步
2.3.1基本概念
1.临界资源
2.同步
3.互斥
同步机制准则：空闲让进、忙则等待、有限等待、让权等待

2.3.2临界区互斥的实现
2.3.3信号量
1.整型信号量
2.记录型信号量
3.利用信号量实现同步
4.利用信号量实现进程互斥
5.利用信号量实现前驱关系

2.3.4管程
2.3.5经典同步问题


2.4 死锁
2.4.1.死锁的定义
多个进程因竞争资源而造成的一种僵局，导致程序无法推进。

2.死锁产生的原因
1.系统资源竞争
2.进程推进顺序非法

3.死锁的产生的四个必要条件
互斥条件
请求保持
不可剥夺
循环等待

2.4.2死锁的处理
1.预防死锁：破坏四个必要条件中的一个；或者允许死锁产生，但发生时可以检测及恢复
2.避免死锁
3.死锁检测及解除

2.4.3死锁的预防
1.破坏互斥条件，不太可行
2.破坏不剥夺条件，反复申请、释放，浪费资源
3.破坏请求和保持条件，预先静态分配，运行前一次申请全部资源，既不申请新的，也不释放持有的。不能满足则等待。
4.破坏循环等待条件
有序资源分配法
https://blog.csdn.net/william_munch/article/details/82833630
是操作系统中预防死锁的一种算法，这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。
系统要求申请进程：
1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
2、在申请不同类资源时，必须按各类设备的编号依次申请。
例如：进程PA，使用资源的顺序是R1，R2；
进程PB，使用资源的顺序是R2，R1；
若采用动态分配有可能形成环路条件，造成死锁。
采用有序资源分配法：R1的编号为1，R2的编号为2；
PA：申请次序应是：R1，R2
PB：申请次序应是：R1，R2
这样就破坏了环路条件，避免了死锁的发生。


2.4.4死锁避免
1.系统安全状态
2.银行家算法（避免死锁）
目标：找到一个资源申请的安全序列
银行家算法：银行家算法是从当前状态出发，按照系统各类资源剩余量逐个检查各进程需要申请的资源量，找到一个各类资源申请量均小于等于系统剩余资源量的进程P1。然后分配给该P1进程所请求的资源，假定P1完成工作后归还其占有的所有资源，更新系统剩余资源状态并且移除进程列表中的P1，进而检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。若找不到这样的安全序列，则当前状态不安全。
https://www.jianshu.com/p/5d01e5db5eaf?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

2.4.5死锁检测和解除
1.资源分配图（检测死锁）
https://www.jianshu.com/p/eae5f6c91d38
资源、进程组成的图，资源到进程的边表示已分配资源，进程到资源的边表示新的资源请求。资源能满足申请，就去掉各资源和该进程的边，使其成为孤立点。所有进程点都能孤立，则这个资源分配图可完全简化，因此，不会产生死锁。

2.死锁定理
当且仅当S状态的资源分配图不可完全简化时，S为死锁。

3.死锁解除
1.资源剥夺法
2.撤销进程法
3.进程回退法


补充
5.IPC
进程通信的机制和同步
不使用共享变量的进程通信

IPC facility提供两个操作
*send(message)
*receive(message)

如果P和Q想通信，需要：
*在它们之间建立通信链路
*通过send/receive交换消息

通信链路的实现
*物理：例如共享内存，硬件总线
*逻辑：例如逻辑属性

消息传递可以是间接或直接的。
1.间接通信：pA->内核->pB
* 定向从消息队列接收消息
每个消息队列都有一个唯一的ID
只有它们共享了一个消息队列，进程才能通信
* 通信链路的属性
只有进程共享一个共同的消息队列，才能建立链路
链接可以与许多进程相关联
每对进程可以共享多个通信链路
链接可以是单向或双向
* 操作
创建一个新的消息队列
通过消息队列发送和接收消息
销毁消息队列
* 原语
send(A,message)发送消息到队列A
receive(A,message)从队列A接受消息

2.直接通信：pA->shared->pB
* 原语
send(P,message) 发送消息到进程P
receive(Q,message)从进程Q接收消息
* 通信链路的属性
自动建立链路
一条链路恰好对应一对通信进程
每对进程之间只有一个链路存在
链路可以使单向的，但通常是双向的

消息传递可以是阻塞（同步）或非阻塞（异步）。

通信链路缓冲
队列的消息被附加到链路，可以是以下三种：
1.0容量：发送方必须等待接收方
2.有限容量：发送方必须等待，如果队列满
3.无限容量：发送方不需要等待

6.信号、管道、消息队列和共享内存
* signal(信号)
软件中断通知事件处理
例如：SIGFPE,SIGKILL,SIGUSRI,SIGSTOP,SIGCONT

* 接收到信号时会发生什么
1. catch：指定信号处理函数被调用
2. ignore：依靠操作系统的默认操作
例如：Abort，memory dump，suspend or resume process
3. mask:闭塞信号因此不会被传送
可能是暂时的（当处理同样类型的信号）
* 不足
不能传递要交换的任何数据

操作系统如何实现：
1.register handles
2.dispatch to handler
3.signal handler stack

管道
* 子进程从父进程继承文件描述符
* 进程不知道或不关心从键盘、文件、程序读取或写入到终端，文件、程序
* shell
例子：ls | more
创建管道
为ls创建一个进程，设置stdout为管道写端
为more创建一个进程，设置stdin为管道读端

消息队列
消息队列按FIFO来管理消息
Message：作为一个字节序列存储
Message Queues：消息数组
FIFO & FIFO configuration

共享内存
直接通信方式
* 进程
每个进程都有私有地址空间
在每个地址空间内，明确地设置了共享内存段
* 优点
快速，方便地共享数据
* 不足
必须同步数据访问

* 特点
*最快的方法
*一个进程写另一个进程立即可见
*没有系统调用干预
*没有数据复制
*不提供同步：由程序员提供同步

* 实现
同一块物理内存映射到不同进程的相同或不同的虚拟地址。






