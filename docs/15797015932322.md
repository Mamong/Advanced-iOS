map容器

[TOC]

序列容器是管理数据的宝贵工具，但对大多数应用程序而言，序列容器不提供方便的数据访问机制。举个简单的示例，当我们用它处理姓名和地址时，在这种场景下，序列容器可能并不能如我们所愿。一种典型的方法是通过名称来寻找地址。如果记录保存在序列容器中，就只能通过搜索得到这些数据。相比而言，map 容器提供了一种更有效的存储和访问数据的方法。

map 容器是关联容器的一种。在关联容器中，对象的位置取决于和它关联的键的值。键可以是基本类型，也可以是类类型。字符串经常被用来作为键，如果想要保存姓名和地址的记录，就可以这么使用。名称通常可能是一个或多个字符串。关联容器中的对象位置的确定取决于容器中的键的类型，而且对于特定容器类型的内部组织方式，不同的 STL 有不同的实现。

map 容器有 4 种，每一种都是由类模板定义的。所有类型的 map 容器保存的都是键值对类型的元素。map 容器的元素是 pair<const K，T> 类型的对象，这种对象封装了一个 T 类型的对象和一个与其关联的 K 类型的键。pair 元素中的键是 const，因为修改键会扰乱容器中元素的顺序。每种 map 容器的模板都有不同的特性：

    map<K，T>容器，保存的是 pair<const K，T> 类型的元素。pair<const K,T> 封装了一对键对象，键的类型是 K，对象的类型是 T。每个键都是唯一的，所以不允许有重复的键；但可以保存重复的对象，只要它们的键不同。map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less<K> 对象比较。
    multimap<K，T> 容器和 map<K，T> 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。和 map<K，T> 不同的是，multimap<K，T> 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 <const K,T> 元素。
    unordered_map<K，T> 中 pair< const K，T>元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。哈希值是由一个叫作哈希的过程生成的整数，本章后面会解释这一点。unordered_map<K，T>不允许有重复的键。
    unordered_multimap<K,T> 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。


map 和 mutilmap 容器的模板定义在 map 头文件中，unordered_map 和 unordered_multimap 容器的模板定义在 unordered_map 头文件中。可以通过 map 模板类型名的前缀来识别容器的特性。

    multi前缀表明键不必唯一，但如果没有这个前缀，键必须唯一。
    unordered_prefix 前缀表明容器中元素的位置是通过其键值所产生的哈希值来决定的，而不是通过比较键值决定的。如果没有该前缀，那么元素的位置就由比较键值决定。


接下来让我们先学习 map 容器。

##map
序列容器是管理数据的宝贵工具，但对大多数应用程序而言，序列容器不提供方便的数据访问机制。举个简单的示例，当我们用它处理姓名和地址时，在这种场景下，序列容器可能并不能如我们所愿。一种典型的方法是通过名称来寻找地址。如果记录保存在序列容器中，就只能通过搜索得到这些数据。相比而言，map 容器提供了一种更有效的存储和访问数据的方法。

map 容器是关联容器的一种。在关联容器中，对象的位置取决于和它关联的键的值。键可以是基本类型，也可以是类类型。字符串经常被用来作为键，如果想要保存姓名和地址的记录，就可以这么使用。名称通常可能是一个或多个字符串。关联容器中的对象位置的确定取决于容器中的键的类型，而且对于特定容器类型的内部组织方式，不同的 STL 有不同的实现。

map<K，T> 类模板定义在 map 文件头中，它定义了一个保存 T 类型对象的 map，每个 T 类型的对象都有一个关联的 K 类型的键。容器内对象的位置是通过比较键决定的。可以用适当的键值从 map 容器中检索对象。图 1 展示了一个用名称作为键的 map<K,T> 容器，对象是整数值，用来表示年龄。


![图 1 map<K，T>容器的概念展示图](http://c.biancheng.net/uploads/allimg/180914/2-1P914095K52Z.jpg)

图 1 表示的是 map<Name，size_t> 类型的容器，其中的 Name 类可以这样定义：

    class Name
    {
    private:
        std::string firstname{}; std::string secondname{};
    public:
        Name(std::string first, std::string second) : firstname{first}, secondname{second}{};
        Name()=default;
        bool operator<(const Name& name)
        {
            return secondname < name.secondname ||((secondname == name.secondname) && (firstname < name.firstname));
        }
    };

为了可以在必要时生成默认的元素，容器保存的对象通常需要定义一个默认的构造函数。当两个 Name 对象的 secondname 不同时，成员函数 operator<() 通过比较 secondname 来确定对象的顺序。如果 secondname 相等，比较结果就由 firstname 决定。string 类定义了 operator<()，因而可以用默认的 less<string> 来比较。

不要因为 map 使用 less<K> 对元素排序就被误导，这些元素并没有被组织成一个简单的有序序列，STL map 容器对元素的组织方式并没有具体要求，但元素一般都会保存在一个平衡二叉树中。容器中的元素被组织成一个平衡二叉树，因而树的高度——根节点和叶节点之间的高度是最低的。如果每个节点的左子树和右子树的高度差不超过 1，那么可以说这棵二叉树就是平衡的。图 2 展示了图 1 所表示的 map 容器可能的平衡二叉树。


![图 2 map 容器的内部组织图](http://c.biancheng.net/uploads/allimg/180914/2-1P91409592C35.jpg)

图 2 所示的树有 3 层，所以从根节点开始，找到任意的元素最多需要 3 步。这里选择的根节点可以使树的高度最小，而且对于每个父节点来说，它的键值大于它的左子节点，但小于它的右子节点。为了保持二叉树的平衡，当添加一个新的元素时，可能会导致根节点发生改变。所以显然，在添加新元素时，为了保持树的平衡，会产生一些额外的开销。作为回报，容器中的元素越多，相对于线性排列和非平衡树，平衡树组织元素的效率也越高。从包含 n 个元素的平衡二叉树中检索一个随机元素所需的时间为 O(log2n)，从序列中检索元素所需的时间为 O(n)。

注意，O(n) 计算时间随着参数的增加而增加。O 被认为是有序的，O(n) 表明线性执行时间在以 n 增加。O(log2n) 计算时间远没有 n 增加得快，因为它是以 log2n 计算的。

###创建
map 类模板有 4 个类型参数，但一般只需要指定前两个模板参数的值。第 1 个是键的类型，第 2 个是所保存对象的类型，第 3 个和第 4 个模板参数分别定义了用来比较键的函数对象的类型以及为 map 分配内存的对象的类型。最后两个参数有默认值。在本节稍后部分会展示如何定义不同类型的比较键的函数对象，但不会定义可替代的分配器类型。

map<> 容器类的默认构造函数会创建一个空的 map 容器。例如，可以创建一个这样的容器，size_t 类型的值表示年龄，作为它保存的值，string 类型的值表示名称，作为它的键：

    std::map<std::string, size_t> people;

第 1 个模板类型参数指定键的类型是字符串，第 2 个模板类型参数指定值的类型为 size_t。当然，这里的模板类型参数可以是任何类型，唯一的要求是键必须可以用 less<K> 比或用自己指定的另一个函数对象来替代。

map<K，T> 中的每个元素都是同时封装了对象及其键的 pair<const K，T> 类型对象，这里不能修改 const K。pair<T1,T2> 类的模板定义在 utility 头文件中，它被包含在 map 头文件中。因此 people 容器中的元素是 pair<const string,size_t> 类型的。pair<T1，T2> 这种模板类型并不是专门在这种情况下使用的。必要时可以用它将两个不同类型的对象组装成一个对象。本章稍后将讲解更多这方面的内容。

我们可以用初始化列表来指定 map 的初始值，但因为 map 中包含的是 pair<const K，T> 类型的元素，所以初始化列表中的值也必须是这种类型。下面展示了如何为 people 容器设置初始值：

    std::map<std::string, size_t> people{{"Ann", 25}, {"Bill", 46},{"Jack", 32},{"Jill", 32}};

初始化列表中的值是通过将每个嵌套花括号中的两个值传递给构造函数产生的，因此列表会包含 4 个 pair<const string,size_t> 对象。

utility 头文件中定义了 make_pair < T1，T2 >() 函数模板，它提供了一种组合 T1 和 T2 类型对象的简单方法。因此，可以按如下方式创建 pair 对象来初始化 map:

    std::map<std::string,size_t> people{std::make_pair("Ann",25),std::make_pair("Bill", 46),std::make_pair("Jack", 32),std::make_pair("Jill", 32)};

make_pair<T1，T2>() 函数模板从函数参数中推断出类型参数值，因而由参数列表中调用 make_pair<>() 返回的是 <char const*,int> 类型的对象。因为这些对象都是 map 容器 people 的初始值，所以这些 pair 对象会被转换成 map 中元素的类型，即 pair<const string，size_t>。

pair<T1, T2> 的公共成员变量 first 和 second 分别保存了存储 T1 和 T2 类型的对象。只要原始 pair 对象的成员变量 first 和 second 可以隐式转换为与目标 pair 对象成员变量相同类型的变量，pair<T1;T2> 模板的构造函数就可以提供这种类型的隐式转换。

map<K,T> 模板定义了移动和复制构造函数，所以可以复制现有的容器。例如：

    std::map<std::string, size_t> personnel {people}; // Duplicate people map

map 容器 personnel 包含 people 元素的副本。

可以用另一个容器的一段元素来创建一个 map，用开始和结束迭代器以通常的方式指定元素。显然，迭代器指向的 pair 元素的类型必须和容器兼容。这里有一个示例：

    std::map<std::string, size_t> personnel {std::begin(people),std::end(people)};

这样就生成了 personnel，并且用 people 容器的迭代器指定的元素对它进行了初始化。map 容器提供了双向迭代器，这样就可以通过自增或自减访问元素。map 容器还提供了反向迭代器，所以可以从最后一个元素遍历到第一个元素。personnel 容器包含的元素和 people 完全相同。当然，也可以用另一个容器的元素子集来创建容器：

    std::map<std::string,size_t> personnel {++std::begin(people),std::end(people)};
    
###插入数据
map<K，T> 容器的成员函数 insert() 有多个版本，它们可以在 map 中插入一个或多个 pair<const K,T> 对象。只能插入 map 中不存在的元素。下面这个代码片段展示了如何插入单个元素：

    std::map<std:: string,size_t> people {std::make_pair ("Ann",25),std::make_pair("Bill",46) , std::make_pair ("Jack",32), std::make_pair("Jill",32)};
    auto pr = std::make_pair("Fred",22); //Create a pair element and insert it
    auto ret_pr = people.insert(pr);
    std::cout << ret_pr.first->first << " "<< ret_pr.first->second<< "" << std:: boolalpha <<ret_pr.second << "\n"; // Fred 22 true

第一条语句生成了一个 map 容器，并用初始化列表中的 4 个值对它进行了初始化；在这种情况下，这些值会被隐式转换为要求的类型。第二条语句生成了另一个被插入的 pair 对象 pr。pr 对象的类型是 pair<const char*,int>，因为 make_pair<>() 函数模板的类型参数是从参数类型推断出来的；但是在 insert() 操作中，这个对象会被隐式转换为容器元素类型。当然，如果不想依靠隐式转换，可以生成所要求类型的 pair 对象：

    auto pr = std::make_pair<std:: string, size_t> (std:: string { "Fred"},22);

make_pair<>() 模板的显式类型参数决定了返回的 pair 对象的类型。可以把文字字符串作为第一个参数，然后通过隐式转换创建键需要的字符串对象。可以省略 make_pair<>() 的模板类型参数，让编译器去推断它们。假设像下面这样声明：

    auto pr = std::make_pair ("Fred",22) ; // pair<const char*, int>

这里会返回和所要求类型不同的 pair 对象。当允许编译器推断模板参数类型时，make_pair() 的参数可以准确地确定模板参数的类型。第一个参数是一个 const char* 类型的字符串，第二个参数是 int 类型。尽管已经说明了元素的类型，但在这种情况下，并没有多大的用处，因为在插入一个新元素时，pair 对象可以被隐式转换为容器所需类型。当 make_pair() 的参数的类型不能隐式转换成容器的键和对象的类型时，就需要注意了。

成员函数 insert() 会返回一个 pair<iterator,bool> 对象。对象的成员 first 是一个迭代器，它要么指向插入元素，要么指向阻止插入的元素。如果 map 中已经保存了一个和这个键相同的对象，就会出现后面这种情况。这个对象的成员变量 second (布尔型)是返回对象，如果插入成功，返回值为 true，否则为 false。

输出语句像我们看到的那样，访问插入 pair 的成员变量 first 的表达式是 ret_pr.first->first。ret_pr 的成员变量 first 是一个指向 pair 对象的迭代器，所以可以使用->操作符来访问它的成员变量 first。输出展示了插入的元素。可以通过下面这个循环进行验证：

    for (const auto& p : people)
        std::cout << std::setw(10) << std::left << p.first << " "<< p.second <<"\n";

循环变量 p 通过引用依次访问 map 容器 people 中的每个元素。输出如下：

Ann 25
Bill 46
Fred 22
Jack 32
Jill 32
元素是以键的升序排列的，因为 map 中默认使用 less<string> 函数对象对它们进行排序。

通过执行下面这两条语句，可以看出元素插入后的效果：

    ret_pr = people.insert(std::make_pair("Bill", 48));
    std:: cout << ret_pr.first->first <<" "<<ret_pr.first->second<< " "<<std::boolalpha<<ret_pr.second << "\n"; // Bill 46 false

程序会输出如注释所示的内容。insert() 返回了一个 pair 对象 ret_pr，它的成员变量 first 指向 map 中已有的和键匹配的元素，成员变量 second 为 false，表明元素没有插入成功。

当元素已经存在时，如果想将键值“Bill”对应的年龄值改为 48，可以像下面这样使用 insert() 返回的 pair 对象来做到这一点：

    if(!ret_pr.second) // If the element is there change the age
        ret_pr.first—>second = 48;

当键已经存在于 map 容器中时，ret_pr 的成员变量 second为false，所以这段代码会将 map 中这个元素的成员变量 second 的值设为 48。

可以用 pair 构造函数生成的对象作为 insert() 的参数：

    ret_pr = people.insert(std::pair<const std::string, size_t> {"Bill", 48});

这里会调用一个具有右值引用参数的 insert() 版本，所以假如元素不在容器中，那么它会被移到容器中。

也可以提供一个提示符来指出元素插入的位置。提示符是迭代器的形式，它指向容器中的一个现有元素，通常从提示符指示的位置开始查找新元素的插入位置。好的提示符可以提高插入操作的速度，反之亦然。例如：

    auto ret_pr = people.insert(std::make_pair("Jim", 48));
    people.insert (ret_pr.first, std::make_pair ("Ian", 38)）；

第一条语句插入了一个元素，并像前面那样返回了一个对象。pair 对象的成员变量 first 是一个指向被插入的元素或容器中与插入元素有相同键的元素的迭代器。

下一个 insert() 函数的第一个参数和上面的提示符有关，所以这里就是插入元素的地方。insert() 的第二个参数指定的新元素会被插入到提示符的前面，并尽可能地靠近它。如果提示符不能以这种方式使用，那么将忽略它。同样地，如果被插入的元素已经在 map 中，会导致元素插入失败。带提示符的 insert() 调用会返回一个指向被插入元素或容器中阻止此插入操作的元素的迭代器，因此可以使用返回值来确定插入是否成功。当确定元素不存在时，可以只提供一个插入符，这是一个好的想法。如果不那么确定，而且仍然想使用插入符，map 中的 count() 函数对我们有一些帮助。它会返回 map 中指定键对应元素的数目，这个数目可能是 0 或 1。

因此代码可以这样写：

    if (!people.count("Ian"))
        people.insert (ret_pr.first, std::make_pair ("Ian", 38));

只有当 count() 函数返回 0 时，insert() 才会被调用，这说明“Ian”键不在 map 中。当然，在不用提示插入元素时，需要做一次这样的检查，但 insert() 的返回值不管怎样都能告诉我们插入结果。

也可以将外部源中的一段元素插入 map 中，这些元素不必来自另一个 map 容器，但必须和被插入容器中的元素是同类型。这里有一些示例：

    std::map<std::string, size_t> crowd {{"May", 55}, {"Pat",66}, {"Al", 22}, {"Ben", 44}};
    auto iter = std::begin(people);
    std::advance(iter, 4);  // begin iterator+ 4
    crowd.insert(++std::begin(people),iter); // Insert 2nd, 3rd, and 4th elements from people

这里生成了一个新的 map 容器 crowd，它有 4 个初始元素。iter 被初始化为 people 的开始迭代器。map 容器的迭代器是双向的，这样就可以对它们进行自增或自减，但是不能加上或减去一个值。这里使用了一个在前面章节中用过的 advance() 函数模板的实例来对 iter 加 4，所以它将会指向第 5 个元素，它在下一行被当作 crowd 的成员函数 insert() 的参数，用来作为指定元素段的结束迭代器。map 容器 people 的开始迭代器加 1，然后用它作为插入元素段的开始迭代器，所以会从 crowd 的第 2 个元素开始插入 3 个元素。

下面是一个接受初始化列表作为参数的 insert() 版本：

    crowd.insert({{"Bert", 44}, {"Ellen”, 99}});

这里会将初始化列表中的两个元素插入到 map 容器 crowd 中。参数表达式生成的 initializer_list<> 对象是 initializer_list<const string，size_t> 类型，因为编译器知道这时 insert() 函数的参数是这种类型。当然，也可以单独创建一个初始化列表，然后将它作为参数传递给 insert() 函数：

    std::initializer_list<std::pair<const std:: string, size_t>>init {{"Bert", 44}, {"Ellen", 99}};
    crowd.insert(init);

initializer-list 模板的第一个类型参数必须为 const 类型。initializer_list <string,size_t> 无法隐式转换为 initializer_list<const string, size_t>，所以前者类型的对象不能作为 insert() 函数的参数。

下面你会看到这些操作的一个完整示例。此处会定义一个有点不同的对象。Name 类型代表人名，这个类定义的头文件的内容如下：

    // Defines a person's name
    #ifndef NAME_H
    #define NAME_H
    #include <string>                                // For string class
    #include <ostream>                               // For output streams
    #include <istream>                               // For input streams
    class Name
    {
    private:
        std::string first {};
        std::string second {};
    public:
        Name(const std::string& name1, const std::string& name2) : first (name1), second (name2) {}
        Name() = default;
        // Less-than operator
        bool operator<(const Name& name) const
        {
            return second < name.second || (second == name.second && first < name.first);
        }
        friend std::istream& operator>>(std::istream& in, Name& name);
        friend std::ostream& operator<<(std::ostream& out, const Name& name);
    };
    // Extraction operator overload
    inline std::istream& operator>>(std::istream& in, Name& name)
    {
        in >> name.first >> name.second;
        return in;
    }
    // Insertion operator overload
    inline std::ostream& operator<<(std::ostream& out, const Name& name)
    {
        out << name.first + " " + name.second;
        return out;
    }
    #endif

这个类非常简单，只有两个 string 类型的私有成员变量 first 和 second。这个构造函数可以接受 string 类型的参数或字符串常量参数。为了可以用这种对象作为 map 容器的键，必须为这个类定义 operator<()。为了便于对象的输入输出，也需要为流定义插入和提取操作。

map 容器中的元素是 std::pair<const Name，size_t> 类型，我们可以用下面定义的别名来简化代码：

    using Entry = std::pair<const Name, size_t>;

当容器是 map<name;site_t> 类型时，我们只能用 Entry 作为容器元素的类型。为了便于 map 元素的输出，我们可以把别名放到一个函数的定义中：

    Entry get_entry()
    {
        std::cout << "Enter first and second names followed by the age: ";
        Name name {};
        size_t age {};
        std::cin >> name >> age;
        return make_pair(name, age);
    }

从 cin 先后读入了一个 Name 对象和一个年龄值，并用它们生成了一个 pair 对象。从输入中读取 name 激发了定义在 Name.h 中的 istream 对象的重载函数 operator>>()，同样也支持流对象对 Name 对象的读入。

可以输出容器元素的辅助函数也是很有用的：

    void list_entries(const map<Name, size_t>& people)
    {
        for(auto& entry : people)
        {
            std::cout << std::left << std::setw(30) << entry.first<< std::right << std::setw(4) << entry.second << std::endl;
        }
    }

这里只用了基于范围的 for 循环来对元素进行遍历。循环变量 entry 依次引用 map 的每个元素。每一个 map 元素都是一个 pair 对象，它的成员变量 first 是 Name 类型的对象，成员变量 second 是 size_t 类型的值。

包含 main() 函数的源文件中的内容如下：

    // Storing names and ages
    #include <iostream>                              // For standard streams
    #include <iomanip>                               // For stream manipulators
    #include <string>                                // For string class
    #include <map>                                   // For map container class
    #include <utility>                               // For pair<> & make_pair<>()
    #include <cctype>                                // For toupper()
    #include "Name.h"
    using std::string;
    using Entry = std::pair<const Name, size_t>;
    using std::make_pair;
    using std::map;
    // Create a map entry from input
    Entry get_entry()
    {
        std::cout << "Enter first and second names followed by the age: ";
        Name name {};
        size_t age {};
        std::cin >> name >> age;
        return make_pair(name, age);
    }
    // Output the elements in a map
    void list_entries(const map<Name, size_t>& people)
    {
        for(auto& entry : people)
        {
            std::cout << std::left << std::setw(30) << entry.first
                  << std::right << std::setw(4) << entry.second << std::endl;
        }
    }
    int main()
    {
        map<Name, size_t> people {{{"Ann", "Dante"}, 25}, {{"Bill", "Hook"}, 46}, {{"Jim", "Jams"}, 32}, {{"Mark", "Time"}, 32}};
        std::cout << "\nThe initial contents of the map is:\n";
        list_entries(people);
        char answer {'Y'};
        std::cout << "\nEnter a Name and age entry.\n";
        while(std::toupper(answer) == 'Y')
        {
            Entry entry {get_entry()};
            auto pr = people.insert(entry);
            if(!pr.second)
            { // It's there already - check whether we should update
                std::cout << "Key \"" << pr.first->first << "\" already present. Do you want to update the age (Y or N)? ";
                std::cin >> answer;
                if(std::toupper(answer) == 'Y')
                    pr.first->second = entry.second;
            }
            // Check whether there are more to be entered
            std::cout << "Do you want to enter another entry(Y or N)? ";
            std::cin >> answer;
        }
        std::cout << "\nThe map now contains the following entries:\n";
        list_entries(people);
    }

定义一些额外的别名可以减少代码冗余。可以用 using::namespace 来完全消除对 std 名称限定的需要，但不赞成这么做，因为 std 中的所有命名都被有效导入到当前作用域内，这违背了定义命名空间的初衷。

map 容器的定义中有一些初始值，它们是初始化列表中的元素。这里只是为了说明如何在这种情况下使用嵌套花括号。在定义元素的每个初始化列表中，花括号中的 Name 对象都是初始化列表，每个初始化元素的花括号中都是一个 Name 对象和一个年龄值。最外面的一对花括号包括了所有元素的初始值。

辅助函数 list_entries() 用来显示容器的初始状态。从 for 循环中读入了更多的 entry 对象。循环由 answer 的值控制，如果一开始它的值就是 'Y'，那么最少执行一次循环，最少从键盘输入一个元素。entry 对象的类型是 Entry 它也是容器元素的类型。辅助函数 get_entry() 的返回对象被作为 entry 的初始值。然后将它作为 insert() 的参数插入到容器中。这个函数返回的 pair 对象有一个成员变量 first,它指向容器中和 entry 的键匹配的元素。如果在插入之前，容器中就存在这个元素，那么它指向的是原始容器中的元素。如果键已经存在于容器中，插入不会成功，并且 pr 的成员变量 second 为 false。

pr.first 是容器中元素的一个迭代器，因此 pr.first->second 可以访问与键关联的对象，如果用户确认需要更新，pr.first->second 的值会变为 entry.second。循环中的最后一个操作可以决定是否输入更多的 entry。在不需要输入更多的 entry 时，循环结束，用 list_entries() 函数输出这个容器最终的内容。

下面是这个示例的一些输出结果:

The initial contents of the map is:
Ann Dante                       25
Bill Hook                       46
Jim Jams                        32
Mark Time                       32

Enter a Name and age entry.
Enter first and second names followed by the age: Emma Nate 42
Do you want to enter another entry(Y or N)? y
Enter first and second names followed by the age: Emma Nate 43
Key "Emma Nate" already present. Do you want to update the age (Y or N)? Y
Do you want to enter another entry(Y or N)? y
Enter first and second names followed by the age: Eamonn Target 56
Do you want to enter another entry(Y or N)? n

The map now contains the following entries:
Ann Dante                       25
Bill Hook                       46
Jim Jams                        32
Emma Nate                       43
Eamonn Target                   56
Mark Time                       32
这些元素是以键的升序排列的，因为容器中的元素是使用 less<Name> 进行排序的。Name::operator<() 先比较姓，在姓相同时才比较名。这导致返回的姓名是正常的顺序。
###构造元素
map 容器的成员函数 emplace() 可以在适当的位置直接构造新元素，从而避免复制和移动操作。它的参数通常是构造元素，也就是 pair<const K,T> 对象所需要的。只有当容器中现有元素的键与这个元素的键不同时，才会构造这个元素。下面是一个示例：

    std::map<Name, size_t> people;
    auto pr = people.emplace (Name { "Dan","Druff"},77);

这个 map 包含的是 Name 类型(前面章节中定义过)的键。对象的类型是 size_t，所以 map 包含的是 pair<const Name,size_t> 类型的元素。emplace() 的第一个参数是一个 Name 对象，它同时也是元素的键，第二个参数是 size_t 类型的值，函数会用这些参数调用 pair<const Name,size_t> 的构造函数以在适当的位置生成元素。如果用 emplace() 的参数构造 pair 对象，那么会调用 pair<const Name，size_t> 对象的移动构造函数。

成员函数 emplace() 和 insert() 返回的 pair 对象提供的指示相同。pair 的成员变量 first 是一个指向插入元素或阻止插入的元素的迭代器；成员变量 second 是个布尔值，如果元素插入成功，second 就为 true。

map 的成员函数 emplace_hint() 和 emplace() 生成元素的方式在本质上是一样的，除了必须为前者提供一个指示元素生成位置的迭代器，作为 emplace_hint() 的第一个参数。例如：

    std::map<Name, size_t> people;
    auto pr = people.emplace(Name{"Dan","Druff"}, 77);
    auto iter = people.emplace_hint (pr.first, Name {"Cal","Cutta"}, 62);

这里，emplace_hint() 调用使用一个迭代器作为指示符，指向先前 emplace() 调用返回的 pair 对象。如果容器使用这个提示符，那么新元素会在这个指示符表示的位置之前生成，并尽可能靠近这个位置。提示符后面的参数用来构造新元素。需要注意的是，它和 emplace() 的返回值是不一样的。emplace_hint() 的返回值不是一个 pair 对象，如果新元素被插入，它返回的是指向新元素的迭代器；如果没有插入，返回的是和这个键匹配的现有元素的迭代器，拥有相同的 key 值，如果不是现有元素的话。没有提示可以直接判断是否生成了新元素。唯一的方法是，用 size() 成员函数来获取 map 中对应元素的数量来检查 map 元素增加的数量。例如：

    auto pr = people.emplace(Name{"Dan", "Druff"}, 77);
    auto count = people.size ();
    auto iter = people.emplace_hint (pr.first, Name {"Cal", "Cutta"}, 62);
    if(count < people.size ()) std::cout <<"Success!\n";

只有当调用 emplace_hint() 后，people 中的元素增加时，才会显示这些信息。
###获取元素
我们已经知道，可以获取 map 容器的开始和结束迭代器以及反向迭代器，它们都可以访问容器中的所有元素。map 的成员函数 at() 返回的是参数键对应的对象。如果这个键不存在，就会拋出 out_of_range 异常。下面展示如何使用这个函数：

    Name key;
    try
    {
        key = Name {"Dan”, ”Druff"};
        auto value = people.at(key);
        std:: cout << key << "is aged " << value << std:: endl;
        key = Name {"Don", "Druff"};
        value = people.at(key);
        std::cout << key << " is aged " << value << std::endl;
    }
    catch(const std::out_of_range& e)
    {
        std::cerr << e.what() << '\n'<< key << " was not found." <<std::endl;
    }

需要在 try 代码块中调用 map 的成员函数 at()，因为抛出的任何未捕获的异常都会导致程序的终止。这段代码获取了 people 容器中的两个对象，它们分别与两个 Name 键关联。如果 map 容器中的内容由执行的前一节中的代码段决定，输出效果如下：

Dan Druff is aged 77
invalid map<K, T> key
Don Druff was not found.
Try 代码块中第一次调用 at() 函数成功，结果会在首行输出。第二次调用失败，拋出了一个可捕获的 out_0f_range 异常，捕获结果在后面两行输出。异常对象的成员函数 what() 是一个返回了描述异常产生原因的字符串。当 catch 代码块中的代码执行后，try 代码块中的所有变量会被销毁，因此不再可以访问。变量 key 是在 try 代码块之前定义的，因此仍然可以在 catch 代码块中访问。

map 容器提供了以键为参数的下标运算符，它可以返回一个和键所关联对象的引用。下面是一个示例：

    auto age = people [Name {"Dan", "Druff”}];

这里获取到一个和 Name 键关联的 size_t 类型的值。注意，下标运算的使用并不是简单的检索机制。如果键不存在，元素默认的构造函数会用键和键所关联的对象生成一个新元素，如果键关联的对象是基本数据类型，它的值为 0。例如：

    auto value = people[Name {"Ned", "Kelly"}]; // Creates a new element if the key is not there

因为容器中不存在这个键，所以用它生成了新元素。关联对象的值是 0，并会返回这个值。可以用下标运算符来更新 map 中的元素，如果元素不在 map 中，也可以用它插入元素。下标运算主要用在左赋值上，用来修改已存在的元素：

    people[Name {"Ned", "Kelly”}] = 39; // Sets the value associated with the key to 39

让我们在新的示例中，用一种不同以往的方式使用 map，并且充分利用下标运算符。可以用 map 容器来确定每个字符在文本中出现的频率。确定词频是非常有用的，例如，可以用它对文档进行分类。下面展示了如何在任意文本序列中统计每个单词的出现次数：

    // Determining word frequency
    #include <iostream>                               // For standard streams
    #include <iomanip>                                // For stream manipulators
    #include <string>                                 // For string class
    #include <sstream>                                // For istringstream
    #include <algorithm>                              // For replace_if() & for_each()
    #include <map>                                    // For map container
    #include <cctype>                                 // For isalpha()
    using std::string;
    int main()
    {
        std::cout << "Enter some text and enter * to end:\n";
        string text_in {};
        std::getline(std::cin, text_in, '*');
        // Replace non-alphabetic characters by a space
        std::replace_if(std::begin(text_in), std::end(text_in), [](const char& ch){ return !isalpha(ch); }, ' ');
        std::istringstream text(text_in);             // Text input string as a stream
        std::istream_iterator<string> begin(text);    // Stream iterator
        std::istream_iterator<string> end;            // End stream iterator
        std::map<string, size_t> words;               // Map to store words & word counts
        size_t max_len {};                            // Maximum word length
        // Get the words, store in the map, and find maximum length
        std::for_each(begin, end, [&max_len, &words](const string& word)
                                {  words[word]++;
                                   max_len = std::max(max_len, word.length());
                                });
        size_t per_line {4}, count {};
        for(const auto& w : words)
        {
            std::cout << std::left << std::setw(max_len + 1) << w.first << std::setw(3) << std::right << w.second << "  ";
            if(++count % per_line == 0)  std::cout << std::endl;
        }
        std::cout << std::endl;
    }

从标准输入流读取到 text_in 中的文本是通过函数 getline() 得到的字符串。replace_if() 算法用空格替换了输入中的所有非字母字符。replace_if() 函数的前两个参数是定义元素范围的迭代器，这里的元素范围就是输入字符串的字符。下一个参数是一个函数对象，当元素需要被替换时，它返回 true；这里是一个 lambda 表达式。最后一个参数是用来替换的元素，在这个示例中这个元素是空格。这个函数会替换掉所有的标点，所以最后每个元素都是用空格分隔的。

我们用 text_in 生成一个 istringstream 对象 text。istringstream 对象允许对它封装的字符串进行流输入操作，因此可以把它当作一个流。这也包括从 text 获得流迭代器的能力，然后可以在 for_each() 中用它们提取单个单词。输入流的迭代器会陆续指向每个输入的字符串。这里输入的单词是连续的，因此开始和结束迭代器指定的范围是 text 中的所有单词。

for_each() 会将第 3 个参数指定的函数对象运用到前两个参数所指定范围内的元素上。函数对象必须以迭代器指向对象类型的引用作为参数，所以这里参数是 const string &。lambda 以引用的方式捕获变量 max_len 和 words，所以它们都可以修改。lambda 通过将每个单词作为下标来将它们以键的方式保存在容器中，并增加单词关联的值。如果单词不在容器中，会以这个单词为键(值为 1)来生成一个新的元素。如果单词先前就被添加到容器中，就自动增加值。因此与每个单词的关联值就是它在文本中累计出现的次数。为了保存最长字符串的长度，lambda 表达式也会更新 max_len。后面的输出中会用到这个值。

因而调用 for_each() 会将输入的所有单词都插入到这个 map 容器中，并且累加计算出每个单词的出现次数，计算出最大单词的长度，一条语句就实现了上面这些功能。

下面是程序输出的结果：

Enter some text and enter * to end:
How much wood would a wood chuck chuck,
If a woodchuck could chuck wood?
A woodchuck would chuck as much wood as a woodchuck could chuck if a woodchuck could chuck wood.
*
A         1  How    1 If                 1 a          4
as        2 chuck  6 could           3 if          1
much   2 wood   5 woodchuck 4 would   2
在这个示例中，map 容器中保存的是整型对象，所以可以对容器的下标运算符返回的值运用自增运算符。当 map 的下标运算符返回的值是类类型的对象时，也可以对它们使用运算符，只要这个类实现了对应的运算符。为了说明我们所讨论的这种情况，下面创建另一个示例。

假设我们要通过人名来保存并检索名人名言。显然，一个名人会有很多名言，因此我们需要通过单个键来保存多个名言。我们不能在 map 容器中保存重复的键，但是可以将键关联到封装了多个名言的对象上。我们可以用前面章节中的Name类作为键，然后定义 Quotations 类用来保存指定名人的所有名言。

我们知道，可以用键的下标运算符来访问和键关联的对象，因此可以通过扩展 Quotations 类的成员函数 operator[]() 来实现这个功能。为了方便向 Quotation 类中添加名言，我们还在类中实现了 operator<<0。我们可以方便地将名言保存在 vector 容器中。下面就是定义了这个类的 Quotations.h 头文件的内容：

    #ifndef QUOTATIONS_H
    #define QUOTATIONS_H
    #include <vector>                                          // For vector container
    #include <string>                                          // For string class
    #include <exception>                                       // For out_of_range exception
    class Quotations
    {
    private:
        std::vector<std::string> quotes; // Container for the quotations
    public:
        // Stores a new quotation that is created from a string literal
        Quotations& operator<<(const char* quote)
        {
            quotes.emplace_back(quote);
            return *this;
        }
        // Copies a new quotation in the vector from a string object
        Quotations& operator<<(const std::string& quote)
        {
            quotes.push_back(quote);
            return *this;
        }
        // Moves a quotation into the vector
        Quotations& operator<<(std::string&& quote)
        {
            quotes.push_back(std::move(quote));
            return *this;
        }
        // Returns a quotation for an index
        std::string& operator[](size_t index)
        {
            if(index < quotes.size())
                return quotes[index];
            else
                throw std::out_of_range {"Invalid index to quotations."};
        }
        size_t size() const// Returns the number of quotations
        {
            return quotes.size();
        }
        // Returns the begin iterator for the quotations
        std::vector<std::string>::iterator begin()
        {
            return std::begin(quotes);
        }
        // Returns the const begin iterator for the quotations
        std::vector<std::string>::const_iterator begin() const
        {
            return std::begin(quotes);
        }
        // Returns the end iterator for the quotations
        std::vector<std::string>::iterator end()
        {
            return std::end(quotes);
        }
        // Returns the const end iterator for the quotations
        std::vector<std::string>::const_iterator end() const
        {
            return std::end(quotes);
        }
    };
    #endif

这里用 << 运算符来添加名言是合理的，它可以在其他一些场景下使用，例如输入流。这里也可以用 += 运算符来代替。这个类定义了 3 个版本的 operator<<()，提供了不同的方式去添加名言。第一个版本接收一个字符串常量参数，然后把它传给 vector 的成员函数 emplace_back()，emplace__back() 会调用 string 的构造函数以在适当的位置生成元素。第二个版本只有一个参数，它是 string 对象的引用，这个参数会被传给 vector 的成员函数 push_back()。第三个版本有一个右值引用参数。当在函数体中通过名称使用右值引用时，它会变成左值，因此必须使用 move() 函数将它变为右值，然后把它传给 vector 的成员函数 push_back()。这会保证对象总是移动传值，而不是复制传值。

类的成员函数 []() 可以通过索引来访问成员元素。当索引不在范围内时，这个函数将抛出一个异常，这种情况不应该发生；如果真的发生，这会是程序中的一个 bug。

在 vector 容器中，begin() 和 end() 返回指向名言的迭代器。需要注意的是，返回类型是指定的。提供迭代器的容器通常会定义一个迭代器成员变量，作为它们支持的迭代器类型的别名，所以不需要知道类型的具体细节。类对象定义的迭代器可以结合 for 循环使用，但要求迭代器至少是正向迭代器。

在 Quotations 类中也定义了 const 版本的 begin() 和 end()，它们的返回值都是 const 类型的迭代器。这个返回类型有一个别名，定义在 vector 模板中。如果没有定义 const 版的 begin() 和 end() 函数，就不能在 for 循环中使用 const 类型的循环变量，例如：

    for (const auto& pr : quotations)//Requires const iterators
        ...

可以在 main() 中定义两个内联辅助函数。第一个用来从 cin 读入 name:

    inline Name get_name()
    {
        Name name {};
        std: :cout << "Enter first name and second name: ";
        std::cin >>std::ws >> name;
        return name;
    }

这里读取的 name 用来作为名和姓。控制符 ws 用来消除空格，因此会跳过 cin 中剩下的字符。 第二个辅助函数用来读取名言：

    inline string get_quote(const Name& name)
    {
        std::cout << "Enter the quotation for " << name << ".Enter * to end: \n";
        string quote;
        std::getline(std::cin >> std::ws, quote, '*');
        return quote;
    }

可以输入多行文本，然后用 * 号终止输入。下面的程序支持保存名言：

    // Stores one or more quotations for a name in a map
    #include <iostream>                              // For standard streams
    #include <cctype>                                // For toupper()
    #include <map>                                   // For map containers
    #include <string>                                // For string class
    #include "Quotations.h"
    #include "Name.h"
    using std::string;
    // Read a name from standard input
    inline Name get_name()
    {
        Name name {};
        std::cout << "Enter first name and second name: ";
        std::cin >> std::ws >> name;
        return name;
    }
    // Read a quotation from standard input
    inline string get_quote(const Name& name)
    {
        std::cout << "Enter the quotation for " << name
        << ". Enter * to end:\n";
        string quote;
        std::getline(std::cin >> std::ws, quote, '*');
        return quote;
    }
    int main()
    {
        std::map<Name, Quotations> quotations;         // Container for name/quotes pairs
        std::cout << "Enter 'A' to add a quote."
        "\nEnter 'L' to list all quotes."
        "\nEnter 'G' to get a quote."
        "\nEnter 'Q' to end.\n";
        Name name {};                                  // Stores a name
        string quote {};                               // Stores a quotation
        char  command {};                              // Stores a command
        while(command != 'Q')
        {
            std::cout << "\nEnter command: ";
            std::cin >> command;
            command = static_cast<char>(std::toupper(command));
            switch(command)
            {
                case 'Q':
                    break;                                     // Quit operations
                case 'A':
                    name = get_name();
                    quote = get_quote(name);
                    quotations[name] << quote;
                    break;
                case 'G':
                {
                    name = get_name();
                    const auto& quotes = quotations[name];
                    size_t count = quotes.size();
                    if(!count)
                    {
                        std::cout << "There are no quotes recorded for "<< name << std::endl;
                        continue;
                    }
                    size_t index {};
                    if(count > 1)
                    {
                        std::cout << "There are " << count << " quotes for " << name << ".\n"<< "Enter an index from 0 to " << count - 1 << ": ";
                        std::cin >> index;
                    }
                    std::cout << quotations[name][index] << std::endl;
                }
                break;
                case 'L':
                if(quotations.empty())                                         // Test for no pairs
                {
                    std::cout << "\nNo quotations recorded for anyone." << std::endl;
                }
                // List all quotations
                for(const auto& pr : quotations)                               // Iterate over pairs
                {
                    std::cout << '\n' << pr.first << std::endl;
                    for(const auto& quote : pr.second)                           // Iterate over quotations
                    {
                        std::cout << "  " << quote << std::endl;
                    }
                }
                break;
                default:
                    std::cout << " Command must be 'A', 'G', 'L', or 'Q'. Try again.\n";
                    continue;
                    break;
            }
        }
    }

quotations 容器保存的是 pair<constName, Quotations> 对象类型的元素。像 quotations[name] 这种表达式可以引用 Name 对象 name 关联的对象。如果在 map 中不存在和键值 name 关联的 pair 对象，就用默认关联的 Quotations 对象生成一个 pair 对象，默认的 Quotations 对象为空。下面的语句会为 name 保存一条新的名言 quote:

    quotations[name] << quote;

<< 左边的操作数等同于 quotations.operator[](name)，它返回一个和 name 关联的 Quotations 对象，因此这条语句等价于：

    quotations.operator[](name).operator<<(quote);

在 main() 函数中可以看到，我们利用表达式 quotations[name][index] 来得到一条名言，它等价于 quotations.operator[](name).operator[](index)，你应该知道 main() 剩下的代码是如何工作的，下面就是一些示例输出：

Enter 'A' to add a quote.
Enter 'L' to list all quotes.
Enter 'G' to get a quote.
Enter 'Q' to end.

Enter command: a
Enter first name and second name: Winston Churchill
Enter the quotation for Winston Churchill. Enter * to end:
There are a terrible lot of lies going around the world, and the worst of it is half of them are true.*

Enter command: a
Enter first name and second name: Dorothy Parker
Enter the quotation for Dorothy Parker. Enter * to end:
Beauty is only skin deep,but ugly goes clean to the bone.*

Enter command: a
Enter first name and second name: Winston Churchill
Enter the quotation for Winston Churchill. Enter * to end:
Never in the field of human conflict was so much owed by so many to so few.*

Enter command: a
Enter first name and second name: Winston Churchill
Enter the quotation for Winston Churchill. Enter * to end:
Courage is what it takes to stand up and speakm,Courage is also what it takes to sit down and listen.*

Enter command: a
Enter first name and second name: Dorothy Parker
Enter the quotation for Dorothy Parker. Enter * to end:
Money cannot buy health,but I'd settle for a diamond-studded wheelchair.*

Enter command: g
Enter first name and second name: Winston Churchill
There are 3 quotes for Winston Churchill.
Enter an index from 0 to 2: 1
Never in the field of human conflict was so much owed by so many to so few.

Enter command: L

Winston Churchill
  There are a terrible lot of lies going around the world, and the worst of it is half of them are true.
  Never in the field of human conflict was so much owed by so many to so few.
  Courage is what it takes to stand up and speakm,Courage is also what it takes to sit down and listen.

Dorothy Parker
  Beauty is only skin deep,but ugly goes clean to the bone.
  Money cannot buy health,but I'd settle for a diamond-studded wheelchair.

Enter command: q
显然，这个程序可以有更好的容错能力，也可以支持忽略大小的键值比较，这取决于你的想法。

map 容器的成员函数 fmd() 可以返回一个元素的迭代器，这个元素的键值和参数匹配。例如：

    std::map<std::string, size_t> people {{"Fred", 45}, {"Joan", 33}, {"Jill", 22}};
    std::string name{"Joan"};
    auto iter = people.find(name);
    if(iter == std::end(people))
        std:: cout <<"Not found.\n";
    else
        std:: cout << name << " is ""<< iter->second << std::endl;

如果没有和参数匹配的元素，find()函数会返回容器的结束迭代器，因此在使用这个迭代器之前，必须先对它进行检查。

为了兼容 multimap，map 容器包含了成员函数 equal_range(}、upper_bound()和 lower_ bound()，因为这些函数会用来查找具有相同键的多个元素。稍后在 multimap 容器这一节中对它们进行深入讲解。
###删除元素erase
map 的成员函数 erase() 可以移除键和参数匹配的元素，然后返回所移除元素的个数，例如：

    std::map<std::string, size_t> people {{ "Fred", 45}, {"Joan", 33},{"Jill", 22}};
    std::string name{"Joan"};
    if(people.erase(name))
        std::cout << name << " was removed." << std::endl;
    else
        std::cout << name << " was not found" << std::endl;

显然，map 容器的返回值只可能是 0 或 1，0 表明元素不在容器中。也可以用指向删除元素的迭代器作为 erase() 的参数。这种情况下，返回的迭代器指向被删除元素的下一个位置。这个参数必须是容器中的有效迭代器，不能是结束迭代器。如果迭代器参数指向的是容器的最后一个元素，那么会返回结束迭代器。例如：

    auto iter = people.erase(std::begin(people));
    if(iter == std::end(people))
        std::cout << "The last element was removed."<< std::endl;
    else
        std::cout << "The element preceding " << iter->first << "was removed." << std::endl;

当最后一个元素被移除时，这段代码会输出一条消息或被移除元素后面元素的键。也有更高级版本的 erase()，它可以移除两个迭代器参数所定义范围内的元素，例如：

    auto iter = people.erase(++std::begin(people), --std::end(people));//Erase all except 1st & last

返回的迭代器指向这段元素中最后一个被删除的元素。如果想删除容器中的所有元素，可以调用成员函数 clear()。

##pair和tuple
###pair
我们已经知道 pair<const K, T> 对象是如何封装键及其关联的对象，也了解了 pair<const K, T> 对象是如何表示map容器中的元素的。一般来说，pair 对象可以封装任意类型的对象，可以生成任何想生成的 pair<T1,T2> 对象，可以是数组对象或者包含 pair<T1,T2> 的 vector 容器。例如，pair 可以封装两个序列容器或两个序列容器的指针。pair<T1，T2> 模板定义在 utility 头文件中，如果不想使用 map 而只想使用 pair 对象，可以包含这个头文件。
pair 的操作
考虑到 pair 是一个比较简单的模板类型，它只有两个 public 数据成员 first 和 second。令人惊讶的是，它却可以构造各种不同的 pair<T1，T2>。我们已经知道如何使用 first 和 second 来创建对象。

和右值引用参数一样，pair 也有很多版本的引用参数，而且有一些版本的右值引用参数允许参数隐式转换为所需的类型。例如，下面有 4 种不同的方式来创建一个 pair 对象：

    std::string s1 {"test”}, s2{"that"};
    std::pair<std::string, std::string> my_pair{s1, s2};
    std::pair<std::string, std::string> your_pair{std::string {"test"},std::string {"that"}};
    std::pair<std::string, std::string> his_pair{"test", std::string {"that"}};
    std::pair<std::string, std::string> her_pair{"test", "that"};

第一个 pair 构造函数复制了所有参数的值，第二个移动参数值，第三个为了隐式转换而将第一个参数传给 string 的构造函数，最后一个构造函数将两个参数隐式转换为 string 对象而且它们会被移到 pair 的成员变量 first 和 second 中。由于这个构造函数有右值引用参数版本，因此任意一个或两个模板类型参数可以是 unique_ptr<T>。

make_pair<T1，T2> 函数模板是一个辅助函数，可以生成并返回一个 pair<T1，T2> 对象。 可以如下所示生成先前代码块中的 pair 对象：

    auto my_pair = std::make_pair(s1, s2);
    auto your_pair = std::make_pair(std::string {"test"},std::string {"that"});
    auto his_pair = std::make_pair<std::string, std::string>("test",std::string {"that"});
    auto her_pair = std::make_pair<std::string, std::string>("test", "that");

前两条语句中的函数模板的类型参数由编译器推断。在最后两条语句中，类型是明确的。如果在最后两条语句中忽略模板类型参数，那么对象类型将是 pair<const char*，string> 和 pair<const char*, const char*>。

pair 对象也可以复制或移动构造它的成员变量。例如：

    std::pair<std::string, std:: string> new_pair{my_pair}; // Copy constructor
    std::pair<std::string, std::string>
        old_pair{std::make_pair(std::string{"his"},std::string{"hers"})};

old_pair 是由 pair<string,string> 类的移动构造函数生成的。

另一个 pair 构造函数使用了 C++11 引入的这种机制，它允许通过在适当的位置生成 first 和 second 对象来构建 pair<T1, T2>。T1 和 T2 的构造函数的参数作为 tuple 参数传给 pair 的构造函数。下一节会介绍如何使用 tuple 对象。下面是一个使用 pair 对象的示例：

    std::pair<Name, Name> couple{std::piecewise_construct, std:: forward_as_tuple ("Jack","Jones") , std:: forward_as_tuple ("Jill", "Smith")};

这里，pair 构造函数的第一个参数是一个定义在 utility 头文件中的 piecewise_construct 类型的实例，这是一个用来作为标签或标记的空类型。这个 piecewise_constmct 参数唯一的作用是区分这个构造函数的调用和有两个 tuple 参数的构造函数调用之间的区别，后者的两个参数通常用来作为 pair 成员变量 first 和 second 的值。

这里，构造函数的第二和第三个参数指定了构造 first 和 second 对象的参数集，forward_as_tuple() 是一个定义在 tuple 头文件中的函数模板。这里用它的转发参数生成了一个 tuple 引用。不会经常用到这种 pair 的构造函数，但它为不支持拷贝或移动运算的 T1 和 T2 类型提供了在适当位置生成 pair<T1,T2> 对象的独特能力。

注意，如果参数是一个临时对象，forward_as_tuple() 函数会生成一个右值引用的 tuple。 例如：

    int a {1}, b {2};
    const auto& c = std::forward_as_tuple(a,b);

这里 c 的类型是 tuple<int&,int&>，因此成员变量是引用。但是假设这样写声明的话：

    const auto& c = std::forward_as_tuple(1,2);

这里 c 的类型是 tuple<int &,int&>，成员变量作为值引用。
如果成员变量可以被复制和移动，pair 对象就支持复制和移动赋值。例如：

    std::pair<std::string, std::string> old_pair; // Default constructor
    std::pair<std::string, std::string> new_pair {std::string{"his"} , std::string{"hers"}};
    old_pair = new_pair; // Copy assignment
    new_pair = pair<std::string, std::string>
    {std::string{"these"}, std::string{"those"}}; // Move assignment

默认的 pair 构造函数会用它的成员变量，即空的 string 对象来生成 old_pair 这是一个空的字符串对象。第 3 条语句一个成员一个成员地将 new_pair 复制到 old_pair 中。第 4 条语句将作为赋值运算符的右操作数的 pair 对象的成员变量移到 new_pair 中。

当 pair 对象包含不同类型的成员变量时，也可以将一个 pair 对象赋值给另一个 pair 对象，只要作为右操作数的 pair 对象的成员变量可以隐式转换为左操作数的 pair 对象的成员变量的类型。例如：

    auto prl = std::make_pair ("these", "those"); // Type pair<const char*, const char*>
    std::pair<std::string, std::string> pr2; // Type pair<string, string>
    pr2 = prl; // OK in this case

prl 成员变量 first 和 second 的类型是 const char*。这个类型可以隐式转换为 string，即 pr2 成员变量的类型，因此可以成功赋值。如果这些类型不能隐式转换，这条赋值语句就无法通过编译。

pair 对象有全套的运算符 ==、!=、<、<=、>、>=。这些运算符都可以正常使用，作为操作数的 pair 对象的类型必须是相同的，它们的成员变量的比较方式也必须相同。相等运算符返回 true，如果左右操作数的成员变量相等的话：

    std::pair<std::string, std::string> new_pair;
    new_pair.first = "his";
    new_pair.second = "hers";
    if (new_pair == std::pair<std::string, std::string> {"his", ,"hers"})
        std::cout << "Equality!\n";

new_pair 的成员变量 first 和 second 被赋值为右操作数所包含的字符串。如果 pair 对象是相等的，if 语句会输出一些消息。当两个 pair 对象中的任何一个或两个成员不相等时，!= 比较会返回 true。

对于小于或大于比较，pair 对象的成员变量是按字典顺序比较的。如果 new_pair.first 小于 old_pair.first 的话，表达式 new_pair<old_pair 会返回 true。如果它们的成员变量 first 相等，但  new_pair.second 小于 old_pair.second，new_pair < old_pair 也为 true。下面是一个 示例：

    std::pair<int, int> p1 {10, 9};
    std::pair<int, int> p2 {10, 11};
    std::pair<int, int> p3 {11, 9};
    std::cout<<std::boolalpha << (p1 < p2) <<" "<<(pi > p3) << " "<< (p3 > p2) << std::endl;

第一个比较的结果为 true，因为 p1 和 p2 的成员变量 first 相等，p1 的成员变量 second 小于 p2 的成员变量 second。
第二个比较的结果为 false，因为 p1 的 first 小于 p3 的 first。 第三个比较的结果则为 true，因为 p3 的 first 大于 p2 的 first。

pair 的成员函数 swap() 可以和作为参数传入的另一个 pair 对象交换其成员变量 first 和 second。显然，参数必须是相同类型。下面有一个示例：

    std::pair<int, int> p1 {10, 11};
    std::pair<int, int> p2 {11, 9};
    p1.swap(p2); // p1={ll,9} p2={10/11}

如果执行两次 swap()，对象恢复成原来的值。

###tuple
tuple<> 模板是 pair 模板的泛化，但允许定义 tuple 模板的实例，可以封装不同类型的任意数量的对象，因此 tuple 实例可以有任意数量的模板类型参数。tuple 模板定义在 tuple 头文件中。

tuple 这个术语也适用于很多其他的场景，例如数据库，这里一个 tuple 就是由一些类型的不同数据项组成的，这和 tuple 的概念相似。tuple 对象有很多用途。当需要将多个对象当作一个对象传给函数时，tuple 类型是很有用的。
tuple 的操作
生成 tuple 对象的最简单方式是使用定义在 tuple 头文件中的辅助函数 make_tuple()。这个函数可以接受不同类型的任意个数的参数，返回的 tuple 的类型由参数的类型决定。例如：

    auto my_tuple = std::make_tuple (Name{"Peter”，"Piper"},42,std::string{"914 626 7890"})；

my_tuple 对象是 tuple<Name，int，string> 类型，因为模板类型参数是由 make_tuple() 函数的参数推导出来的。如果提供给 make_tuple() 的第三个参数是一个字符串常量，my_tuple 的类型将是 tuple<Name,int,const*>，这和之前的不同。

tuple 对象的构造函数提供了可能会用到的每一种选择。例如：

    std::tuple<std::string, size_t> my_tl;//Default initialization
    std:: tuple<Name, std::string> my_t2 {Name {"Andy", "Capp"},std::string{“Programmer”}};
    std::tuple<Name,std::string> copy_my_t2{my_t2}; // Copy constructor
    std::tuple<std::string, std::string> my_t3 {"this", "that"};
    // Implicit conversion

tuple 中的对象由默认构造函数用默认值初始化。为 my_t2 调用的构造函数将参数移到 tuple 的元素中。下一条语句会调用拷贝构造函数来生成 tuple，在最后一个构造函数调用中，将参数隐式转换为 string 类型并生成了一个 tuple 元素。

也可以用 pair 对象构造 tuple 对象，pair 可以是左值，也可以是右值。显然，tuple 只能有两个元素。下面有两个示例：

    auto the_pair = std::make_pair("these","those");
    std::tuple<std::string, std::string> my_t4 {the_pair}; std::tuple<std::string, std::string> my_t5 {std::pair <std::string, std::string > { "this", "that"}};

第二条语句从 the_pair 生成了一个 tuple，它是一个左值。the_pair 的成员变量 first 和 second 可以隐式转换为这个 tuple 中的元素的类型。最后一条语句从右值 pair 对象生成了一个 tuple。

可以用任何比较运算符来比较相同类型的 tuple 对象。tuple 对象中的元素是按照字典顺序比较的。例如：

    std::cout << std::boolalpha << (my_t4 < my_t5) << std::endl;

tuple 对象中的元素是依次比较的，第一个不同的元素决定了比较结果。my_t4 的第一个元素小于 my_t5 的第一个元素，因此比较结果为 true。如果是相等比较，任何一对不相等的对应元素都会使比较结果为 false。

tuple 对象的成员函数 swap() 可以将它的元素和参数交换。参数的类型必须和 tuple 对象的类型一致。例如：

    my_t4.swap (my_t5);

通过调用成员函数 swap() 来交换 my_t4 和 my_t5 对应的元素。显然，tuple 中所有元素的类型都必须是可交换的，tuple 头文件中定义了一个全局的 swap() 函数，它能够以相同的方式交换两个 tuple 对象的元素。

因为 tuple 是 pair 的泛化，所以它的工作方式不同。pair 的对象个数是固定的，因此它们有成员名。tuple 中的对象数目是不固定的，所以访问它们的机制必须能够满足这种情况。函数模板 get<>() 可以返回 tuple 中的一个元素。第一个模板类型参数是 size_t 类型值，它 是 tuple 中元素的索引，因此 0 会选择 tuple 中的第一个元素，1 会选择第二个元素，以此类推。get<>() 模板剩下的类型参数是和 tuple 的参数同样推导的。下面是一个使用 get<>() 和索引来获取元素的示例：

    auto my_tuple = std::make_tuple (Name {"Peter","Piper"}, 42, std::string {"914 626 7890"});
    std::cout << std::get<0>(my_tuple)<< "age = "<<std::get<1>(my_tuple)<< " tel: " << std::get<2>(my_tuple) << std::endl;

在输出语句中第一次调用 get<>() 时返回了 my_tuple 中第一个元素的引用，它是一个 Name 对象，第二次调用 get<>() 时返回了下一个元素的引用，它是一个整数；第三次调用 get<>() 时返回了第三个元素的引用，它是一个 string 对象。因此输出结果是：

    Peter Piper age = 42 tel: 914 626 7890

也可以用基于类型的 get<>() 从 tuple 获取元素，但要求 tuple 中只有一个这种类型的元素。例如：

    auto my_tuple = std::make_tuple(Name{"Peter", "Piper"}, 42, std::string {"914 626 7890"});
    std::cout << std::get<Name>(my_tuple)<<" age = " << std::get<int> (my_tuple)<< " tel: " <<std::get<std::string>(my_tuple) << std::endl;

如果 tuple 中包含的 get<>() 类型参数值的元素不止一个，代码就无法编译通过。这里 tuple 的全部 3 个成员为不同类型，所以可以正常使用。

全局的 tie<>() 函数模板定义在 tuple 头文件中，它提供了另一种访问 tuple 元素的方式。这个函数可以把 tuple 中的元素值转换为可以绑定到 tie<>() 的左值集合。tie<>() 的模板类型参数是从函数参数中推导的。例如：

    auto my_tuple = std::make_tuple(Name{"Peter","Piper"}, 42, std::string{"914 626 7890"});
    Name name{};
    size_t age{};
    std::string phone{};
    std::tie(name, age, phone) = my_tuple;

在最后一条语句中，赋值运算符的左操作数表达式会返回一个参数的 tuple 引用。因此，赋值运算符左右的操作数都是 tuple 对象，并且用 my_tuple 中的元素值来对 tie() 参数中的变量赋值。我们可能并不想存储每一个元素的值。下面展示了如何只保存 my_tuple 中 name 和 phone 的值：

    std::tie(name, std::ignore,phone) = my_tuple;

ignore 定义在 tuple 中，它被用来标记 tie() 函数中要被忽略的值。tuple 中被忽略的元素的值将不会被记录下来。在这个示例中只复制了第一个和第三个元素。

也可以用 tie() 函数来实现对类的数据成员的字典比较。例如，可以在 Name 类中实现 operator<() 函数：

    bool Name::operator<(const Name& name) const
    {
        return std::tie(second, first) < std::tie(name.second, name.first);
    }

在这个函数体中，调用 tie() 得到的 tuple 对象的元素是按顺序比较的。用 < 运算符来比较连续的元素对，出现的第一对不同值会决定比较的结果；这个表达式的比较结果就是不同元素的比较结果。如果全部元素都相等或等价，那么结果为 false。
 

##multimap
multimap 容器保存的是有序的键/值对，但它可以保存重复的元素。multimap 中会出现具有相同键的元素序列，它们会被添加到容器中。multimap 和 map 有相同范围的构造函数，默认的比较键的函数是 less<K>()。

multimap 大部分成员函数的使用方式和 map 相同。因为重复键的原因，multimap 有一些函数的使用方式和 map 有一些区别。接下来介绍 multimap 和 map 容器不同的那些成员函数的用法。

###插入元素
multimap 容器的成员函数 insert() 可以插入一个或多个元素，而且插入总是成功。这个函数有很多的版本都可以插入单个元素，它们都会返回一个指向插入元素的迭代器。下面有一个示例，假设我们已经使用了声明 using std::string：
```
std::multimap<string, string〉 pets; // Element is pair{pet_type, pet_name}
auto iter = pets.insert (std::pair<string, string>{string{"dog"}, string{"Fang"}});
iter = pets.insert(iter, std::make_pair("dog", "Spot")); // Insert Spot before Fang
pets.insert(std::make_pair("dog", "Rover"));// Inserts Rover after Fang
pets.insert (std::make_pair ("cat", "Korky"));// Inserts Korky before all dogs
pets.insert ({{ "rat", "Roland"}, {"pig", "Pinky" }, {"pig", "Perky"}});//Inserts list elements
```

第三条语句的第一个参数是一个作为提示符的迭代器，它说明了元素应该被插入的位置。元素会被立即插入到 iter 所指向元素的前面，因此，这使我们可以覆盖默认的插入位置。对于默认的插入位置来说，元素会被插入到先前插入的键为 "dog" 的元素的后面。元素默认是按照键的升序插入的。如果没有用提示符改变插入位置，有相同键的元素的位置和插入位置相同。最后一条语句插入了一些初始化列表中的元素。有高级版本的 insert()，它可以接收两个迭代器参数，用来指定插入元素的范围。

和 map —样，multimap 的成员函数 emplace() 可以在容器的适当位置构造元素。在插入具有相同键的元素时，可以使用 multimap 的成员函数 emplace_hint()，可以通过为这个函数提供一个迭代器形式的提示符来控制元素的生成位置：
```
auto iter = pets.emplace("rabbit”,"Flopsy");
iter = pets.emplace_hint (iter, "rabbit", "Mopsy");// Create preceding Flopsy
```
这两个函数都返回一个指向插入元素的迭代器。emplace_hint() 函数尽可能近地在第一个参数所指向位置的前面生成一个新元素。如果只使用 emplace() 来插入 "Mopsy"，它可能会被插入到当前所有键为 "rabbit" 的元素的后面。

###查找元素
####查找单个元素
multimap 不支持下标运算符，因为键并不能确定一个唯一元素。和 map 相似，multimap 也不能使用 at() 函数。multimap 的成员函数 fmd() 可以返回一个键和参数匹配的元素的迭代器。例如：

    std::multimap<std::string, size_t> people {{"Ann",25},{"Bill", 46}, {"Jack", 77}, {"Jack", 32},{"Jill", 32}, {"Ann", 35} };
    std::string name {"Bill"};
    auto iter = people.find(name);
    if (iter ! = std::end (people))
        std::cout << name << " is " << iter->second << std::endl;
    iter = people.find ("Ann");
    if (iter != std::end(people))
        std::cout << iter->first << " is " << iter->second <<std::endl;

如果没有找到键，会返回一个结束迭代器，所以我们应该总是对返回值进行检查。第一个 find() 调用的参数是一个键对象，因为这个键是存在的，所以输出语句可以执行。第二个 find() 调用的参数是一个字符串常量，它说明参数不需要和键是相同的类型。对容器来说，可以用任何值或对象作为参数，只要可以用函数对象将它们和键进行比较。最后一条输出语句也可以执行，因为有等于 "Ann" 的键。事实上，这里有两个等于 "Ann" 的键，你可能也会得到不同的运行结果。

####查找等于范围元素
如果使用 multimap 容器，几乎可以肯定它会包含键重复的元素；否则，就应该使用 map。一般来说，我们想访问给定键对应的所有元素。成员函数 equal_range() 就可以做到这一点。它会返回一个封装了两个迭代器的 pair 对象，这两个迭代器所确定范围内的元素的键和参数值相等。例如：

    auto pr = people.equal_range("Ann");
    if(pr.first != std::end(people))
    {
        for (auto iter = pr.first ; iter != pr.second; ++iter)
            std:cout << iter->first << " is " << iter->second << std::endl;
    }

equal_range() 的参数可以是和键同类型的对象，或是不同类型的但可以和键比较的对象。返回的 pair 对象的成员变量 first 是一个迭代器，它指向第一个大于等于参数的元素；如果键和参数相等的元素存在的话，它是第一个键和参数相同的元素。如果键不存在，pair 的成员变量 first 就是容器的结束迭代器，所以应该总是对它们进行捡查。

pair 的成员变量 second 也是一个迭代器，它指向键值大于参数的第一个参数；如果没有这样的元素，它会是一个结束迭代器。这段代码会输出容器中键值为”Ann”的元素的一些信息。

####查找小于和大于范围元素
multimap 的成员函数 lower_bound() 会返回一个迭代器，它指向键值和参数相等或大于参数的第一个元素，或者指向结束迭代器。upper_bound() 也返回一个迭代器，它指向键值大于函数参数的第一个元素，如果这样的元素不出现的话，它就是一个结束迭代器。所以，当存在一个或多个相等键时，这些函数会返回一个开始迭代器和一个结束迭代器，它们指定了和参数匹配的元素的范围，这和 equal_range() 返回的迭代器是相同的。因而前面的代码段可以这样重写：

    auto iter1 = people.lower_bound("Ann");
    auto iter2 = people.lower_bound("Ann");
    if(iter1 != std::end(people))
    {
        for(auto iter = iterl ; iter != iter2; ++iter)
            std::cout << iter->first << " is " << iter->second << std::endl;
    }

它和前一个代码段的输出结果是相同的。通过调用 multimap 的成员函数 count() 可以知道有多少个元素的键和给定的键相同。

    auto n = people.count("Jack"); // Returns 2

可以用不同的方式使用这些函数。可以选择 find() 或 equal_range() 来访问元素。如果以班级为键，在 mutilmap 中保存学生信息，可以用成员函数 count() 来获取班级的大小。当然，通过将在前面章节介绍的 distance() 函数模板运用到成员函数 equal_range() 返回的迭代器或者 lower_bound() 和 upper_bound() 返回的迭代器上，也可以获取键和给定键相等的元素 的个数：

    std::string key{"Jack"};
    auto n = std::distance( people.lower_bound(key),people.upper_bound(key)); // No. of elements matching key

注意，全局的 equal_range()、lower_bound()、upper_bound() 函数模板的使用方式和关联容器中同名成员函数的使用方式略有不同。在教程后面的部分你会了解到这些。

###删除元素
multimap 的成员函数 erase() 有 3 个版本：

    以待删除兀素的迭代器作为参数，这个函数没有返回值；
    以一个键作为参数，它会删除容器中所有含这个键的元素，返回容器中被移除元素的个数；
    接受两个迭代器参数，它们指定了容器中的一段元素，这个范围内的所有元素都会被删除，这个函数返回的迭代器指向最后一个被删除元素的后一个位置。


下面在示例中尝试一些multimap操作：

    // Using a multimap
    #include <iostream>                                        // For standard streams
    #include <string>                                          // For string class
    #include <map>                                             // For multimap container
    #include <cctype>                                          // For toupper()
    using std::string;
    using Pet_type = string;
    using Pet_name = string;
    int main()
    {
        std::multimap<Pet_type, Pet_name> pets;
        Pet_type type {};
        Pet_name name {};
        char more {'Y'};
        while(std::toupper(more) == 'Y')
        {
            std::cout << "Enter the type of your pet and its name: ";
            std::cin >> std::ws >> type >> name;
            // Add element - duplicates will be LIFO
            auto iter = pets.lower_bound(type);
            if(iter != std::end(pets))
                pets.emplace_hint(iter, type, name);
            else
                pets.emplace(type, name);
            std::cout << "Do you want to enter another(Y or N)? ";
            std::cin >> more;
        }
        // Output all the pets
        std::cout << "\nPet list by type:\n";
        auto iter = std::begin(pets);
        while(iter != std::end(pets))
        {
            auto pr = pets.equal_range(iter->first);
            std::cout << "\nPets of type " << iter->first << " are:\n";
            for(auto p = pr.first; p != pr.second; ++p)
                std::cout << "  " << p->second;
            std::cout << std::endl;
            iter = pr.second;
        }
    }

我们在代码中使用一些类型别名将类型及其表示的事物关联了起来。pets 容器保存的是 pair<string，string> 类型的对象，这个 pair 对象以 pet 类型作为键，以 pet 的名称为对象。

代码中的第一个循环，将给定键的第二个以及随后的元素插入到这个键序列的前面。这里使用 emplace_hint() 来插入元素。如果它是给定类型的第一个元素，就调用 emplace() 在适当的位置创建元素。

在第二个 while 循环中，按照 pet 的类型分组输出元素。首先找到 iter 指向的 pet 的第一个类型，然后用 equal_range() 返回的迭代器列出这种 pet 类型的全部序列。最后将 iter 设为这个序列的结束迭代器，它也是一个指向下一个 pet 类型的迭代器，或是容器的结束迭代器。后者会结束循环。下面是一些示例输出：

Enter the type of your pet and its name: rabbit Flopsy
Do you want to enter another(Y or N)? y
Enter the type of your pet and its name: rabbit Mopsy
Do you want to enter another(Y or N)? y
Enter the type of your pet and its name: rabbit Cottontail
Do you want to enter another(Y or N)? y
Enter the type of your pet and its name: dog Rover
Do you want to enter another(Y or N)? y
Enter the type of your pet and its name: dog Spot
Do you want to enter another(Y or N)? y
Enter the type of your pet and its name: snake Slither
Do you want to enter another(Y or N)? y
Enter the type of your pet and its name: snake Sammy
Do you want to enter another(Y or N)? n

Pet list by type:

Pets of type dog are:
  Spot  Rover

Pets of type rabbit are:
  Cottontail  Mopsy  Flopsy

Pets of type snake are:
  Sammy  Slither
输出表明元素是按键的升序排列的，键相同的元素的顺序和它们输入的顺序相反。

##自定义比较函数

对于为什么要改变 map 或 multimap 的比较函数，可能想用降序排列的元素来代替默认升序排列的元素；或者键需要使用的比较函数和直接的小于或大于运算符不同。例如，如果键是指针的话，就需要使用这种函数。在看一个演示如何替代比较函数的示例之前，先强调比较键的函数对象所需要的一个非常重要的条件。

需要注意的是，map 容器的比较函数在相等时不能返回 true，换句话说，不能使用<=或>=来比较。这是为什么？ map或multimap容器用等价来判 断键是否相等。如果表达式 key1<key2 和 key2<key1 的结果都是 false，那么 key1 和 key2 是等价的，所以它们被认为是相等的。换一种方式，等价意味着 !(key1<key2)&&!(key2<key1) 的运算值为 true。

如果我们的函数对象实现了 <=，思考一下会发生什么。当 key1 和 key2 相等时，key1<=key2 和 key2<=key1 都为 true，因而表达式 !(key1<=key2)&&!(key2<=key1) 为 false，这意味着来自于容器的这两个键竟然不相等。

事实上，不会出现用相等来判断键的情况。这意味着这个容器将无法进行正常操作。让我们来看一下如何替换比较函数，从而使容器可以正常操作。
###greater<T>对象的用法
假设我们已经为先前章节中使用的 Name 类实现了 operator>()。在这个类的定义中，成员函数 operator>() 的定义如下：

    bool operator>(const Name& name) const
    {
        return second > name.second ||(second == name.second && first > name.first);
    }

当然，可以将成员函数的定义放在类的外面：

    inline Name::bool operator> (const Name& name) const
    {
        return second > name.second || (second == name.second && first > name.first);
    }

现在可以用 Name 对象作为 map 的键，将容器中的 pair 对象按降序排列：

    std::map<Name,size_t, std::greater<Name>>people{{Name{"Al", "Bedo"}, 53}, {Name{"Woody","Leave"},33},{Name{"Noah", "Lot"}, 43}};

这里第三个模板类型参数指定了用来比较键的函数对象的类型。greater<Name> 对象使用 > 运算符来比较 Name 对象，因为 Name 类实现了 operator>()，所以可以这样做。这三个元素会按照降序排列。如果列出这些元素，它们的排列方式是很明显的，可以像下面这样列出元素：

    for ( const auto& p : people)
        std:: cout << p.first << " " << p.second << " \n";

基于范围的 for 循环遍历了 people 容器中的所有元素，然后将它们输出：

Noah Lot 43
Woody Leave 33
Al Bedo 53

###用自定义的函数对象来比较元素
如果 map 或 multimap 中的键是指针的话，那么需要定义一个函数来比较它们所指向的对象，否则会比较指针所表示的地址，这并不是我们想要的。如果键是不支持直接进行 < 或 > 比较的类型，为了可以在 map 或 multimap 中使用它们，必须为它们定义一个适当的函数对象。处理这两种情况的方式在本质上相同。

假设我们想用堆上生成的对象的指针作为 map 容器的键。下面用指向 string 对象的智能指针来说明这种情况。这个容器的键可以是 unique_ptr<string> 类型，在这个示例中我们需要含两个 unique_ptr<string> 参数的比较函数，这个函数可以比较它的参数所指向的 string 对象。可以用伪函数，即函数对象来定义它，这里假设使用了 using_std::string：

    // Compares keys that are unique_ptr<string> objects
    class Key_compare
    {
    public:
        bool operator () (const std::unique_ptr<string>& p1, const std::unique_ptr <string>& p2) const
        {
            return *p1 < *p2;
        }
    };

可以用 Key_compare 类型作为 map 容器来比较键的函数对象的类型：

    std::map<std::unique_ptr<string>,std::string,Key_compare> phonebook;

第三个 map 模板参数指定了用来比较元素的函数对象的对象，因为这个类型参数指定了默认的值 less<T>，所以我们需要指定我们自己定义的函数对象。map 中的元素是 pair 对象，它封装了一个指向 string 对象的智能指针，string 对象用来保存人名和电话。对于这个 map，我们不能使用初始化列表，因为初始化列表包含了副本，而 unique_ptr 对象是不能被复制的。我们至少有两种向容器中添加元素的方式：

    Phonebook.emplace(std::make_unique<string>("Fred"), "914 626 7897");
    Phonebook.insert(std::make_pair(std::make_unique<string>("Lily"), "212 896 4337"));

第一条语句在容器的适当位置直接生成了一个 pair 对象。这个 pair 对象的构造函数可以移动这里指定的参数，所以可以无条件地复制它们。第二条语句调用了容器的成员函数 insert()，它会将参数元素移到容器中。

可以按如下所示列出 phonebook 容器中的元素：

    for (const auto& p: phonebook)
        std:: cout << *p.first << " " << p.second << std::endl;

基于范围的 for 循环遍历了 map 中的所有元素，map 中的元素都是 pair 对象。每一个 pair 对象的成员变量 first 都是 unique 指针，所以不得不通过解引用来访问它们所指向的 string 对象。如果使用迭代器来访问元素，语法略有不同：

    for (auto iter = std::begin (phonebook) ;iter != std:: end (phonebook) ; ++iter)
        std:: cout << *iter->first << " " << iter->second << std::endl;

它和之前的循环有相同的输出，但使用的是迭代器。可以用 -> 运算符来访问 pair 对象的成员。因为这样定义了伪函数 Key_compare，所以容器中的元素会被升序排列。

##hash
如果在容器中保存对象及其关联的键，并且不用键来决定 键/对象 对的顺序，那就必须对键值釆用其他方式来确定元素在内存中的位置。如果使用像 string 这样的对象作为键，就会遇到一些问题，可能的变量的数目是巨大的。具有 10 个字符的字母字符串可能的个数是 2610。这个索引范围没有多大用处。我们需要一种机制来将它变为可接受的范围；而且理想情况下，这个机制可以为每个键生成唯一的值。这也是哈希需要做的事情之一。

哈希是用给定范围的基本类型的数据项，或者用像 string 这样的对象，生成整数值的过程。哈希产生的值叫作哈希值或哈希码，它们通常被用在容器中，用来确定表中对象的位置。像前面所说的那样，理想情况下，每个对象应该产生唯一的哈希值，但这一般是不可能的。当不同键值的个数大于可能的哈希值个数时，显然就会出现上面所说的这种情况，我们早晚会得到重复的哈希值。重复的哈希值也叫作碰撞。

哈希不仅可以在容器中保存对象，它也被应用到很多其他地方，例如密码和加密数据的安全系统中，密码识别有时也包含哈希。在系统中保存明文密码是有很大风险的。保存密码的哈希值要比保存明文密码更安全，更能防范黑客。得到哈希值的黑客需要将哈希值转换为对他们有用的原始密码，而这是一个不可能完成的任务。因此STL提供的对不同类型数据哈希的能力不仅可以用在关联容器上，也可以被用在更加广阔的场景中。

虽然理解容器的哈希机制没在必要，但是这能让我们对它们能做些什么有一个基本的了解。哈希算法有很多，但却没有可以通用的。为某个场景确定合适的哈希算法并不总是简单。通常都需要对数据分割后再计算。这可能是最简单的处理键的算法了，不管什么类型的键，都会作为数值处理。所以哈希值可能是表达式k%m产生的。

显然，这种方法最多允许有 m 个不同的哈希值，值的范围为 0 到 m-1。可以很容易地看到哪里会产生重复的哈希值。值为 k+m、k+2*m 的键会有重复的哈希值，m 值的选择对于减少重复哈希值的出现至关重要，而且可以保证值是均匀分布的。如果 m 是 2 的幂，也就是 2n，哈希值的最小位为 k 的 n 位。这显然不是一个好的结果，因为 k 的大多数位都没有影响到哈希值；理想情况下，键的所有数位应该都可以影响哈希结果。m 通常是一个质数，因为它可以使哈希值更加均匀地分布在这个范围内。

另一种更好的计算哈希值的方式是选择一个常量 a，将它和 k 相乘，用 a*k 除以整数 m 来计算它的余数，然后从 (a*k)%m 的结果中选择一个长度值作为哈希值。显然 a 和 m 的选择是非常重要的。对于 32 位的计算机来说，m 通常选为 232。乘数 a 是和 m 相近的质数，这就意味着 a 和 m 除了 1 之外没有其他的公共因子。此外，a 的二进制表示中头部和尾部不能为 0，否则会和其他头部有 0 或尾部有 0 的键值产生碰撞。基于这些原因，这个算法也被叫作乘法哈希。

也有几个专门哈希字符串的算法。其中一个将字符串看作一定个数的单词，使用像乘法算法这样的方法来计算第一个单词的哈希值，然后加上下一个单词，再计算它的哈希值，重复这个过程，直到计算出所有单词最后的哈希值。
生成哈希值的函数
functional 头文件中定义了无序关联容器使用的特例化 hash<K> 模板。hash<K> 模板定义了可以从 K 类型的对象生成哈希值的函数对象的类型。hash<K> 实例的成员函数  operator()() 接受 K 类型的单个参数，然后返回 size_t 类型的哈希值。对于基本类型和指针类型，也定义了特例化的 hash<K> 模板。

hash<K> 模板专用的算法取决于实现，但是如果它们遵循 C++14 标准的话，需要满足一些具体的要求。这些要求如下：

    不能拋出异常
    对于相等的键必须产生相等的哈希值
    对于不相等的键产生碰撞的可能性必须最小接近 size_t 最大值的倒数


注意，相等键生成相等的哈希值只适用于单次执行。这也就意味着，在不同的场合允许给定的键可以生成不同的哈希值。这就使我们可以在哈希算法中使用随机数，当对密码进行哈希时，这是我们所希望使用的。注意，C++14 为了保持一致性并没有排除给定类型的键的哈希值等同于键的可能。在无序关联容器中，用哈希函数哈希整数值可能就是这种情况。

下面是一个用 hash<K> 生成整数的哈希值的示例：

    std::hash<int> hash_int;// Function object to hash int
    std::vector<int> {-5, -2, 2, 5, 10};
    std::transform(std::begin(n), std::end(n),std::ostream_iterator<size_t> (std:: cout," "),hash_int);

这里使用 transform() 算法来哈希 vector 中的元素。transform() 参数中的前两个迭代器指定了被操作元素的范围，第三个参数是一个指定输出地址的迭代器，这里是一个 ostream 迭代器，最后一个参数是应用到范围元素上的函数对象 hash<int>。某次测试的输出结果为：

554121069 2388331168 3958272823 3132668352 1833987007
在你的 C++ 编译器和库中，可能会产生不同的哈希值，所有的哈希值都是这样。下面是一个哈希浮点数值的示例：

    std::hash<double> hash_double;
    std::vector<double> x {3.14,-2.71828, 99.0, 1.61803399,6.62606957E-34};
    std::transform(std::begin(x), std::end(x),std::ostream_iterator<size_t>(std::cout," "),hash_double);

某次测试的输出结果为：

4023697370 332724328 2014146765 3488612130 3968187275
指针也很容易哈希：

    std::hash<Box*> hash_box; // Box class as in Chapter 2
    Box box{1, 2, 3};
    std:: cout << "Hash value = " << hash_box (&box)<<std::endl;    // Hash value = 2916986638

可以用相同的函数对象来哈希智能指针：

    std::hash<Box*> hash_box; // Box class as in Chapter 2
    auto upbox = std::make_unique<Box>(1A 2, 3);
    std::cout << "Hash value = " << hash_box(upbox.get())<<std::endl; // Hash value = 1143026886

这里调用 unique_ptr<Box> 对象的成员函数 get() 来获取保存自由存储区地址的原生指针，然后将它传给哈希函数。这里使用的 hash<K> 模板也是 unique_ptr<T> 和 shared_ptr<T> 对象的特例化模板。例如，可以对 unique_ptr<Box> 对象而不是对它所包含的原生指针进行哈希：

    std::hash<std::unique_ptr<Box>>hash_box; // Box class as in Chapter 2
    auto upbox = std::make_unique<Box>(1, 2, 3);
    std::cout << "Hash value = "<< hash_box (upbox)<< std::endl; // Hash value = 4291053140

原生指针和 unique_ptr 的哈希值是相同的。不要被这个误导，考虑到当一个类型的键没有具体的哈希函数时，这种对指针哈希的能力是很有用的。可以对地址进行哈希，而不是对对象自己。这和指针指向的对象无关。

如果想在无序容器中以指向键的指针为键，而不是以键为键，保存一些对象，思考一下会发生什么。指向键的指针的哈希值和原始键的哈希值有很大的不同，因为它们的地址不同，因而无法用它来检索对象。需要一种可以为使用的任何类型的键生成哈希值的方式。如果键的类型是我们所定义的，我们有一个选择，可以用 STL 提供的哈希函数来为我们定义的类的数据成员生成哈希值。

string 头文件中定义了一些特例化的 hash<K> 模板，它们会生成一些函数对象，这些函数对象生成表示字符串的对象的哈希值。有 4 个特例化的模板，它们分别对应于字符串类型：string、wstring、u16string 和 u32string。

wstring 类型的字符串包含的是 wchar_t 类型的字符；u16string 类型包含的是 charl6_t 类型的字符，它是用 UTF-16 编码的 Unicode 字符；u32string 类型包含的是 char32_t 类型的字符，它是用 UTF-32 编码的 Unicode 字符。

当然，字符类型 char、wchar_t、charl6_t 和 char32_t 都是C++14 中的基本类型。下面是一个对字符串对象进行哈希的示例:

    std::hash<std::string> hash_str;
    std::string food {"corned beef"};
    std::cout << "corned beef hash is " <<hash_str (food) <<std::endl;

这里生成了一个函数对象，它用和前面章节中示例相同的方式来哈希 string 对象。本次测试的输出结果如下：

corned beef hash is 3803755380
这里对 C 风格字符串的哈希没有具体的规定。使用 const char* 类型的 hash<T> 模板会为指针进行特例化。如果想将 C 风格的字符串当作字符序列来哈希生成哈希值，可以先用它生成一个 string 对象，然后使用函数对象 hash<string>。

代码段生成的哈希值都是非常大的数，这看起来对于确定对象在无序容器中的位置没有什么帮助。有几种方式可以用哈希值确定对象在容器中的位置。一个常见的用法是用哈希值的比特序列作为对象在表或树中的索引。
##unordered_map
###基本结构和特性
unordered_map 包含的是有唯一键的键/值对元素。容器中的元素不是有序的。元素的位置由键的哈希值确定，因而必须有一个适用于键类型的哈希函数。如果用类对象作为键，需要为它定义一个实现了哈希函数的函数对象。如果键是 STL 提供的类型，通过特例化 hash<T>，容器可以生成这种键对应的哈希函数。

因为键可以不通过搜索就访问无序 map 中的对象，所以可以很快检索出无序 map 中的元素。迭代遍历无序 map 中的元素序列的速度一般没有有序 map 快，因此在某个应用中选择何种容器取决于想如何访问容器中的元素。

unordered_map 容器中元素的组织方式和 map 有很大的不同，元素的内部组织方式取决于 C++ 实现。一般情况下，元素被保存在哈希表中，这个表中的条目被称为格子，每个格子可以包含几个元素。

一个给定的哈希值会选择特定的格子，因为哈希值可能的个数几乎可以肯定会大于格子的个数，两个不同的哈希值可能会映射到同一个格子上。因此，不同键会产生相同的哈希值，会产生碰撞，而且两个不同的哈希值选择相同的格子也会导致碰撞的产生。

下面的一些参数可以影响元素存储的管理：

* 容器中格子的个数有一个默认值，但也可以定指定初始个数。
* 载入因子是每个格子平均保存的元素的个数。这个值等于容器中元素个数除以格子的个数。

最大载入因子，默认是 1.0，但也可以修改。这是载入因子的上限。当容器达到最大载入因子时，容器会为格子分配更多的空间，这通常也会对容器中的元素重新进行哈希。

任何时候都不要将单个格子中的最大元素个数和最大载入因子混淆。假设有一个容器，它有 8 个格子，前两个格子中各有 3 个元素，剩下的格子都为空。那么这时候的载入因子为 6/8，也就是 0.75，小于默认的最大载入因子 1.0，所以这没有什么问题。

图 1 展示了 unordered_map 的基本结构图。


![图 1 unordered_map 中的数据](http://c.biancheng.net/uploads/allimg/180917/2-1P91F9413c07.jpg)

为了简单起见，图 1 中的每个格子只有一个元素。可以使用从 0 开始的索引来访问格子。

组织格子的方式有很多。一种方式是将格子看作类似 vector 的序列，然后在哈希表中保存序列的地址。另一种方式是将格子定义为链表，在哈希表中保存根节点。具体使用哪种方法取决于我们的实现。前者一个格子只能放一个元素，后者可以放多个。

unordered_map 必须能够比较元素是否相等。当容器中有相同的键时，对从包含多个元素的格子中检索到的元素进行确认和选择很有必要。容器默认会使用定义在 fimctional 头文件中的equal_to<K> 模板。它会用 == 运算符来比较元素，所以当键相等时，容器会认为它们是相同的，这一点和 map 容器不同，map 容器使用的是等价。如果使用的键是没有实现 operator=() 的类类型，那就必须提供一个函数对象来比较键。（判断相等就更新元素，不相等就在格子里追加元素）

###初始化
生成 unordered_map 容器和生成 map 一样简单，只要可以用 hash<K> 的实例哈希 k 类型的键，而且必须能够用 == 运算符来比较键。下面展示了如何定义和初始化 unordered_map：

    std::unordered_map<std::string, size_t> people {{"Jan",44}, {"Jim", 33}, {"Joe", 99}}; // Name,age

这样就生成了一个包含 pair<string，size_t> 元素的容器，并用初始化列表中的元素对它进行了初始化。容器中格子的个数是默认的，它使用 equal_to<String>() 对象来判断键是否相等。它会用定义在 string 头文件中的 hash<string> 来对 string 进行哈希。如果没有提供初始值，默认的构造函数会生成一个空容器，它有默认个数的格子。

当我们知道要在容器中保存多少个元素时，可以在构造函数中指定应该分配的格子的个数：

    std::unordered_map<std::string,size_t> people {{ { "Jan", 44}, {"Jim", 33}, {"Joe", 99}}, 10};

这个构造函数有两个参数：初始化列表和需要分配的格子数。

也可以用迭代器定义的一段 pair 对象来生成容器。显然，只要这个范围内的 pair 对象都是要求的类型，那么任何对象源都可以接受。例如：

    std::vector<std::pair<string, size_t>>folks {{ "Jan",44}, {"Jim", 33}, {"Joe", 99},{"Dan", 22},{"Ann", 55}, {"Don", 77}};
    std::unordered_map<string, size_t> neighbors {std::begin(folks), std::end(folks) , 500};

folks 是一个包含 pair<string,size_t> 类型元素的 vector 容器，然后用它的元素来填充 neighbors 容器。这里为 neighbors 分配了 500 个格子，但也可以省略这个参数，使用默认的格子个数。可以为前面的两个构造函数指定定义哈希函数的函数对象。这个函数对象会分别作为第 1 个构造函数的第 3 个参数，以及第 2 个构造函数的第 4 个参数，所以这时需要为第 2 个构造函数指定格子个数。接下来会展示如何在接收初始化列表的构造函数中指定这个参数。

假如我们想要用定义在前面章节中的 Name 对象作为键，那就必须为它定义一个哈希函数和一个恒等运算符，扩展后的类的定义如下：

    class Name
    {
    public:
        size_t hash() const { return std::hash<std::string>()(first+second); }
        bool operator==(const Name& name) const { return first == name.first && second== name.second; }
    };

在这个示例中，编译器提供的默认的 operator==() 成员函数能够满足我们的要求，但还是想自己定义。成员函数 hash() 用函数对象 hash<string>() 来哈希 Name 对象的成员 first 和 second 所拼接的字符串。

unordered_map 容器的哈希函数只能接受和键同类型的单个参数，它会返回一个 size_t 类型的哈希值。我们可以定义一个满足这些条件的函数对象的类型，这个类型的函数对象会调用 Name 对象的成员函数 hash():

    class Hash_Name {
    public:
        size_t operator()(const Name& name) const { return name.hash(); }
    };

当生成 unordered_map 容器时，可以用 Hash_Name 对象作为它的比较函数：

    std::unordered_map<Name, size_t, Hash_Name> people
    {{{{"Ann", "Ounce"}, 25}, {{"Bill", "Bao"}, 46}, {{"Jack", "Sprat"}, 77}},500,Hash_Name()}

这个容器中的元素是 pair<Name, size_t> 类型对象。它的构造函数的第一个参数是一个初始化列表，里面定义了三个这种类型的对象。注意括号是如何嵌套的。最内层的括号中包含 Name 构造函数的参数。它上面的一层包含的是 pair<Name，size_t> 构造函数的参数。

unordered_map 构造函数的第 2 个参数是格子的个数，我们必须指定它，因为我们想使用第 3 个参数，第 3 个参数是用来哈希键的函数对象。Hash_Name 类型的函数对象会作为这个容器的第 3 个模板类型参数。这么做是必要的，因为模板类型参数有一个不同于我们函数对象的类型的默认值。unordered_map 有以元素段为参数的构造函数，它的前两个参数是迭代器，第 3 个参数是格子个数，第 4 个参数是哈希函数。

当需要指定用来比较两个键对象是否相等的函数对象时，必须指定格子个数，函数对象会用键值来生成哈希值。如果我们忽略了 Name 类的成员函数 operator==()，并且假设定义了一个定义了函数对象的类类型 Name_Equal，可以按如下方式在构造函数中指定它：

    std::unordered_map<Name, size_t, Hash_Name, Name_Equal〉 people
    { { { {"Ann", "Ounce"}, 25}, {{"Bill”, "Bao"}, 46},{{"Jack","Sprat"}, 77}},500,Hash_Name(), Name_Equal()};

这里有一个额外的模板类型参数和一个额外的构造函数参数，因为参数有默认值，所以这个模板类型参数是必要的。模板参数列表中用来比较键的函数对象同样会用在以初始化列表为参数的构造函数中。

unordered_map 也有移动和拷贝构造函数。显然，可以用它们生成容器的副本，副本容器的格子个数、哈希函数都和参数容器相同。

###插入元素
unordered_map 容器的成员函数 insert() 提供的能力和 map 谷器的这个函数相同。可以通过复制或移动来插入一个元素，可以使用也可以不使用提示符来指明插入的位置。可以插入初始化列表中指定的元素或由两个迭代器指定范围内的元素。下面有一些示例，先看第一种情况：
```
std:: unordered_map<std:: string, size_t> people { {"Jim", 33}, { "Joe", 99}};// Name,age
std::cout <<"people container has " << people.bucket_count()<<" buckets.\n"; // 8 buckets
auto pr = people.insert (std::pair<string, size_t> {"Jan", 44});// Move insert
std:: cout << "Element " << (pr.second ? "was" : "was not") << " inserted." << std::endl;
```
第一条语句用两个初始元素生成了一个容器，它的格子个数是默认的。第二条语句调用 people 的成员函数 bucket_count() 来获取格子个数；注释中展示的是在笔者系统上执行代码后返回的值，但在你的系统上可能会有些不同。这个 insert() 调用是一个有右值引用参数的版本，所以 pair 对象会被移到容器中。insert函数返回了一个 pair 对象，它的成员变量 first 是一个迭代器，它指向插入的新元素；如果元素没有被插入，它指向的是【阻止插入的元素】（指明哪个元素阻止了这个元素的插入）。Pair 的成员变量 second 是一个布尔值，如果对象插入成功，它的值为 true。

看下面这些语句：
```
std::pair<std::string, size_t> Jim {"Jim", 47};
pr = people.insert(Jim);
std::cout << "\nElement " << (pr.second ? "was" : "was not") << " inserted. " << std::endl;
std::cout << pr.first->first << " is " « pr.first->second << std::endl;
// 33
```
因为参数是左值，所以会调用有 const 引用参数的 insert() 版本，如果插入成功，它会将元素复制到容器中。这个插入操作不会成功，因为容器中已经有键值为 string("Jim") 的元素，所以最后一条语句输出的年龄为 33。

    auto count = people.size();
    std::pair<std::string, size_t> person {"Joan", 33};
    auto iter = people.insert(pr.first,person);
    std::cout << "\nElement." << (people.size () > count ? "was" : "was not") << " inserted." << std::endl;

这里，insert() 的第一个参数是一个迭代器，它是上一个 insert() 调用返回的 pair 对象的成员变量 first，用来作为标识元素插入位置的指示符;容器不一定会使用这个指示符。insert 的第二个参数是待插入的元素。这个版本的 insert() 函数不会返回一个 pair 对象，但会返回一个指向插入元素或阻止插入操作的元素的迭代器。这段代码中使用容器的成员函数 size() 返回的元素个数来判断元素是否插入成功。

也可以插入初始化列表中的内容：

    people.insert({{"Bill", 21}, {"Ben", 22}});//Inserts the two elements in the list

这个版本的 insert() 不会有返回值，可以插入元素段的 insert() 版本也没有返回值：

    std::unordered_map<std::string, size_t> folks; // Empty container
    folks.insert(std::begin(people), std::end(people));// Insert copies of'all people elements

迭代器所定义的来自于 people 容器的元素和 folks 中的元素是同种类型，people 可以是任意类型的容器，只要它的元素类型符合 folks 的要求。

可以调用 unordered_map 容器的成员函数 emplace() 或 emplace_hint() 在容器的适当位置生成元素。例如：

    auto pr = people. emplace ("Sue", 64);// returns pair<iterator, bool>
    auto iter = people.emplace_hint(pr.first, "Sid", 67);// Returns iterator
    people.emplace_hint(iter, std::make_pair("Sam", 59));//Uses converting pair<string, size_t>

emplace() 可以用参数在容器的适当位置生成对象，它会返回一个包含迭代器和布尔值的 pair 对象，这和 insert() 返回的 pair 对象有同样的意义。emplace_hint() 的第一个参数是一个作为提示符的迭代器，后面的参数被用来生成元素，它返回的迭代器指向被插入元素或阻止插入的元素。

为了可以用 unordered_map 对象的内容替换这个容器的内容，unordered_map 容器实现了赋值运算符；

    folks = people; // Replace folks elements by people elements

显然，参数所包含的元素的类型必须和当前容器相同。
####调整格子个数
在维持当前载入因子的前提下，如果插入元素数超过了格子可以满足的个数，容器将不得不增加格子的个数。那么为了将元素重新分配到新的格子中，元素会被再次哈希。这时，这个容器当前存在的任何迭代器都会失效。在任何时候都可以调用成员函数 rehash() 来改变格子的个数：

    people.rehash(15); // Make bucket count 15

rehash() 的参数可以比当前格子数多或少。这条语句会将格子的个数变为 15，只要它不导致当前因子超过最大载入因子。容器中的所有元素都会被重新哈希分配到新的格子中，而且当前所有的迭代器都会失效。如果指定的格子个数导致载入因子超过最大载入因子，那么格子会自动增加来避免超出最大值。

如果确定会增加格子的个数，可以使用 bucket_count() 返回的值：

    people.rehash((5*people.bucket_count())/4); // Increase bucket count by 25%

另一种方式是增加最大载入因子，也就是增加每个格子所包含的元素个数：

    people.max_load_factor(1.2*people.max_load_factor()); // 工ncrease max load factor by 20%

为了改变最大载入因子，可以以新的最大载入因子为参数调用容器的 max_load_factor(); 如果无参数地调用这个函数，它会返回当前的最大载入因子，可以用它来设置新的值。

可以发现，调用 unordered_map 的成员函数 load_factor() 时返回的当前载入因子是一个浮点值：

    float lf = people.load_factor();

也可以选择设置格子的个数，使它们在容纳给定个数的元素的同时将负载因子维持在最大数之内：

    size_t max_element_count {100};
    people.reserve(max_element_count);

这里设置了格子的个数，使它可以容纳 100 个元素而不超过最大载入因子的限制。这会导致容器中的内容被重新哈希，从而使所有的当前迭代器失效。当然，也可以不考虑载入因子和格子个数来生成和使用 unordered_map 容器。容器自己会处理这些事情。

对于现实世界中的应用来说，性能是很重要的，而容器就是影响性能的一个重要因素。当每个格子中的元素不超过一个时，访问速度是最快的，但实际上这是不现实的，因为这需要很多内存而且会有很多的空格子。增大最大载入因子可以使每个格子容纳更多的元素，从而使格子的总数越少。所以从内存使用上来说，这是最有效率的。然而，每个格子中的元素越多，会导致访问元素的速度越慢。这需要根据每个程序的具体情况来选择。或许最重要的事是要避免反复哈希容器的内容。如果可以预估出要保存的元素的个数，就可以设定格子的个数或者设定合适的载入因子，从而减少再次哈希的可能。

###获取元素
####下标和at
对于 unordered_map，可以在下标运算符中使用键来获取它所对应对象的引用。例如：
```
people["Jim"] = 22; //Set Jim's age to 22;
people["May"] = people["Jim"]; //Set May's age to Jim's
++people ["Joe"] ; //Increment Joe's age
people ["Kit"] = people ["Joe"]; // Set Kit's age to Joe's
```
这和 map 容器的操作是一样的。在下标中使用不存在的键时，会以这个键为新键生成一个新的元素，新元素中对象的值是默认的。如果容器中不存在”Kit”，上面最后一条语句会生成一个以“kit”为键、年龄值为 0 的元素；最后"Joe”所关联的对象会被复制到"Kit"。

成员函数 at() 会返回参数所关联对象的引用，如果键不存在，会拋出一个 out_of_range 异常。所以当我们不想生成有默认对象的元素时，应该选择使用 at() 而不是下标运算符。你可能已经发现成员函数 find() 和 equal_range() 的工作方式和之前描述的 map 是一样的。

####迭代器
unordered_map的迭代器是可以使用的，因此可以用基于范围的 for 循环来访问它的元 素，例如：
```
for(const auto& person : people)
    std::cout << person.first << " is "<< person.second <<std::endl;
```
这样就可以列出 people 容器中的全部元素。

####访问格子
可以访问 unordered_map 的个别格子及其包含的元素。可以用这个容器的成员函数 begin() 和 end() 的重载版来做到这一点，它们可以返回容器元素的迭代器。格子的索引从 0 开始，可以通过将索引值传给容器的成员函数 begin() 来获取给定位置的格子中第一个元素的迭代器。例如：
```
auto iter = people.begin(1); // Returns an iterator for the 2nd bucket
```
将索引值传给容器的成员函数 cbegin() 会返回一个 const 迭代器，它指向位于索引位置的格子中的第一个元素。这个容器的成员函数 end() 和 cend() 也有这样的版本，它们接受一个索引值，分别返回一个迭代器和一个 const 迭代器，它们指向位于指定位置的格子中的最后一个元素的下一个位置。可以输出特定格子中的元素，也就是说，需要使用循环：
```
size_t index{1};
std::cout <<"The elements in bucket["<< index << "] are:\n";
for(auto iter = people.begin(index); iter != people.end(index); ++iter)
    std::cout <<iter->first << " is " <<iter->second <<std::endl;
```
我们已经看到 unordered_map 的成员函数 bucket_count() 返回的格子个数。bucket_size() 可以返回参数指定的格子中的元素个数。bucket() 返回的是格子的索引值，包含和传入的参数键匹配的元素。可以用不同的方式来组合使用它们。例如：
```
string key {"May"};
if(people.find(key) != std::end(people))
    std::cout << "The number of elements in the bucket containing " << key << " is "<< people.bucket_size(people.bucket(key)) << std:: endl;
```
bucket_size() 的参数是 bucket() 返回的索引值。当键在容器中时，这段代码才会执行输语句。输出记录了包含键的格子中的元素个数。

下面有一个示例，可以让我们深入了解在添加元素时，我们系统中的 unorderect_map 是如何做的：
```
// Analyzing how and when the number of buckets in an unordered_map container increases
#include <iostream>                              // For standard streams
#include <iomanip>                               // For stream manipulators
#include <string>                                // For string class
#include <unordered_map>                         // For unordered_map container
#include <vector>                                // For vector container
#include <algorithm>                             // For max_element() algorithm
using std::string;
using std::unordered_map;
// Outputs number of elements in each bucket
void list_bucket_counts(const std::vector<size_t>& counts)
{
    for(size_t i {}; i < counts.size(); ++i)
    {
        std::cout << "bucket[" << std::setw(2) << i << "] = " << counts[i] << "  ";
        if((i + 1) % 6 == 0) std::cout << '\n';
    }
    std::cout << std::endl;
}
int main()
{
    unordered_map<string, size_t> people;
    float mlf {people.max_load_factor()};                         // Current maximum load factor
    size_t n_buckets {people.bucket_count()};                     // Number of buckets in container
    std::vector<size_t> bucket_counts (people.bucket_count());    // Records number of elements per bucket
    string name {"Name"};                                         // Key - with value appended
    size_t value {1};                                             // Element value
    size_t max_count {8192};                                      // Maximum number of elements to insert
    auto lf = people.load_factor();                               // Current load factor
    bool rehash {false};                                          // Records when rehash occurs
    while(mlf <= 1.5f)                                            // Loop until max load factor is 1.5
    {
        std::cout << "\n\n***************New Container***************"
              << "\nNumber of buckets: " << n_buckets << "  Maximum load factor: " << mlf << std::endl;
        // Insert max elements in container
        for(size_t n_elements {}; n_elements < max_count; ++n_elements)
        {
            lf = people.load_factor();                               // Record load factor
            people.emplace("name" + std::to_string(++value), value);
            auto new_count = people.bucket_count();                  // Current bucket count
            if(new_count > n_buckets)                                // If bucket count increases...
            {                                                        // Output info
                std::cout << "\nBucket count increased to " << new_count<< ". Load factor was " << lf << " and is now " << people.load_factor()<< "\nMaximum elements in a bucket was "<< *std::max_element(std::begin(bucket_counts), std::end(bucket_counts)) << std::endl;
                if(n_buckets <= 64)
                {
                    std::cout << "Bucket counts before increase were: " << std::endl;
                    list_bucket_counts(bucket_counts);
                }
                n_buckets = new_count;                                  // Update bucket count
                bucket_counts = std::vector < size_t > (n_buckets);     // New vector for counts
                rehash = true;                                          // Record rehash occurred
            }
            // Record current bucket counts
            for(size_t i {}; i < n_buckets; ++i)
                bucket_counts[i] = people.bucket_size(i);
            if(rehash)                                                // If the container was rehashed...
            {                                                         // ...output info
                rehash = false;                                         // Reset rehash indicator
                std::cout << "\nRehashed container. Bucket count is " << n_buckets << ". Element count is " << people.size()<< "\nMaximum element count in a bucket is now "<< *std::max_element(std::begin(bucket_counts), std::end(bucket_counts)) << std::endl;
                if(n_buckets <= 64)                                     // If no more than 64 buckets...
                {
                    std::cout << "\nBucket counts after rehash are:\n";
                    list_bucket_counts(bucket_counts);
                }
            }
        }
        std::cout << "Final state for this container is:\n"<< "Bucket count: " << people.bucket_count() << "  Element count: " << people.size()<< "  Maximum element count in a bucket: "<< *std::max_element(std::begin(bucket_counts), std::end(bucket_counts)) << std::endl;
        value = 1;                                                  // Reset key suffix
        people = unordered_map<string, size_t>();                   // New empty container
        n_buckets = people.bucket_count();
        bucket_counts = std::vector < size_t >(n_buckets);          // New vector for bucket counts
        mlf += 0.25f;                                               // Increase max load factor...
        people.max_load_factor(mlf);                                // ...and set for container
    }
}
```
上述程序会记录元素个数增加时的载入因子和格子个数。通过这种方式，可以了解容器在什么条件下是以何种方式增加格子的。因为这段代码的执行会花费相当长的时间，所以我们需要耐心等待一下。如果觉得花费的时间太长了，可以减小变量 max 的值。

这个示例以一个空的 unordered_map 容器开始，然后插入max 所指定的有限个新元素。然后通过在参数“name”的后面追加 value 递增后 to_string() 返回的字符串来构造唯一的键。 to_string() 函数定义在 string 头文件中，可以将任意数值类型转换为 string 对象。

每个格子中的元素个数记录在一个 vector 容器中。外层的 while 循环会一直进行下去，只要最大载入因子小于等于 1.5。嵌套的 for 循环会向 unordered_map 容器中插入 max_count 个元素。无论什么时候格子个数改变，都会调用辅助函数 list_bucket_counts() 来输出每个格子中的元素个数。

为了避免大量输出导致无法管理，只输出 64 个或更少的格子。当插入 max_count 个元素后，会使用更大的载入因子来生成 unordered_map，对这个新容器继续重复内会循环。这样就展示了最大载入因子如何影响格子个数的增加程度，从而导致元素被重新哈希。

对于运行结果，由于运行过程会占用太多的空间，我们可以简单概括下发生了什么。默认的格子数是 8。在添加了 8 个元素后，格子数从 8 增加到了 64，这是一个非常大的变化。当格子的最大元素个数是 2，但只有一个格子包含两个元素时；元素的总个数是 9。输出显示当载入因子接近 1.0 时，会触发格子个数的增加，格子个数下一次会乘以因子 8，从 64 到 512 (因运行系统而异)。格子个数的因子会缓慢增加到 2，所以格子个数的序列是 8、64、512、1024、2048、4096、8192。随着格子个数的增加，观察有多少空格子是很有意思的。

在我自己的系统上，所有格子的最大元素数目是 8，一点儿也不令人惊讶的是它也是最大的载入因子。在载入因子最大为 1.5 时，从一个格子中得到了 7 个元素。每次格子个数的增加都会导致容器中的所有元素被重新哈希分配到新的位置。可以很容易地对程序做一下调整，使它能够输出在格子增加前后的元素，这样就能够知道元素是如何被移动的。这显然会涉及相当大的开销，所以在保存的元素增加时，开始得到正确的格子数就变得更重要。

从系统上的输出可以了解到容器是如何将原始哈希值映射到格子的索引上的。格子数总是为 2 的幂。这样就允许格子的索引是来自于原始哈希值的固定位序列：8 个格子需要 3 位，64 个需要 6 位，512 个需要 9 位，以此类推。这就使获取格子的索引变得简单和快速。也就解释了为什么在格子数增加后，需要重新对元素进行哈希。从给定的哈希值中取 6 位要比取 3 位更能表示不同的索引值，所以一个给定的原始哈希值可能会被映射到不同的格子中。

###删除元素
可以调用 unordered_map 的成员函数 erase() 来移除元素。参数可以是标识元素的一个键或是指向它的一个迭代器。当参数是键时，erase() 会返回一个整数，它是移除元素的个数，所以 0 表示没有找到匹配的元素。当参数是迭代器时，返回的迭代器指向被移除元素后的元素。下面是一些示例：
```
auto n = people.erase ("Jim");// Returns 0 if key not found
auto iter = people.find ("May") ; // Returns end iterator if key not found
if(iter != people.end())
    iter = people.erase (iter) ;// Returns iterator for element after "May"
```
也可以移除指定的一个元素序列。例如：
```
//Remove all except 1st and last
auto iter = people.erase(++std:rbegin(people),--std:rend(people));
```
返回的迭代器指向被移除的最后一个元素的下一个位置。

成员函数 clear() 会移除所有的元素。当容器中没有元素时，成员函数 empty() 返回 true。

##unordered_multimap
###初始化
unordered_multimap 是一个允许有重复键的无序 map。因此，它支持的操作实际上和 unordered_map 容器是相同的，为了处理多个重复键所做的添加和更改除外。后面会对这些差别做些讨论。生成 unordered_multimap 的方式和 unordered_map 相同。例如：

    std:: unordered_multimap<std::string,size_t> people {{"Jim",33}, {"Joe",99}};

###添加元素
可以使用 insert()、emplace()、emplace_hint() 来添加新元素，这和 unordered_multimap 相同，只要参数和容器中的元素类型一致。这些成员函数都会返回一个指向容器中新元素的迭代器；在使用 inserted emplace() 的情况下，unordered_multimap 和 unordered_map 有些不同，unordered_multimap 的这两个函数会返回一个 pair 对象，它用来说明插入是否成功。如果不成功，也是一个迭代器。例如： 

    auto iter = people.emplace("Jan", 45);
    people.insert({"Jan", 44});
    people.emplace_hint(iter, "Jan", 46);

第 3 条语句使用了第 1 条语句返回的迭代器作为插入元素的提示符。这个提示符有时会被容器或我们的实现所忽略。

###查找元素
unordered_map 支持的成员函数 at() 和 operator[]() 对于 unordered_multimap 来说并不可用，因为潜在的重复键。唯一的选择是使用 find() 和 equal_range() 来访问元素。find() 总会返回它所找到的第一个元素的迭代器，如果找不到这个键，会返回一个结束迭代器。可以以键为参数调用 count() 来发现容器中给定键的元素个数。下面展示实际用法：
```
std:: string key{"Jan"};
auto n = people.count(key);//Number of elements stored with key
if(n == 1)
    std::cout << key << " is " << people.find(key)->second<<std::endl;
else if (n > 1)
{
    auto pr = people.equal_range (key); // pair of begin & end iterators returned
    while(pr.first != pr.second)
    {
        std::cout << key << " is " << pr.first->second << std::endl;
        ++pr.first; // Increment begin iterator
    }
}
```
当容器中只有一个 key 时，可以用 find() 来访问这个元素。如果超过一个，可以用 equal_range() 来访问这段元素。当然，在这两种情况下都可以使用 equal_range()。

让我们来看一个使用 unordered_multimap 的示例。在这个示例中也会展示一些定义函数模板来使用容器的方式。这个程序会实现一个电话簿，可以用姓名或名称来查找电话号码。此处用一个 pair 对象来封装名和姓，用一个元组来记录区号、交换码、电话号码，它们都是以 string 对象的形式保存的。使用下面的 using 简化代码：

    using std::string;
    using std::unordered_multimap;
    using Name = std::pair<string, string>；
    using Phone = std::tuple<string, string, string>;

电话号码可以用三个整数来表示，但这样组合起来更像编码而不是号码。电话号码中的每个元素都有固定个数的数字，有一些位数的组合是不允许的。如果想增加对号码检查的功能，显然用 string 对象可以使号码位数或区号的检查更简单。这里并没有包含这个功能，因为这会使本书的编码量大大增加。

为了从 istream 对象读取电话号码，对 >> 运算符进行了重载。函数如下：

    inline std::istream& operator>>(std::istream& in, Phones phone)
    {
        string area_code {},exchange {}, number {};
        in >> std::ws >> area_code >> exchange >> number; phone = std::make_tuple(area_code, exchange, number); return in;
    }

phone 是元组模板类型。这里 make_tuple() 使用从 in 读出的局部变量的值生成了一个 phone 对象。

我们可以为 Name 对象做相同的事：

    inline std::istream& operator>>(std::istream& in, Names& name)
    {
        in >> std::ws >> name.first >> name.second;
        return in;
    }

这里会丢弃从 in 读入的任何前置空格，然后读出两个 name 字符串作为 pair 对象的成员。当然，我们也需要输出功能。这里定义了 operator<<() 来为 phone 对象提供输出：

    inline std::ostream& operator<<(std::ostream& out, const Phone& phone)
    {
        std::string area_code {}, exchange {}, number {}; std::tie(area_codeA exchange, number) = phone;
        out << area_code <<" "<< exchange << " " << number; return out;
    }

这里使用函数模板 tie<>() 生了一个包含三个局部变量引用的元组。然后为了将 phone 的成员变量的值保存到局部变量中，将 phone 赋值给 tie<>() 生成的元组，后面会输出这些局部变量。或者，使用函数模板 get<>() 来访问 phone 成员变量的值。这种方法显然更好，因为能够避免上面出现的 string 对象的副本，但这里是为了展示 tie<>() 函数的使用。

为 Name 对象重载 << 是很简单的：

    inline std::ostream& operator<<(std::ostream& out, const Name& name)
    {
        out << name.first << " " << name.second;
        return out;
    }

所有的这些 I/O 函数都是内联的，所以把它们放在叫作 Record_IO.h 的头文件中。文件的开头是 #include 和 using:

    #include <string>   //  For string class
    #include <istream>  //  For istream class
    #include <ostream>  //  For ostream class
    #include <utility>  //  For pair type
    #include <tuple>    //  For tuple type
    using Name = std::pair <std::string, std::string>;
    using Phone = std::tuple <std::string, std::string,std::string>;

这个程序会使用两个关联容器一其中一个以名称作为键，另一个以电话号码为键，所以它们都会包含相同的基本信息，但它们的访问方式不同。当然有更有效率的方式来做这些，但这里我们是为了尝试 unordered_multimap 容器的使用。main() 中定义的容器如下：

    unordered_multimap<Name, Phone, NameHash> by_name {8, NameHash()};
    unordered_multimap<Phone, Name, PhoneHash> by_number {8, PhoneHash()};

这里并没有为 pair 或 tuple 对象提供默认的哈希能力，所以我们不得不自己定义它们。 这里它们分别是 NameHash 和 PhoneHash 类型的函数对象。构造函数中哈希函数对象之前的参数是格子的个数，所以这里的格子数是指定的。它们等于系统的默认值。

把这两个哈希函数类型的定义放在同一个头文件中，名为 Hash_Function_Objects.h，文件的开头是下面这些代码：

    #include <string>                                // For string class
    #include <utility>                               // For pair type
    #include <tuple>                                 // For tuple type
    using Name = std::pair < std::string, std::string >;
    using Phone = std::tuple < std::string, std::string, std::string >;

按如下方式定义 PhoneHash 类型：

    // Hash a phone number
    class PhoneHash
    {
    public:
        size_t operator()(const Phone& phone) const
        {
            return std::hash<std::string>()(std::get<0>(phone)+std::get<1>(phone)+std::get<2>(phone));
        }
    };

通过用定义在 string 头文件中的 hash<string>() 模板的特例化来处理电话号码中三个元素串联后的结果，对应地生成哈希值。下面以相似的方式定义了 HashName 类型：

    // Hash a name
    class NameHash
    {
    public:
        size_t operator()(const Name& name) const
        {
            return std::hash<std::string>()(name.first + name.second);
        }
    };

将输出操作打包放在单独的函数中：

    void show_operations()
    {
        std::cout << "Operations:\n"<< "A: Add an element.\n"<< "D: Delete elements.\n"<< "F: Find elements.\n"<< "L: List all elements.\n"<< "Q: Quit the program.\n\n";
    }

通过名称或号码列出所有的元素。我们定义了一个函数模板来处理这两种可能：

    template<typename Container>
    void list_elements(const Container& container)
    {
        for(const auto& element : container)
            std::cout << element.first << "  " << element.second << std::endl;
    }

当函数被调用时，这个模板会从使用的参数中推断出容器的类型。两个容器包含的元素是 pair 对象。by_name 容器包含的是 pair<Name，Phone>S 象类型的元素，by_number 容器包含的是 pair<Phone，Name> 对象类型的元素。因为我们己经为 Name 和 Phone 类型重载了 operator<<()，循环体会为 pair 元素的成员变量类型自动选择合适的函数输出。把这个函数模板和 My_Templates.h 头文件后面的模板放在完整的示例中。

通过名称或号码来查找元素的过程本质上是相同的，所以我们也可以为它们定义一个函数模板：

    template<typename Container>
    auto find_elements(const Container& container)
    {
        typename Container::key_type key {};
        std::cin >> key;
        auto pr = container.equal_range(key);
        return pr;
    }

这段代码对应于 C++11 标准。返回类型是依赖容器类型的 pair<> 模板类型。这是因为返回的 pair 封装的迭代器类型是特定的容器类型。这就意味着编译器不能处理函数名之前的返回类型，因为容器的类型取决于函数参数的类型，这个类型稍后才用得到。

为了能够使 C++11 编译器可以确定返回类型，必须使用尾部返回类型语法。这会允许编译器在处理完函数参数后再处理返回类型。注意，typename 关键字对模板类型的规范是至关重要的，它对于局部变量 key 的规范也至关重要。容器中 key 的类型是由容器类的成员变量 key_type 指定的，所以 key 的类型规范会自动从容器中选择正确的类型。如果需要和键关联的对象的类型，它是由成员 Container:mapped_type 指定的，Container::value_type 指定了容器元素的类型。

C++14 标准为编译器引入了推断函数返回类型的能力，因而函数模板可以这样写：

    template<typename Container>
    auto find_elements(const Container& container) -> std::pair<typename Container::const_iterator, typename Container::const_iterator>
    {
        typename Container::key_type key {};
        std::cin >> key;
        auto pr = container.equal_range(key);
        return pr;
    }

这里不需要尾部返回类型，因为编译器可以从返回值 pr 中推断出返回类型。

这个操作允许通过搜索名称或号码来查找元素，每种情况都会返回一个 pair 对象，它包含的迭代器定义了一种或另一种类型元素的范围。我们可以另外定义一个函数模板来输出这段元素：

    template<typename T>
    void list_range(const T& pr)
    {
        if(pr.first != pr.second)
        {
            for(auto iter = pr.first; iter != pr.second; ++iter)
                std::cout << "  " << iter->first << "  " << iter->second << std::endl;
        }
        else
            std::cout << "No records found.\n";
    }

如果作为参数的 pair 对象的成员变量是相同的，那么范围为空，这种情况下我们只会输出一条消息。为 Name 和 Phone 类型实现的 << 运算符函数使这个模板可以正常使用。pair 成员变量的实际类型会自动选择合适的 operatorr<< 函数。需要注意的是，在已编译的代码中，这些模板不会减少代码量。它们只是提供了一种生成所使用函数的转换机制，提供了如何使用模板的简单演示。

main() 函数包含下面这些代码：

    #include <iostream>                              // For standard streams
    #include <cctype>                                 // For toupper()
    #include <string>                                // For string class
    #include <unordered_map>                         // For unordered_map container
    #include "Record_IO.h"
    #include "My_Templates.h"
    #include "Hash_Function_Objects.h"
    using std::string;
    using std::unordered_multimap;
    using Name = std::pair < string, string >;
    using Phone = std::tuple < string, string, string >;
    // Display command prompt
    void show_operations()
    {
        std::cout << "Operations:\n"<< "A: Add an element.\n"<< "D: Delete elements.\n"<< "F: Find elements.\n"<< "L: List all elements.\n"<< "Q: Quit the program.\n\n";
    }
    int main()
    {
        unordered_multimap<Name, Phone, NameHash> by_name {8, NameHash()};
        unordered_multimap<Phone, Name, PhoneHash> by_number {8, PhoneHash()};
        show_operations();
        char choice {};                                     // Operation selection
        Phone number {};                                    // Records a number
        Name name {};                                       // Records a name
        while(std::toupper(choice) != 'Q')                  // Go until you quit...
        {
            std::cout << "Enter a command: ";
            std::cin >> choice;
            switch(std::toupper(choice))
            {
                case 'A':                                         // Add a record
                    std::cout << "Enter first & second names, area code, exchange, and number separated by spaces:\n";
                    std::cin >> name >> number;
                    by_name.emplace(name, number);                  // Create in place...
                    by_number.emplace(number, name);                // ...in both containers
                    break;
                case 'D':                                         // Delete records
                {
                    std::cout << "Enter a name: ";                  // Only find by name
                    auto pr = find_elements(by_name);
                    auto count = std::distance(pr.first, pr.second);  // Number of elements
                    if(count == 1)
                    {                                               // If there's just the one...
                        by_number.erase(pr.first->second);            // ...delete from numbers container
                        by_name.erase(pr.first);                      // ...delete from names container
                    }
                    else if(count > 1)
                    { // There's more than one
                        std::cout << "There are " << count << " records for "<< pr.first->first << ". Delete all(Y or N)? ";
                        std::cin >> choice;
                        if(std::toupper(choice) == 'Y')
                        { // Erase records from by_number container first
                            for(auto iter = pr.first; iter != pr.second; ++iter)
                            {
                                by_number.erase(iter->second);
                            }
                            by_name.erase(pr.first, pr.second);         // Now delete from by_name
                        }
                    }
                }
                break;
                case 'F':                                         // Find a record
                    std::cout << "Find by name(Y or N)? ";
                    std::cin >> choice;
                    if(std::toupper(choice) == 'Y')
                    {
                        std::cout << "Enter first name and second name: ";
                        list_range(find_elements(by_name));
                    }
                    else
                    {
                        std::cout << "Enter area code, exchange, and number separated by spaces: ";
                        list_range(find_elements(by_number));
                    }
                    break;
                case 'L':                                         //List all records
                    std::cout << "List by name(Y or N)? ";
                    std::cin >> choice;
                    if(std::toupper(choice) == 'Y')
                        list_elements(by_name);
                    else
                        list_elements(by_number);
                    break;
                case 'Q':
                    break;
                default:
                    std::cout << "Invalid command - try again.\n";
            }
        }
    }

这段代码很好理解。在输入选项后，程序就会执行相应的操作，直到输入 'q' 或 'Q'。 循环体是一条大的 switch 语句，用来选择合适的操作。

添加元素只涉及每个容器元素的生成，by_name 使用的键/对象值和 by_number 使用的是相反的。

可以用 find_elements() 来删除 by_name 容器的元素，为了保证两个容器中内容的同步，需要删除 by_number 容器的对应元素。为了能够从 by_name 容器移除多个元素，需要用定义元素范围的迭代器作为 erase() 的参数。如果所有元素的键相同，就可以以这个范围内的第一个元素的键为参数来删除它们，例如：

    by_name.erase(pr.first->first); // Delete elements with the specified key

为了查找操作，find_elements() 模板实例返回的 pair 必须直接传给 list_range() 模板的实例。编译器会自动保证生成合适的调用。最后，为了可以列出元素，必须用指定的键为参数来调用一个 list elements() 模板的实例，从而输出元素。

由于程序运行结果很占篇幅，各位读者可自行运行程序查看运行结果。
