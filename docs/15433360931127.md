Runtime的加载过程（上）

[TOC]

##map images

其中map_images函数是初始化的关键，内部完成了大量Runtime环境的初始化操作。

在map_images函数中，内部也是做了一个调用中转。然后调用到map_images_nolock函数，方法内实现共享内存优化，默认方法注册、自动释放池和散列表初始化及类的加载等操作。

```c
void _objc_init(void)
{
    // .... 各种init
    _dyld_objc_notify_register(&map_images, load_images, unmap_image);
}

void map_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]) { 
    rwlock_writer_t lock(runtimeLock); 
    return map_images_nolock(count, paths, mhdrs); 
}

void map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[]) { 

    if (firstTime) {
        // 共享内存优化
        preopt_init();
    }

    if (firstTime) {
        // 注册默认方法(load等)
        sel_init(selrefCount);
        // 自动释放池和散列表初始化
        arr_init();
    }

    if (hCount > 0) {
        // 类加载、方法注册、分类加载、协议加载等操作
        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);
    }
}
```
在_read_images函数中实现类加载，方法注册，加载虚函数表，加载协议Protocol，非延迟类方法和静态实例加载，下面是精简版带注释的源代码。

先整体梳理一遍_read_images函数内部的逻辑：
1. 加载所有类到类的gdb_objc_realized_classes表中。
2. 对所有类做重映射。
3. 将所有SEL都注册到namedSelectors表中。
4. 修复函数指针遗留。
5. 将所有Protocol都添加到protocol_map表中。
6. 对所有Protocol做重映射。
7. 初始化所有非懒加载的类，进行rw、ro等操作。
8. 遍历已标记的懒加载的类，并做初始化操作。
9. 处理所有Category，包括Class和Meta Class。
10. 初始化所有未初始化的类。

##map_images_nolock
```
map_images_nolock(unsigned mhCount, const char * const mhPaths[],
                  const struct mach_header * const mhdrs[])
```
这个函数的四个参数大概可以猜到：
* mhCount：mach-o header count，即mach-o header 个数
* mhPaths：mach-o header Paths，即header的路径数组
* mhdrs：mach-o headers，即headers

这几个参数中mhdrs应该是我们比较属性的类型了，上篇文章中其实笔者就和大家讨论过mach_header在getsectiondata中会用到,后面我们看到，第一步即是对header进行操作，将其遍历并封装成了hi对象：
```
while (i--) {
            const headerType *mhdr = (const headerType *)mhdrs[i];
            auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);
//...这里省略后续代码
```
点击方法addHeader，进入其中可以发现，其返回的是类型：header_info：
```
static header_info * addHeader(const headerType *mhdr, const char *path,
 int &totalClasses, int &unoptimizedTotalClasses)
```
因此我们确认了，这一步的操作是将
mach_header转换为header_info类型。接下来，我们只需要研究header_info这个结构体即可。进入其定义：
```
typedef struct header_info {
private:
    // Note, this is no longer a pointer, but instead an offset to a pointer
    // from this location.
    intptr_t mhdr_offset;

    // Note, this is no longer a pointer, but instead an offset to a pointer
    // from this location.
    intptr_t info_offset;

    // Do not add fields without editing ObjCModernAbstraction.hpp
public:

    header_info_rw *getHeaderInfoRW() {
        header_info_rw *preopt =
            isPreoptimized() ? getPreoptimizedHeaderRW(this) : nil;
        if (preopt) return preopt;
        else return &rw_data[0];
    }

    const headerType *mhdr() const {
        return (const headerType *)(((intptr_t)&mhdr_offset) + mhdr_offset);
    }

    void setmhdr(const headerType *mhdr) {
        mhdr_offset = (intptr_t)mhdr - (intptr_t)&mhdr_offset;
    }

    const objc_image_info *info() const {
        return (const objc_image_info *)(((intptr_t)&info_offset) + info_offset);
    }

    void setinfo(const objc_image_info *info) {
        info_offset = (intptr_t)info - (intptr_t)&info_offset;
    }

    bool isLoaded() {
        return getHeaderInfoRW()->getLoaded();
    }

    void setLoaded(bool v) {
        getHeaderInfoRW()->setLoaded(v);
    }

    bool areAllClassesRealized() {
        return getHeaderInfoRW()->getAllClassesRealized();
    }

    void setAllClassesRealized(bool v) {
        getHeaderInfoRW()->setAllClassesRealized(v);
    }

    header_info *getNext() {
        return getHeaderInfoRW()->getNext();
    }

    void setNext(header_info *v) {
        getHeaderInfoRW()->setNext(v);
    }

    bool isBundle() {
        return mhdr()->filetype == MH_BUNDLE;
    }

    const char *fname() const {
        return dyld_image_path_containing_address(mhdr());
    }

    bool isPreoptimized() const;

#if !__OBJC2__
    struct old_protocol **proto_refs;
    struct objc_module *mod_ptr;
    size_t              mod_count;
# if TARGET_OS_WIN32
    struct objc_module **modules;
    size_t moduleCount;
    struct old_protocol **protocols;
    size_t protocolCount;
    void *imageinfo;
    size_t imageinfoBytes;
    SEL *selrefs;
    size_t selrefCount;
    struct objc_class **clsrefs;
    size_t clsrefCount;    
    TCHAR *moduleName;
# endif
#endif

private:
    // Images in the shared cache will have an empty array here while those
    // allocated at run time will allocate a single entry.
    header_info_rw rw_data[];
} header_info;
```

##header_info详解
header_info封装了headerType，后者前面的文章已经说过了，其实是mach_header_64类型，封装函数如下：
```
auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);
```
其实现如下（去掉部分冗余逻辑）：
```
static header_info * addHeader(const headerType *mhdr, const char *path, int &totalClasses, int &unoptimizedTotalClasses)
{
    header_info *hi;
    if (bad_magic(mhdr)) return NULL;
    bool inSharedCache = false;
    // Look for hinfo from the dyld shared cache.
    hi = preoptimizedHinfoForHeader(mhdr);
    if (hi) {
        // Found an hinfo in the dyld shared cache.
        // Weed out duplicates.
        if (hi->isLoaded()) {
            return NULL;
        }
        inSharedCache = true;
        // Initialize fields not set by the shared cache
        // hi->next is set by appendHeader
        hi->setLoaded(true);
    }
    else 
    {
        // Weed out duplicates
        for (hi = FirstHeader; hi; hi = hi->getNext()) {
            if (mhdr == hi->mhdr()) return NULL;
        }
        // Locate the __OBJC segment
        size_t info_size = 0;
        unsigned long seg_size;
        const objc_image_info *image_info = _getObjcImageInfo(mhdr,&info_size);
        const uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&seg_size);
        if (!objc_segment  &&  !image_info) return NULL;

        // Allocate a header_info entry.
        // Note we also allocate space for a single header_info_rw in the
        // rw_data[] inside header_info.
        hi = (header_info *)calloc(sizeof(header_info) + sizeof(header_info_rw), 1);

        // Set up the new header_info entry.
        hi->setmhdr(mhdr);
        // Install a placeholder image_info if absent to simplify code elsewhere
        static const objc_image_info emptyInfo = {0, 0};
        hi->setinfo(image_info ?: &emptyInfo);

        hi->setLoaded(true);
        hi->setAllClassesRealized(NO);
    }

    {
        size_t count = 0;
        if (_getObjc2ClassList(hi, &count)) {
            totalClasses += (int)count;
            if (!inSharedCache) unoptimizedTotalClasses += count;
        }
    }
    appendHeader(hi);
    return hi;
}
```
这个函数其实很好理解：
* 判断一下当前的header在dyld的共享缓存中有没有
* 如果有的话直接设置已加载
* 如果共享缓存中没有，那么就实行“封装操作”
* 封装成功以后，加入到链表中。

###判断当前的header在dyld的共享缓存中有没有
对应的方法是：
```
hi = preoptimizedHinfoForHeader(mhdr);
```
其实现如下（去掉部分冗余逻辑）：
```
header_info *preoptimizedHinfoForHeader(const headerType *mhdr)
{
    objc_headeropt_ro_t *hinfos = opt ? opt->headeropt_ro() : nil;
    if (hinfos) return hinfos->get(mhdr);
    else return nil;
}
```
不难看出，这个共享缓存的数据都在opt内，我们推测opt应该是一个全局或者静态变量，点击进入看一下其声明以及定义：
```
// preopt: the actual opt used at runtime (nil or &_objc_opt_data)
// _objc_opt_data: opt data possibly written by dyld
// opt is initialized to ~0 to detect incorrect use before preopt_init()
static const objc_opt_t *opt = (objc_opt_t *)~0;
```
果然是个静态变量。
~0这个之前笔者已经介绍过了，其实就是0Xffffffff，这是块安全区域，防止进入其他位置导致野指针。上面的注释也大概介绍了opt初始化时机：方法preopt_init()中。
那调用时机是在哪里呢，见下图：
![](https://upload-images.jianshu.io/upload_images/1672498-ccb8b0dcd7583d4f.png?imageMogr2/auto-orient/strip|imageView2/2/w/624)

opt的定义也不复杂，代码拷贝如下：
```
struct alignas(alignof(void*)) objc_opt_t {
    uint32_t version;
    uint32_t flags;
    int32_t selopt_offset;
    int32_t headeropt_ro_offset;
    int32_t clsopt_offset;
    int32_t protocolopt_offset;
    int32_t headeropt_rw_offset;

    const objc_selopt_t* selopt() const {
        if (selopt_offset == 0) return NULL;
        return (objc_selopt_t *)((uint8_t *)this + selopt_offset);
    }
    objc_selopt_t* selopt() { 
        if (selopt_offset == 0) return NULL;
        return (objc_selopt_t *)((uint8_t *)this + selopt_offset);
    }

    struct objc_headeropt_ro_t* headeropt_ro() const {
        if (headeropt_ro_offset == 0) return NULL;
        return (struct objc_headeropt_ro_t *)((uint8_t *)this + headeropt_ro_offset);
    }

    struct objc_clsopt_t* clsopt() const { 
        if (clsopt_offset == 0) return NULL;
        return (objc_clsopt_t *)((uint8_t *)this + clsopt_offset);
    }

    struct objc_protocolopt_t* protocolopt() const { 
        if (protocolopt_offset == 0) return NULL;
        return (objc_protocolopt_t *)((uint8_t *)this + protocolopt_offset);
    }

    struct objc_headeropt_rw_t* headeropt_rw() const {
        if (headeropt_rw_offset == 0) return NULL;
        return (struct objc_headeropt_rw_t *)((uint8_t *)this + headeropt_rw_offset);
    }
};
```
看名字就很容易理解，分别是
* 类的缓存clsopt()
* 协议的缓存protocolopt()
* 头的缓存headeropt_rw()
* 选择器的缓存selopt()

###有则直接设置已加载
对应的代码：
```
if (hi) {
        // Found an hinfo in the dyld shared cache.
        // Weed out duplicates.
        if (hi->isLoaded()) {
            return NULL;
        }
        inSharedCache = true;
        // Initialize fields not set by the shared cache
        // hi->next is set by appendHeader
        hi->setLoaded(true);
    }
```
对，很好理解，唯一有问题的点在于方法isLoaded()：
```
bool isLoaded() {
    return getHeaderInfoRW()->getLoaded();
}

header_info_rw *getHeaderInfoRW() {
    header_info_rw *preopt =
        isPreoptimized() ? getPreoptimizedHeaderRW(this) : nil;
    if (preopt) return preopt;
    else return &rw_data[0];
}

/***********************************************************************
* Return YES if we have a valid optimized shared cache.
**********************************************************************/
bool isPreoptimized(void) 
{
    return preoptimized;
}

static bool preoptimized;
```
preoptimized也是个静态变量。和前面的opt一样！也就是说dlyd的共享缓存其实是由两个变量来决定的一个opt存放动态缓存数据，另一个preoptimized存放标志位。

###如果共享缓存中没有，那么就实行“封装操作”
```
// Didn't find an hinfo in the dyld shared cache.
// Weed out duplicates
for (hi = FirstHeader; hi; hi = hi->getNext()) {
    if (mhdr == hi->mhdr()) return NULL;
}
// Locate the __OBJC segment
size_t info_size = 0;
unsigned long seg_size;
const objc_image_info *image_info = _getObjcImageInfo(mhdr,&info_size);
const uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&seg_size);
if (!objc_segment  &&  !image_info) return NULL;

// Allocate a header_info entry.
// Note we also allocate space for a single header_info_rw in the
// rw_data[] inside header_info.
hi = (header_info *)calloc(sizeof(header_info) + sizeof(header_info_rw), 1);

// Set up the new header_info entry.
hi->setmhdr(mhdr);
// Install a placeholder image_info if absent to simplify code elsewhere
static const objc_image_info emptyInfo = {0, 0};
hi->setinfo(image_info ?: &emptyInfo);

hi->setLoaded(true);
hi->setAllClassesRealized(NO);
```
以上代码我们逐步分析：
```
for (hi = FirstHeader; hi; hi = hi->getNext()) {
    if (mhdr == hi->mhdr()) return NULL;
}
```
如果是第一次进入该方法，FirstHeader是没有值的。因此这个循环走不进去。
接着是下面三行代码：
```
const objc_image_info *image_info = _getObjcImageInfo(mhdr,&info_size);
const uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&seg_size);
if (!objc_segment  &&  !image_info) return NULL;
```
我们点进去看就会发现，_getObjcImageInfo获取的是__DATA,__objc_imageinfo的数据；而第二行是获取的segment为__OBJC的数据。
那这两个区或者段的作用是什么呢，大家可以参考这篇文章：[深入理解Macho文件（二）- 消失的__OBJC段与新生的__DATA段](https://links.jianshu.com/go?to=https%3A%2F%2Fsatanwoo.github.io%2F2017%2F06%2F29%2FMacho-2%2F)

其实不看这篇文章我们也大概能了解其含义，因为第一行代码返回的是数据结构objc_image_info，其定义如下：
```
// Description of an Objective-C image.
// __DATA,__objc_imageinfo stores one of these.
typedef struct objc_image_info {
    uint32_t version; // currently 0
    uint32_t flags;

#if __cplusplus >= 201103L
  private:
    enum : uint32_t {
        IsReplacement       = 1<<0,  // used for Fix&Continue, now ignored
        SupportsGC          = 1<<1,  // image supports GC
        RequiresGC          = 1<<2,  // image requires GC
        OptimizedByDyld     = 1<<3,  // image is from an optimized shared cache
        CorrectedSynthesize = 1<<4,  // used for an old workaround, now ignored
        IsSimulated         = 1<<5,  // image compiled for a simulator platform
        HasCategoryClassProperties  = 1<<6,  // class properties in category_t

        SwiftVersionMaskShift = 8,
        SwiftVersionMask    = 0xff << SwiftVersionMaskShift  // Swift ABI version

    };
   public:
    enum : uint32_t {
        SwiftVersion1   = 1,
        SwiftVersion1_2 = 2,
        SwiftVersion2   = 3,
        SwiftVersion3   = 4
    };

  public:
    bool isReplacement()   const { return flags & IsReplacement; }
    bool supportsGC()      const { return flags & SupportsGC; }
    bool requiresGC()      const { return flags & RequiresGC; }
    bool optimizedByDyld() const { return flags & OptimizedByDyld; }
    bool hasCategoryClassProperties() const { return flags & HasCategoryClassProperties; }
    bool containsSwift()   const { return (flags & SwiftVersionMask) != 0; }
    uint32_t swiftVersion() const { return (flags & SwiftVersionMask) >> SwiftVersionMaskShift; }
#endif
} objc_image_info;
```
代码量有点多，但其实我们只需要关注#if __cplusplus >= 201103L以上的部分即可。其中#if __cplusplus >= 201103L的含义大概说一下，就是判断编译器环境是不是支持C++11。
因此：
>version这个字段目前永远为0。flags是用于做表示需要支持的特性的，比如是否需要/支持 Garbage Collection。

后面的分配内存的代码很好理解了：
```
hi = (header_info *)calloc(sizeof(header_info) + sizeof(header_info_rw), 1);
```
分配的空间大小是header_info大小与header_info_rw大小之和，原因在注释中也说了，只是要预留给header_info_rw这个结构体内的数组。等等，这个header_info_rw又是什么呢？我们再次点击他，进入其定义：
```
// Split out the rw data from header info.  For now put it in a huge array
// that more than exceeds the space needed.  In future we'll just allocate
// this in the shared cache builder.
typedef struct header_info_rw {
    bool getLoaded() const {
        return isLoaded;
    }
    void setLoaded(bool v) {
        isLoaded = v ? 1: 0;
    }
    bool getAllClassesRealized() const {
        return allClassesRealized;
    }
    void setAllClassesRealized(bool v) {
        allClassesRealized = v ? 1: 0;
    }
    header_info *getNext() const {
        return (header_info *)(next << 2);
    }
    void setNext(header_info *v) {
        next = ((uintptr_t)v) >> 2;
    }

private:
    uintptr_t isLoaded              : 1;
    uintptr_t allClassesRealized    : 1;
    uintptr_t next                  : 62;
} header_info_rw;
```
对，里面存放了可读写的数据。这里先不多说这个结构体了，如果后面碰到的话，我们再继续研究。

我们继续看代码，
```
hi->setmhdr(mhdr);
```
终于！封装mhdr的方法出现了。于是迫不及待的点进去看，却发现如下代码：
```
const headerType *mhdr() const {
    return (const headerType *)(((intptr_t)&mhdr_offset) + mhdr_offset);
}

void setmhdr(const headerType *mhdr) {
    mhdr_offset = (intptr_t)mhdr - (intptr_t)&mhdr_offset;
}
```
what?不是应该是将mhdr设置到header_info里，并进行存储么。为什么是一串 offset和类型转换。笔者看到这段代码的一开始是懵逼的。直到看到了这篇文章：
[C语言--通过结构体成员的地址获取结构体变量的地址](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fchampionhengyi%2Farticle%2Fdetails%2F70313355)大概意思是：
>C 语言的结构体可以将不同类型的对象聚合到一个对象中，在内存中，编译器按照成员列表顺序分别为每个结构体变量成员分配内存，但由于 C 的内存对齐机制以及不同机器间的差异，各个成员之间可能会有间隙，所以不能简单的通过成员类型所占的字长来推断其它成员或结构体对象的地址。
如果要计算结构体中某成员相对于该结构体首地址的偏移量，一般第一个反应就是该成员的地址与结构体对象的首地址之间的字节数。

所以，这么设计其实是从效率和空间上都是非常明智的选择：我们只需要计算出mhdr的内存地址，从而获取该对象，而不要手动将其赋值给当前对象。省略了很多赋值的麻烦步骤。

最后的最后，我们看代码：
```
static const objc_image_info emptyInfo = {0, 0};
hi->setinfo(image_info ?: &emptyInfo);

hi->setLoaded(true);
hi->setAllClassesRealized(NO);
```

###封装成功以后，加入到链表中
```
/***********************************************************************
* appendHeader.  Add a newly-constructed header_info to the list. 
**********************************************************************/
void appendHeader(header_info *hi)
{
    // Add the header to the header list. 
    // The header is appended to the list, to preserve the bottom-up order.
    HeaderCount++;
    hi->setNext(NULL);
    if (!FirstHeader) {
        // list is empty
        FirstHeader = LastHeader = hi;
    } else {
        if (!LastHeader) {
            // list is not empty, but LastHeader is invalid - recompute it
            LastHeader = FirstHeader;
            while (LastHeader->getNext()) LastHeader = LastHeader->getNext();
        }
        // LastHeader is now valid
        LastHeader->setNext(hi);
        LastHeader = hi;
    }
}
```
从以上代码看出header_info原来还是个链表：
```
//获取下一个data：
header_info *getNext() {
    return getHeaderInfoRW()->getNext();
}
//设置下一个数据
void setNext(header_info *v) {
    getHeaderInfoRW()->setNext(v);
}
```
本文主要介绍了方法addheader，调用栈位于：
```
_objc_init
|-dyld_objc_notify_register
  |-map_2_images
    |-map_images_nolock
      |-addHeader
```
本文也顺便带出了dyld的共享缓存在runtime中的使用。

##sel_init()分析
sel_init()的调用栈如下
```
-| _objc_init()
   -| _dyld_objc_notify_register
     -| map_images_nolock()
       -| sel_init()
```
其代码如下：
```
/***********************************************************************
* sel_init
* Initialize selector tables and register selectors used internally.
**********************************************************************/
void sel_init(size_t selrefCount)
{
    // save this value for later
    SelrefCount = selrefCount;

    builtins = preoptimizedSelectors();
    if (PrintPreopt  &&  builtins) {
        uint32_t occupied = builtins->occupied;
        uint32_t capacity = builtins->capacity;
        
        _objc_inform("PREOPTIMIZATION: using selopt at %p", builtins);
        _objc_inform("PREOPTIMIZATION: %u selectors", occupied);
        _objc_inform("PREOPTIMIZATION: %u/%u (%u%%) hash table occupancy",
                     occupied, capacity,
                     (unsigned)(occupied/(double)capacity*100));
    }

#define s(x) SEL_##x = sel_registerNameNoLock(#x, NO)
#define t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO)

    sel_lock();
    
    s(load);
    s(initialize);
    t(resolveInstanceMethod:, resolveInstanceMethod);    
    t(resolveClassMethod:, resolveClassMethod);
    t(.cxx_construct, cxx_construct);
    t(.cxx_destruct, cxx_destruct);
    s(retain);
    s(release);
    s(autorelease);
    s(retainCount);
    s(alloc);
    t(allocWithZone:, allocWithZone);
    s(dealloc);
    s(copy);
    s(new);
    t(forwardInvocation:, forwardInvocation);
    t(_tryRetain, tryRetain);
    t(_isDeallocating, isDeallocating);
    s(retainWeakReference);
    s(allowsWeakReference);

    sel_unlock();

#undef s
#undef t
}
```
宏的用法，以上的代码中有一个宏：
```
#define s(x) SEL_##x = sel_registerNameNoLock(#x, NO)
```
可能比较少人会了解##和#的用法。
```
#表示：对应变量字符串化
##表示：把宏参数名与宏定义代码序列中的标识符连接在一起，形成一个新的标识符
```
因此s(load);会被替换成：
```
SEL_load = sel_registerNameNoLock("load",NO);
```
而
```
t(resolveInstanceMethod:, resolveInstanceMethod);
```
会被改写成：
```
SEL_resolveInstanceMethod = sel_registerNameNoLock("resolveInstanceMethod:",NO);
```
我们进入sel_registerNameNoLock方法的定义中看：
```
SEL sel_registerNameNoLock(const char *name, bool copy) {
    return __sel_registerName(name, 0, copy);  // NO lock, maybe copy
}
```
而__sel_registerName的定义如下：
```
static SEL __sel_registerName(const char *name, int lock, int copy) 
{
    SEL result = 0;

    if (lock) selLock.assertUnlocked();
    else selLock.assertWriting();

    if (!name) return (SEL)0;

    result = search_builtins(name);
    if (result) return result;
    
    if (lock) selLock.read();
    if (namedSelectors) {
        result = (SEL)NXMapGet(namedSelectors, name);
    }
    if (lock) selLock.unlockRead();
    if (result) return result;

    // No match. Insert.

    if (lock) selLock.write();

    if (!namedSelectors) {
        namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, 
                                          (unsigned)SelrefCount);
    }
    if (lock) {
        // Rescan in case it was added while we dropped the lock
        result = (SEL)NXMapGet(namedSelectors, name);
    }
    if (!result) {
        result = sel_alloc(name, copy);
        // fixme choose a better container (hash not map for starters)
        NXMapInsert(namedSelectors, sel_getName(result), result);
    }

    if (lock) selLock.unlockWrite();
    return result;
}
```
可以发现，这个方法其实是讲selector添加到MapTable中，关于MapTable这里先不做介绍了，后面的文章会给出详细分析。
需要注意的是，被注册的selector会被放到一个静态变量namedSelectors中：
```
static NXMapTable *namedSelectors;
```

##arr_init()分析
arr_init的作用是自动释放迟的初始化，那arr_init究竟做了哪些事情，有哪些我们需要注意的地方，本文就带大家一起分析该方法。
```
void arr_init(void) 
{
    AutoreleasePoolPage::init();
    SideTableInit();
}
```
AutoreleasePoolPage和SideTable会在另外的章节介绍。

##NonlazyClass
来自Stack Overflow的[Objective-C: What is a lazy class?](https://stackoverflow.com/questions/15315668/objective-c-what-is-a-lazy-class)：

>It's all about a class implementing or not a +load method.

>All the classes implemented in a given image file have a reference in a list stored in the "\_\_DATA, \_\_objc_classlist, regular, no_dead_strip" binary's section. This list allows the runtime system to keep track of all the classes stored in such file. However, not all of the classes need to be realized when the program starts up. That's why when a class implements a +load method, it also has a reference in a list stored in the "__DATA, \__objc_nlclslist, regular, no_dead_strip" section.

>So, _getObjc2NonlazyClassList retrieves the list of classes that do implement a +load method and are so called non-lazy. _getObjc2ClassList retrieves a list of all the classes in a image file, including the classes that don't have a +load method (and are called lazy) and the non-lazy ones. Non-lazy classes must be realized when the program starts up. Lazy classes, on the other hand, don't need to be realized immediately. This may be delayed until the class receives a message for the first time, for example (that's the reason for them to be considered "lazy").

>The same is true for categories, by the way.

某个类中有 load 方法，该类就变成了 none-lazy class，而 none-lazy class 会提前实现 realizeClass 方法，后者会将里面的一些属性进行改变。比如调用 setHasCxxCtor 设置 hasCxxCtor 等。

none-lazy class 是一个很特殊的区中取出来的 class 列表，至于苹果为什么这么设计，原因笔者估计就是为了提高效率：只有 load 方法实现的类中才提前设置它的一些属性，否则，只加载最基本的数据即可。

##_read_images
```c
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)
{
    header_info *hi;
    uint32_t hIndex;
    size_t count;
    size_t i;
    Class *resolvedFutureClasses = nil;
    size_t resolvedFutureClassCount = 0;
    static bool doneOnce;
    TimeLogger ts(PrintImageTimes);

#define EACH_HEADER \
    hIndex = 0;         \
    hIndex < hCount && (hi = hList[hIndex]); \
    hIndex++
    if (!doneOnce) {
        doneOnce = YES;
        // 实例化存储类的哈希表，并且根据当前类数量做动态扩容
        int namedClassesSize = (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
        gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
    }
    
    // 由编译器读取类列表，并将所有类添加到类的哈希表中，并且标记懒加载的类并初始化内存空间
    for (EACH_HEADER) {
        if (! mustReadClasses(hi)) {
            continue;
        }

        bool headerIsBundle = hi->isBundle();
        bool headerIsPreoptimized = hi->isPreoptimized();

        /** 将新类添加到哈希表中 */
        // 从编译后的类列表中取出所有类，获取到的是一个classref_t类型的指针
        classref_t *classlist = _getObjc2ClassList(hi, &count);
        for (i = 0; i < count; i++) {
            // 数组中会取出OS_dispatch_queue_concurrent、OS_xpc_object、NSRunloop等系统类，例如CF、Fundation、libdispatch中的类。以及自己创建的类
            Class cls = (Class)classlist[i];
            // 通过readClass函数获取处理后的新类，内部主要操作ro和rw结构体
            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);
    
            // 初始化所有懒加载的类需要的内存空间
            if (newCls != cls  &&  newCls) {
                // 将懒加载的类添加到数组中
                resolvedFutureClasses = (Class *)
                    realloc(resolvedFutureClasses, 
                            (resolvedFutureClassCount+1) * sizeof(Class));
                            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;
            }
        }
    }
    // 将未映射Class和Super Class重映射，被remap的类都是非懒加载的类
    if (!noClassesRemapped()) {
        for (EACH_HEADER) {
            // 重映射Class，注意是从_getObjc2ClassRefs函数中取出类的引用
            Class *classrefs = _getObjc2ClassRefs(hi, &count);
            for (i = 0; i < count; i++) {
                remapClassRef(&classrefs[i]);
            }
            // 重映射父类
            classrefs = _getObjc2SuperRefs(hi, &count);
            for (i = 0; i < count; i++) {
                remapClassRef(&classrefs[i]);
            }
        }
    }
    
    // 将所有SEL都注册到哈希表中，是另外一张哈希表
    static size_t UnfixedSelectors;
    sel_lock();
    for (EACH_HEADER) {
        if (hi->isPreoptimized()) continue;

        bool isBundle = hi->isBundle();
    
        SEL *sels = _getObjc2SelectorRefs(hi, &count);
        UnfixedSelectors += count;
        for (i = 0; i < count; i++) {
            const char *name = sel_cname(sels[i]);
            // 注册SEL的操作
            sels[i] = sel_registerNameNoLock(name, isBundle);
        }
    }
    // 修复旧的函数指针调用遗留
    for (EACH_HEADER) {
        message_ref_t *refs = _getObjc2MessageRefs(hi, &count);
        if (count == 0) continue;
        for (i = 0; i < count; i++) {
            // 内部将常用的alloc、objc_msgSend等函数指针进行注册，并fix为新的函数指针
            fixupMessageRef(refs+i);
        }
    }
    // 遍历所有协议列表，并且将协议列表加载到Protocol的哈希表中
    for (EACH_HEADER) {
        extern objc_class OBJC_CLASS_$_Protocol;
        // cls = Protocol类，所有协议和对象的结构体都类似，isa都对应Protocol类
        Class cls = (Class)&OBJC_CLASS_$_Protocol;
        assert(cls);
        // 获取protocol哈希表
        NXMapTable *protocol_map = protocols();
        bool isPreoptimized = hi->isPreoptimized();
        bool isBundle = hi->isBundle();
        
        // 从编译器中读取并初始化Protocol
        protocol_t **protolist = _getObjc2ProtocolList(hi, &count);
        for (i = 0; i < count; i++) {
            readProtocol(protolist[i], cls, protocol_map, 
                         isPreoptimized, isBundle);
        }
    }
    // 修复协议列表引用，优化后的images可能是正确的，但是并不确定
    for (EACH_HEADER) {
        // 需要注意到是，下面的函数是_getObjc2ProtocolRefs，和上面的_getObjc2ProtocolList
        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &count);
        for (i = 0; i < count; i++) {
            remapProtocolRef(&protolist[i]);
        }
    }
    // 实现非懒加载的类，对于load方法和静态实例变量
    for (EACH_HEADER) {
        classref_t *classlist = 
            _getObjc2NonlazyClassList(hi, &count);
        for (i = 0; i < count; i++) {
        Class cls = remapClass(classlist[i]);
        if (!cls) continue;
        // 实现所有非懒加载的类(实例化类对象的一些信息，例如rw)
            realizeClass(cls);
        }
    }
    // 遍历resolvedFutureClasses数组，实现所有懒加载的类
    if (resolvedFutureClasses) {
        for (i = 0; i < resolvedFutureClassCount; i++) {
            // 实现懒加载的类
            realizeClass(resolvedFutureClasses[i]);
            resolvedFutureClasses[i]->setInstancesRequireRawIsa(false/*inherited*/);
        }
        free(resolvedFutureClasses);
    }
    
    // 发现和处理所有Category
    for (EACH_HEADER) {
        // 外部循环遍历找到当前类，查找类对应的Category数组
        category_t **catlist = 
            _getObjc2CategoryList(hi, &count);
        bool hasClassProperties = hi->info()->hasCategoryClassProperties();
        // 内部循环遍历当前类的所有Category
        for (i = 0; i < count; i++) {
            category_t *cat = catlist[i];
            Class cls = remapClass(cat->cls);

            // 首先，通过其所属的类注册Category。如果这个类已经被实现，则重新构造类的方法列表。
            bool classExists = NO;
            if (cat->instanceMethods ||  cat->protocols  
                ||  cat->instanceProperties) 
            {
                // 将Category添加到对应Class的value中，value是Class对应的所有category数组
                addUnattachedCategoryForClass(cat, cls, hi);
                // 将Category的method、protocol、property添加到Class
                if (cls->isRealized()) {
                    remethodizeClass(cls);
                    classExists = YES;
                }
            }

            // 这块和上面逻辑一样，区别在于这块是对Meta Class做操作，而上面则是对Class做操作
            // 根据下面的逻辑，从代码的角度来说，是可以对原类添加Category的
            if (cat->classMethods  ||  cat->protocols  
                ||  (hasClassProperties && cat->_classProperties)) 
            {
                addUnattachedCategoryForClass(cat, cls->ISA(), hi);
                if (cls->ISA()->isRealized()) {
                    remethodizeClass(cls->ISA());
                }
            }
        }
    }

    // 初始化从磁盘中加载的所有类，发现Category必须是最后执行的
        // 从runtime objc4-532版本源码来看，DebugNonFragileIvars字段一直是-1，所以不会进入这个方法中
    if (DebugNonFragileIvars) {
        realizeAllClasses();
    }
#undef EACH_HEADER
}
```
这个方法作用就是读取各个 section 中的数据并放到缓存中，这里的缓存大部分都是全局静态变量，载体就是我们之前分析的 hashmap，我们先回顾上一篇文章中的所有 hashmap：
pendingInitializeMap 、 category_map 、nonmeta_class_map 、future_named_class_map 、remapped_class_map 、protocol_map 、gdb_objc_realized_classes。
我们把这里面的 hashmap 分为几类：

关于 class 的：
gdb_objc_realized_classes、remapped_class_map、future_named_class_map、nonmeta_class_map

关于 protocol 的：
protocol_map

关于 category 的：
category_map

本文带大家了解 _read_images 方法的过程中会揭开其中的几个 hashmap 的作用。

精简一下上面的代码：
```
if (!doneOnce) {
    gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
}

for (EACH_HEADER) {
    classref_t *classlist = _getObjc2ClassList(hi, &count);
}

for (EACH_HEADER) {
    Class *classrefs = _getObjc2ClassRefs(hi, &count);
}

for (EACH_HEADER) {
    SEL *sels = _getObjc2SelectorRefs(hi, &count);
}

for (EACH_HEADER) {
    message_ref_t *refs = _getObjc2MessageRefs(hi, &count);
}

for (EACH_HEADER) {
    protocol_t **protolist = _getObjc2ProtocolList(hi, &count);
}

for (EACH_HEADER) {
    protocol_t **protolist = _getObjc2ProtocolRefs(hi, &count);
}

for (EACH_HEADER) {
    classref_t *classlist = _getObjc2NonlazyClassList(hi, &count);
}

for (EACH_HEADER) {
    category_t **catlist = 
        _getObjc2CategoryList(hi, &count);
}
```
发现很多类似的方法，这些方法在笔者之前的文章中已经讲解过，都是获取 section 的方法：
```
//      function name                 content type     section name
GETSECT(_getObjc2SelectorRefs,        SEL,             "__objc_selrefs"); 
GETSECT(_getObjc2MessageRefs,         message_ref_t,   "__objc_msgrefs"); 
GETSECT(_getObjc2ClassRefs,           Class,           "__objc_classrefs");
GETSECT(_getObjc2SuperRefs,           Class,           "__objc_superrefs");
GETSECT(_getObjc2ClassList,           classref_t,      "__objc_classlist");
GETSECT(_getObjc2NonlazyClassList,    classref_t,      "__objc_nlclslist");
GETSECT(_getObjc2CategoryList,        category_t *,    "__objc_catlist");
GETSECT(_getObjc2NonlazyCategoryList, category_t *,    "__objc_nlcatlist");
GETSECT(_getObjc2ProtocolList,        protocol_t *,    "__objc_protolist");
GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    "__objc_protorefs");
```
因此 _read_images 方法的作用也很明显了： 把对应 section 里的数据取出来，然后进行加工，最后添加到缓存中。虽然说 _read_images 只有几百行，但其中又会调用其他很多方法，因此总的来说 _read_images 方法还是比较复杂的。这里只摘取一些 section 数据获取后的处理流程。

###__objc_classlist 与 __objc_classrefs
之前已经大概说过 __objc_classlist 这个 section 表示的是项目中全部类列表，与之关联的一个 section 为： __objc_classrefs ，表示项目中被引用的类列表。列一张表看一下：

|区 	|__objc_classlist |__objc_classrefs|
|----|----|----|
|含义 	|项目中全部类列表 	|项目中被引用的类列表|
|对应方法| 	_getObjc2ClassList |	_getObjc2ClassRefs|
|对应全局变量 |	gdb_objc_realized_classes |	noClassesRemapped|

这两个 section 的数据都在 _read_images 方法中，这里做个大概讲解：
创建：
```
gdb_objc_realized_classes =
    NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
```
插入：
```
- Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);
    - addNamedClass(cls, mangledName, replacing);
        - NXMapInsert(gdb_objc_realized_classes, name, cls);
```

###__objc_selrefs
|区 	|__objc_selrefs|
|----|----|
|含义 |	方法列表|
|方法名| 	_getObjc2SelectorRefs|
|对应全局变量| 	namedSelectors|

创建
```
namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, (unsigned)SelrefCount);
```
插入
```
NXMapInsert(namedSelectors, sel_getName(result), result);
```

删除
```
result = (SEL)NXMapGet(namedSelectors, name);
```

用一幅图总结一下本文涉及到的 section:
![](https://upload-images.jianshu.io/upload_images/1672498-b26ddd99394833e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/539)

###class相关的hash表
_read_images中讲解了 class 相关的多个 hash 表：
* gdb_objc_realized_classes
* remapped_class_map
* future_named_class_map
* nonmeta_class_map

####gdb_objc_realized_classes
>gdb_objc_realized_classes is actually a list of named classes not in the dyld shared cache, whether realized or not.

这段文字出现在文件 objc_runtime_new.mm 中：
![](https://upload-images.jianshu.io/upload_images/1672498-bb7f714823f5cc8e.png?imageMogr2/auto-orient/strip|imageView2/2/w/720)
gdb_objc_realized_classes 是一系列的类列表，这些类不管有没有实现都不在 dyld 的共享缓存中。
全局搜索 gdb_objc_realized_classes，我们可以看到一系列方法，
![](https://upload-images.jianshu.io/upload_images/1672498-ebecf30966f5015c.png?imageMogr2/auto-orient/strip|imageView2/2/w/295)
这些方法涉及到对于 gdb_objc_realized_classes 的一系列操作，包括：
获取某个类：
```
static Class getClass_impl(const char *name)
{
    runtimeLock.assertLocked();
    // allocated in _read_images
    assert(gdb_objc_realized_classes);
    // Try runtime-allocated table
    Class result = (Class)NXMapGet(gdb_objc_realized_classes, name);
    if (result) return result;
    // Try table from dyld shared cache
    return getPreoptimizedClass(name);
}
```
添加某个类：
```
/***********************************************************************
* addNamedClass
* Adds name => cls to the named non-meta class map.
* Warns about duplicate class names and keeps the old mapping.
* Locking: runtimeLock must be held by the caller
**********************************************************************/
static void addNamedClass(Class cls, const char *name, Class replacing = nil)
{
    runtimeLock.assertWriting();
    Class old;
    if ((old = getClass(name))  &&  old != replacing) {
        inform_duplicate(name, old, cls);

        // getNonMetaClass uses name lookups. Classes not found by name 
        // lookup must be in the secondary meta->nonmeta table.
        addNonMetaClass(cls);
    } else {
        NXMapInsert(gdb_objc_realized_classes, name, cls);
    }
    assert(!(cls->data()->flags & RO_META));

    // wrong: constructed classes are already realized when they get here
    // assert(!cls->isRealized());
}
```
移除某个类：
```
/***********************************************************************
* removeNamedClass
* Removes cls from the name => cls map.
* Locking: runtimeLock must be held by the caller
**********************************************************************/
static void removeNamedClass(Class cls, const char *name)
{
    runtimeLock.assertWriting();
    assert(!(cls->data()->flags & RO_META));
    if (cls == NXMapGet(gdb_objc_realized_classes, name)) {
        NXMapRemove(gdb_objc_realized_classes, name);
    } else {
        // cls has a name collision with another class - don't remove the other
        // but do remove cls from the secondary metaclass->class map.
        removeNonMetaClass(cls);
    }
}
```
而初始化的位置就是我们所知道的 _read_images 方法中：
```
// namedClasses
// Preoptimized classes don't go in this table.
// 4/3 is NXMapTable's load factor
int namedClassesSize = 
    (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3;
gdb_objc_realized_classes =
    NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);
```
add 方法的也位于 _read_images 调用栈中：
```
- void _objc_init(void)
    - void _dyld_objc_notify_register();
        - void map_2_images();
            - void map_images_nolock();
                - void _read_images();
                    - Class readClass();
                        - void addNamedClass();
```
需要注意的是：`addNamedClass(cls, mangledName, replacing);`的第二个参数是 mangledName， 也就是从 section 中获取的数据。

现在看来，gdb_objc_realized_classes 的作用已经很明显了，即是对所有的类进行缓存：从对应的 section 中读取所有的类，取出来后以 mangledName 作为键，以 class 结构体作为值。

####remapped_class_map
 全局搜索 remapped_class_map 我们看到如下结果：
 ![](https://upload-images.jianshu.io/upload_images/1672498-6c9e01230efe80fe.png?imageMogr2/auto-orient/strip|imageView2/2/w/477)
可以发现，关于 remapped_class_map 的一些引用都位于文件 objc-runtime-new.m 中。

其中，获取 remapped_class_map 的方法为：
```
static NXMapTable *remappedClasses(bool create)
{
    static NXMapTable *remapped_class_map = nil;
    runtimeLock.assertLocked();
    if (remapped_class_map) return remapped_class_map;
    if (!create) return nil;
    // remapped_class_map is big enough to hold CF's classes and a few others
    INIT_ONCE_PTR(remapped_class_map, 
                  NXCreateMapTable(NXPtrValueMapPrototype, 32), 
                  NXFreeMapTable(v));
    return remapped_class_map;
```
在该方法上下查看，可以发现一系列和 remap 相关的函数：
![](https://upload-images.jianshu.io/upload_images/1672498-6b1f1c10bd35036b.png?imageMogr2/auto-orient/strip|imageView2/2/w/402)
这里总结如下：

添加一个 class：
```
static void addRemappedClass(Class oldcls, Class newcls) {
    runtimeLock.assertWriting();
    if (PrintFuture) {
        _objc_inform("FUTURE: using %p instead of %p for %s", 
                     (void*)newcls, (void*)oldcls, oldcls->nameForLogging());
    }
    void *old;
    old = NXMapInsert(remappedClasses(YES), oldcls, newcls);
    assert(!old);
}
```
将一个 class 进行 remap：
```
static Class remapClass(classref_t cls)
{
    return remapClass((Class)cls);
}
```

大家注意一下，这边的参数类型是 classref_t，经过前面的文章，我们了解到，这是从 secion 中取出来的原始的 class 类型。
这个方法是在 _read_images 方法中被调用的：
```
// Realize non-lazy classes (for +load methods and static instances)
for (EACH_HEADER) {
    classref_t *classlist =
    _getObjc2NonlazyClassList(hi, &count);
    for (i = 0; i < count; i++) {
        Class cls = remapClass(classlist[i]);
        if (!cls) continue;
        realizeClass(cls);
    }
}
```
remapped_class_map 相关的方法介绍完了，但大家可能还是一头雾水
* 什么是 remapped class ？
* 为什么 class 要 remap？
* remap 过程？

本文就带大家研究一下 remap class 的实现。

**分析**
**什么是 remapped class ？**

remap class，字面意思是 重新映射 class，那肯定有一个映射者和映射结果。所以我们看方法：
```
static Class remapClass(classref_t cls) {
    return remapClass((Class)cls);
}
```
参数类型是 classref_t，返回值类型是 Class。classref_t 我们很熟悉了，在前面的文章中我们知道，section 为 __objc_classlist 以及 __objc_nlclslist 的返回类型都是 classref_t，也就是说， remap 的参数从这两个 section 中拿到的。其实现如下：
```
static Class remapClass(Class cls)
{
    runtimeLock.assertLocked();
    Class c2;
    if (!cls) return nil;
    NXMapTable *map = remappedClasses(NO);
    if (!map  ||  NXMapMember(map, cls, (void**)&c2) == NX_MAPNOTAKEY) {
        return cls;
    } else {
        return c2;
    }
}
```
从该方法实现中可以看出：map 的键是 cls，也就是 section 中拿到的 cls，而 value 就是我们 remap 的结果。而 remap 的 操作肯定是在方法
```
static void addRemappedClass(Class oldcls, Class newcls) {
}
```
中的，因为两个参数分别为 oldcls ，newcls。

**为什么 Class 要 remap？**
要知道原因，我们看一下调用时机，他们都在方法 readClass 中，其调用栈为：
全局搜索 addRemappedClass，发现其实调用时机只有一个地方,且调用栈为：
```
void _objc_init()
    void map_2_images()
        void map_images_nolock()
            void _read_images()
                Class readClass()
                    void addRemappedClass()
```
其实现为：
```
Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)
{
    const char *mangledName = cls->mangledName();
    if (missingWeakSuperclass(cls)) {
        addRemappedClass(cls, nil);
        cls->superclass = nil;
        return nil;
    }

    Class replacing = nil;
    if (Class newCls = popFutureNamedClass(mangledName)) {
        if (newCls->isSwift()) {
            _objc_fatal("Can't complete future class request for '%s' "
                        "because the real class is too big.", 
                        cls->nameForLogging());
        }
        
        class_rw_t *rw = newCls->data();
        const class_ro_t *old_ro = rw->ro;
        memcpy(newCls, cls, sizeof(objc_class));
        rw->ro = (class_ro_t *)newCls->data();
        newCls->setData(rw);
        freeIfMutable((char *)old_ro->name);
        free((void *)old_ro);
        
        addRemappedClass(cls, newCls);
        
        replacing = cls;
        cls = newCls;
    }
    
    if (headerIsPreoptimized  &&  !replacing) {
        assert(getClass(mangledName));
    } else {
        addNamedClass(cls, mangledName, replacing);
    }
    
    // for future reference: shared cache never contains MH_BUNDLEs
    if (headerIsBundle) {
        cls->data()->flags |= RO_FROM_BUNDLE;
        cls->ISA()->data()->flags |= RO_FROM_BUNDLE;
    }
    
    return cls;
}
```
如上代码可知，有两个分支有机会进入方法 addRemappedClass，一个是 missingWeakSuperclass 方法是否为真，另外一个是 popFutureNamedClass(mangledName) 方法返回是否为真。这里会有两个概念
* WeakSuperclass
* FutureNamedClass

而这两个条件为true 的情况就是需要 remap 的情况。

####weak-linked class
missingWeakSuperclass 的源码为：
```
/***********************************************************************
* missingWeakSuperclass
* Return YES if some superclass of cls was weak-linked and is missing.
**********************************************************************/
static bool  missingWeakSuperclass(Class cls) {
    assert(!cls->isRealized());

    if (!cls->superclass) {
        // superclass nil. This is normal for root classes only.
        return (!(cls->data()->flags & RO_ROOT));
    } else {
        // superclass not nil. Check if a higher superclass is missing.
        Class supercls = remapClass(cls->superclass);
        assert(cls != cls->superclass);
        assert(cls != supercls);
        if (!supercls) return YES;
        if (supercls->isRealized()) return NO;
        return missingWeakSuperclass(supercls);
    }
}
```
代码的注释已经一目了然：该函数就是判断某个 class 的父类是否是 weak-linked 并且缺失了。那 什么叫做 weak-linked？比如 NSObject 是否是 weak-linbked ？很显然不是的。那么什么是 weak-linked？
>weak-linked
我们开发的时候，都会使用最新的SDK，但是为了让老的设备可以下载并运行我们的应用，就要将Deployment Target设置成之前系统的版本号。例如我们应用使用iOS 8.1的SDK，Deployment Target设置成iOS 5.1.1，虽然我们开发的时候使用的是8.1的SDK，但是程序运行在的设备中却可能是6.0 or 7.0的SDK上，按照苹果的说法，如果我们应用使用了最新SDK引入的特性，比如符号、函数等，那么在版本较旧的设备上就运行不了。下面是苹果官方文档的一段话：
Normally, if an application uses a new feature in a framework, it is unable to run on earlier versions of the framework that do not support that feature. Such applications would either fail to launch or crash when an attempt to use the feature was made.
那么为什么我们使用最新的SDK开发的应用却可以运行在旧的系统中呢？答案是使用了弱引用。资料里面说过，我们自己创建的framework，如果需要做版本兼容，那么就要对今后加入的符号等使用弱引用，使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL，下面就是教我们怎样定义弱引用。有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用整个framework就好，方法就是链接的时候使用 -weak_framework frameworkName
```
// weak link the function
extern int MyFunction() __attribute__((weak_import));
// weak link the variable
extern int MyVariable __attribute__((weak_import));
```
这么一来， missingWeakSuperclass 的作用的作用就不言而喻了：查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing，祖宗类里有 missing weak-linked 的，则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -> nil。

####future_named_class_map
在前面的文章中我们分析过，存储在 hash map 中数据的几个类：
* gdb_objc_realized_classes：已经实现过的类列表
* remapped_class_map，已经重映射的类列表

今天我们就讲另外一个和上面两个息息相关的 hash map ：future_named_class_map，它存储了 ”未来“要实现的类？

创建:
```
static NXMapTable *future_named_class_map = nil;
static NXMapTable *futureNamedClasses()
{
    runtimeLock.assertWriting();
    if (future_named_class_map) return future_named_class_map;
    // future_named_class_map is big enough for CF's classes and a few others
    future_named_class_map =  NXCreateMapTable(NXStrValueMapPrototype, 32);
    return future_named_class_map;
}
```
以上代码清晰明了：如果有的话使用，没有的话则创建。

获取:
```
OBJC_EXPORT Class objc_getFutureClass(const char *name) 
    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0)
    OBJC_ARC_UNAVAILABLE;
```
这个方法需要注意，它是在 runtime.h 中声明的，也就是说，他其实是对外暴露的，可以直接使用，不过看其注释：
```
/*** Used by CoreFoundation's toll-free bridging.
Return the id of the named class.
@return The id of the named class, or an uninitialized class
structure that will be used for the class when and if it does
get loaded.
@warning Do not call this function yourself.
***/
```
注意最后一句： 不要主动调用这个函数！

我们来看一下这个函数的实现：
```
Class objc_getFutureClass(const char *name)
{
    Class cls;
    cls = look_up_class(name, YES, NO);
    if (cls) {
        if (PrintFuture) {
            _objc_inform("FUTURE: found %p already in use for %s", 
                         (void*)cls, name);
        }
        return cls;
    }
    return _objc_allocateFutureClass(name);
}
```
其中函数 look_up_class 这里先不多做介绍了，里面逻辑较多，而且不是这个函数的重点，重点是最后一句：_objc_allocateFutureClass(name) 它才是从 hash map 中获取对应值的函数，其实现如下 ：
```
Class _objc_allocateFutureClass(const char *name)
{
    rwlock_writer_t lock(runtimeLock);
    Class cls;
    NXMapTable *map = futureNamedClasses();
    if ((cls = (Class)NXMapGet(map, name))) {
        // Already have a future class for this name.
        return cls;
    }
    cls = _calloc_class(sizeof(objc_class));
    addFutureNamedClass(name, cls);
    return cls;
}
```
很容易理解：有的话就通过方法 NXMapGet 取出来，没有的话则创建。

移除:
```
static Class popFutureNamedClass(const char *name)
{
    runtimeLock.assertWriting();

    Class cls = nil;

    if (future_named_class_map) {
        cls = (Class)NXMapKeyFreeingRemove(future_named_class_map, name);
        if (cls && NXCountMapTable(future_named_class_map) == 0) {
            NXFreeMapTable(future_named_class_map);
            future_named_class_map = nil;
        }
    }

    return cls;
}
```
这个方法有点熟悉了，正是上文介绍的 remap 的条件之一。上一篇文章讲述的是第一个条件，本文讲的是第二个条件。这两个条件无论哪一个符合都会调用方法：addRemappedClass，即向 remapped_class_map 中插入数据。这里画一幅图加深理解：
![](https://upload-images.jianshu.io/upload_images/1672498-908955a0c5589aeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/994)
以上这张图已经说明了之前笔者分析的两个 map 与本文的 map 之间的关系。

不管是上一篇文章的 remapped_class_map 还是本文的 future_named_class_map 里面的数据都是空。remapped_class_map 有数据是需要一定条件，而 future_named_class_map 有数据也是需要先 add 的，所以大家对于这两个 map 只需要有个大概的概念就好。


下面我们要重点分析realizeClass函数。

##realizeClass
```c
static Class realizeClass(Class cls)
{
    const class_ro_t *ro;
    class_rw_t *rw;
    Class supercls;
    Class metacls;
    bool isMeta;

    if (!cls) return nil;
    if (cls->isRealized()) return cls;
    assert(cls == remapClass(cls));

    // fixme verify class is not in an un-dlopened part of the shared cache?
    // 最开始cls->data是指向ro的
    ro = (const class_ro_t *)cls->data();
    if (ro->flags & RO_FUTURE) {
        // This was a future class. rw data is already allocated.
        // rw已经初始化并且分配内存空间
        rw = cls->data();
        ro = cls->data()->ro;
        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);
    } else {
        // Normal class. Allocate writeable class data.
        // 如果rw并不存在，则为rw分配空间
        rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);
        rw->ro = ro;
        rw->flags = RW_REALIZED|RW_REALIZING;
        // 将rw传入setData函数，等于cls->data()重新指向rw
        cls->setData(rw);
    }

    isMeta = ro->flags & RO_META;

    rw->version = isMeta ? 7 : 0;  // old runtime went up to 6


    // Choose an index for this class.
    // Sets cls->instancesRequireRawIsa if indexes no more indexes are available
    cls->chooseClassArrayIndex();

    // Realize superclass and metaclass, if they aren't already.
    // This needs to be done after RW_REALIZED is set above, for root classes.
    // This needs to be done after class index is chosen, for root metaclasses.
    
    // 如果父类或元类没有初始化，必须先初始化父类或元类
    supercls = realizeClass(remapClass(cls->superclass));
    metacls = realizeClass(remapClass(cls->ISA()));

#if SUPPORT_NONPOINTER_ISA
    // Disable non-pointer isa for some classes and/or platforms.
    // Set instancesRequireRawIsa.
    bool instancesRequireRawIsa = cls->instancesRequireRawIsa();
    bool rawIsaIsInherited = false;
    static bool hackedDispatch = false;

    if (DisableNonpointerIsa) {
        // Non-pointer isa disabled by environment or app SDK version
        instancesRequireRawIsa = true;
    }
    else if (!hackedDispatch  &&  !(ro->flags & RO_META)  &&  
             0 == strcmp(ro->name, "OS_object")) 
    {
        // hack for libdispatch et al - isa also acts as vtable pointer
        hackedDispatch = true;
        instancesRequireRawIsa = true;
    }
    else if (supercls  &&  supercls->superclass  &&  
             supercls->instancesRequireRawIsa()) 
    {
        // This is also propagated by addSubclass() 
        // but nonpointer isa setup needs it earlier.
        // Special case: instancesRequireRawIsa does not propagate 
        // from root class to root metaclass
        instancesRequireRawIsa = true;
        rawIsaIsInherited = true;
    }
    
    if (instancesRequireRawIsa) {
        cls->setInstancesRequireRawIsa(rawIsaIsInherited);
    }
// SUPPORT_NONPOINTER_ISA
#endif

    // Update superclass and metaclass in case of remapping
    cls->superclass = supercls;
    cls->initClassIsa(metacls);

    // Reconcile instance variable offsets / layout.
    // This may reallocate class_ro_t, updating our ro variable.
    if (supercls  &&  !isMeta) reconcileInstanceVariables(cls, supercls, ro);

    // Set fastInstanceSize if it wasn't set already.
    cls->setInstanceSize(ro->instanceSize);

    // Copy some flags from ro to rw
    if (ro->flags & RO_HAS_CXX_STRUCTORS) {
        cls->setHasCxxDtor();
        if (! (ro->flags & RO_HAS_CXX_DTOR_ONLY)) {
            cls->setHasCxxCtor();
        }
    }

    // Connect this class to its superclass's subclass lists
    if (supercls) {
        addSubclass(supercls, cls);
    } else {
        addRootClass(cls);
    }

    // 初始化class_rw_t
    methodizeClass(cls);

    return cls;
}
```
那么从上述源码中就可以发现，类的初始信息本来其实是存储在class_ro_t中的，并且ro本来是指向cls->data()的，也就是说bits.data()得到的是ro，但是在运行过程中创建了class_rw_t，并将cls->data指向rw，同时将初始信息ro赋值给rw中的ro。最后在通过setData(rw)设置data。那么此时bits.data()得到的就是rw，之后再去检查是否有分类，同时将分类的方法，属性，协议列表整合存储在class_rw_t的方法，属性及协议列表中。

在上面的代码中我们还发现了两个函数，addRootClass和addSubclass函数，这两个函数的职责是将某个类的子类串成一个列表，大致是下面的链接顺序。由此可知，我们是可以通过class_rw_t，获取到当前类的所有子类。
```c
superClass.firstSubclass -> subClass1.nextSiblingClass -> subClass2.nextSiblingClass -> ...
```

通过上述对源码的分析，我们对class_rw_t内存储方法、属性、协议列表的过程有了更清晰的认识，那么接下来探寻class_rw_t中是如何存储信息的。

##class_rw_t中是如何存储信息

初始化rw和ro之后，rw的method list、protocol list、property list都是空的，需要在下面methodizeClass函数中进行赋值。函数中会把ro的list都取出来，然后赋值给rw，如果在运行时动态修改，也是对rw做的操作。所以ro中存储的是编译时就已经决定的原数据，rw才是运行时动态修改的数据。
```c
static void methodizeClass(Class cls)
{
    bool isMeta = cls->isMetaClass();
    auto rw = cls->data();
    auto ro = rw->ro;
    
    // 将ro中的method list、property list、protocol list加载到rw中，也就是将编译时确定的只读参数加载到rw的读写可操作参数中
    method_list_t *list = ro->baseMethods();
    if (list) {
        prepareMethodLists(cls, &list, 1, YES, isBundleClass(cls));
        rw->methods.attachLists(&list, 1);
    }

    property_list_t *proplist = ro->baseProperties;
    if (proplist) {
        rw->properties.attachLists(&proplist, 1);
    }

    protocol_list_t *protolist = ro->baseProtocols;
    if (protolist) {
        rw->protocols.attachLists(&protolist, 1);
    }

    // Root classes get bonus method implementations if they don't have 
    // them already. These apply before category replacements.
    
    // 处理根元类的一些操作，添加一个objc_noop_imp的函数指针
    if (cls->isRootMetaclass()) {
        // root metaclass
        addMethod(cls, SEL_initialize, (IMP)&objc_noop_imp, "", NO);
    }

    // 获取到类对应的Category，并将Category从哈希表中移除
    category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);
    // 添加Category到类中，添加到rw中
    attachCategories(cls, cats, false /*don't flush caches*/);
    
    if (cats) free(cats);
}
```
而prepareMethodLists的实现：
```
static void 
prepareMethodLists(Class cls, method_list_t **addedLists, int addedCount, 
                   bool baseMethods, bool methodsFromBundle)
{
    runtimeLock.assertWriting();

    if (addedCount == 0) return;

    // Don't scan redundantly
    bool scanForCustomRR = !cls->hasCustomRR();
    bool scanForCustomAWZ = !cls->hasCustomAWZ();

    // There exist RR/AWZ special cases for some class's base methods. 
    // But this code should never need to scan base methods for RR/AWZ: 
    // default RR/AWZ cannot be set before setInitialized().
    // Therefore we need not handle any special cases here.
    if (baseMethods) {
        assert(!scanForCustomRR  &&  !scanForCustomAWZ);
    }

    // Add method lists to array.
    // Reallocate un-fixed method lists.
    // The new methods are PREPENDED to the method list array.

    for (int i = 0; i < addedCount; i++) {
        method_list_t *mlist = addedLists[i];
        assert(mlist);

        // Fixup selectors if necessary
        if (!mlist->isFixedUp()) {
            fixupMethodList(mlist, methodsFromBundle, true/*sort*/);
        }

        // Scan for method implementations tracked by the class's flags
        if (scanForCustomRR  &&  methodListImplementsRR(mlist)) {
            cls->setHasCustomRR();
            scanForCustomRR = false;
        }
        if (scanForCustomAWZ  &&  methodListImplementsAWZ(mlist)) {
            cls->setHasCustomAWZ();
            scanForCustomAWZ = false;
        }
    }
}
```
在fixupMethodList中会对方法列表进行排序：
```
static void 
fixupMethodList(method_list_t *mlist, bool bundleCopy, bool sort)
{
    runtimeLock.assertWriting();
    assert(!mlist->isFixedUp());

    // fixme lock less in attachMethodLists ?
    sel_lock();
    
    // Unique selectors in list.
    for (auto& meth : *mlist) {
        const char *name = sel_cname(meth.name);
        meth.name = sel_registerNameNoLock(name, bundleCopy);
    }
    
    sel_unlock();

    // Sort by selector address.
    if (sort) {
        method_t::SortBySELAddress sorter;
        std::stable_sort(mlist->begin(), mlist->end(), sorter);
    }
    
    // Mark method list as uniqued and sorted
    mlist->setFixedUp();
}
```
也就是根据SEL的地址进行稳定排序，这样确保相同SEL的method能保持原有的顺序，也就确保了分类的method会在类的method之前。


![类结构体](https://upload-images.jianshu.io/upload_images/270478-6a2db4356819af18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

##参考
iOS开发之runtime（17）：_dyld_objc_notify_register方法介绍
https://www.jianshu.com/p/0056401bde7c

iOS开发之runtime（18）：header_info详解(1)
https://www.jianshu.com/p/f97841c4fb57

iOS开发之runtime（19）：header_info详解(2)
https://www.jianshu.com/p/a03643581ccf

iOS开发之runtime(27): _read_images 浅析
https://www.jianshu.com/p/5bbb654656c4


iOS开发之 runtime(29) ：gdb_objc_realized_classes 浅析
https://www.jianshu.com/p/9718a1ba5519

iOS开发之 runtime(30) ：remapped_class_map 浅析
https://www.jianshu.com/p/1a316934f29c


